<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pushdown Automata (PDA) - CS305</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; background: #0f172a; color: #e2e8f0; }
.slide { display: none; min-height: 100vh; padding: 40px 60px; position: relative; }
.slide.active { display: flex; flex-direction: column; justify-content: center; }
.slide-number { position: absolute; bottom: 20px; right: 40px; color: #64748b; font-size: 14px; }
.nav { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; z-index: 100; }
.nav button { background: #334155; border: 1px solid #475569; color: #e2e8f0; padding: 8px 20px; border-radius: 8px; cursor: pointer; font-size: 14px; transition: all 0.2s; }
.nav button:hover { background: #475569; }
.nav button:disabled { opacity: 0.3; cursor: not-allowed; }
.progress { position: fixed; top: 0; left: 0; height: 3px; background: linear-gradient(90deg, #3b82f6, #8b5cf6); transition: width 0.3s; z-index: 100; }
h1 { font-size: 2.8em; margin-bottom: 20px; background: linear-gradient(135deg, #3b82f6, #8b5cf6); -webkit-background-clip: text; -webkit-text-fill-color: transparent; line-height: 1.2; }
h2 { font-size: 2em; margin-bottom: 16px; color: #93c5fd; }
h3 { font-size: 1.4em; margin-bottom: 12px; color: #a5b4fc; }
p, li { font-size: 1.15em; line-height: 1.7; color: #cbd5e1; margin-bottom: 10px; }
.subtitle { font-size: 1.3em; color: #94a3b8; margin-bottom: 30px; }
.two-col { display: grid; grid-template-columns: 1fr 1fr; gap: 40px; align-items: start; }
.center { text-align: center; }
.mt { margin-top: 20px; }
.diagram { background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 24px; font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; font-size: 1em; line-height: 1.6; white-space: pre; overflow-x: auto; margin: 16px 0; color: #a5f3fc; }
.diagram.small { font-size: 0.85em; }
.key-idea { background: linear-gradient(135deg, rgba(59,130,246,0.15), rgba(139,92,246,0.15)); border-left: 4px solid #3b82f6; border-radius: 0 12px 12px 0; padding: 20px 24px; margin: 16px 0; }
.key-idea h3 { margin-bottom: 8px; }
.warning { background: rgba(245,158,11,0.12); border-left: 4px solid #f59e0b; border-radius: 0 12px 12px 0; padding: 20px 24px; margin: 16px 0; }
.warning h3 { color: #fbbf24; }
.analogy { background: rgba(16,185,129,0.12); border-left: 4px solid #10b981; border-radius: 0 12px 12px 0; padding: 20px 24px; margin: 16px 0; }
.analogy h3 { color: #34d399; }
table { border-collapse: collapse; margin: 16px 0; width: auto; }
th, td { border: 1px solid #475569; padding: 10px 16px; text-align: center; }
th { background: #334155; color: #93c5fd; font-weight: 600; }
td { background: #1e293b; color: #e2e8f0; }
tr.highlight td { background: rgba(59,130,246,0.2); }
.fade-in { animation: fadeIn 0.5s ease-in; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
ul { padding-left: 24px; }
ul li { margin-bottom: 8px; }
code { background: #1e293b; padding: 2px 8px; border-radius: 4px; font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; color: #a5f3fc; font-size: 0.95em; }

/* === SIMULATOR SHARED STYLES === */
.sim-container { background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 16px; margin-top: 12px; }
.sim-controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-bottom: 12px; }
.sim-controls input[type="text"] { background: #0f172a; border: 1px solid #475569; color: #e2e8f0; padding: 6px 12px; border-radius: 6px; font-family: 'SF Mono', monospace; font-size: 14px; width: 140px; }
.sim-controls button { background: #334155; border: 1px solid #475569; color: #e2e8f0; padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 13px; transition: all 0.2s; }
.sim-controls button:hover { background: #475569; }
.sim-controls button:disabled { opacity: 0.4; cursor: not-allowed; }
.sim-tape { display: flex; gap: 2px; margin: 8px 0; flex-wrap: wrap; }
.sim-tape-cell { width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border: 1px solid #475569; border-radius: 4px; font-family: 'SF Mono', monospace; font-size: 16px; background: #0f172a; color: #e2e8f0; transition: all 0.3s; }
.sim-tape-cell.consumed { background: #1e293b; color: #475569; }
.sim-tape-cell.current { background: rgba(250,204,21,0.25); border-color: #fbbf24; color: #fbbf24; }
.sim-stack-wrap { display: flex; flex-direction: column; align-items: center; min-height: 160px; }
.sim-stack-cell { width: 48px; height: 30px; display: flex; align-items: center; justify-content: center; border: 1px solid #475569; border-radius: 4px; font-family: 'SF Mono', monospace; font-size: 15px; background: #0f172a; color: #93c5fd; margin: 1px 0; transition: all 0.4s; }
.sim-stack-cell.push-anim { animation: pushIn 0.35s ease-out; }
.sim-stack-cell.pop-anim { animation: popOut 0.35s ease-in forwards; }
@keyframes pushIn { from { opacity: 0; transform: translateY(-18px); } to { opacity: 1; transform: translateY(0); } }
@keyframes popOut { from { opacity: 1; transform: translateY(0); } to { opacity: 0; transform: translateY(-18px); } }
.sim-log { max-height: 140px; overflow-y: auto; font-size: 12px; color: #94a3b8; font-family: 'SF Mono', monospace; line-height: 1.6; margin-top: 6px; }
.sim-log .log-entry { padding: 1px 0; }
.sim-verdict { font-size: 16px; font-weight: 700; margin-top: 8px; padding: 6px 12px; border-radius: 6px; display: inline-block; }
.sim-verdict.accept { background: rgba(34,197,94,0.2); color: #4ade80; }
.sim-verdict.reject { background: rgba(239,68,68,0.2); color: #f87171; }
.sim-svg-state { fill: #1e293b; stroke: #475569; stroke-width: 2; }
.sim-svg-state.active-state { stroke: #3b82f6; stroke-width: 3; filter: drop-shadow(0 0 6px rgba(59,130,246,0.6)); }
.sim-svg-state.accept-state { stroke: #475569; stroke-width: 2; }
.sim-svg-text { fill: #e2e8f0; font-family: 'SF Mono', monospace; font-size: 13px; text-anchor: middle; dominant-baseline: central; }
.sim-svg-label { fill: #94a3b8; font-family: 'SF Mono', monospace; font-size: 10px; text-anchor: middle; }
.sim-svg-arrow { stroke: #475569; stroke-width: 1.5; fill: none; marker-end: url(#arrowhead); }
.sim-inner-two-col { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
.purple-flash { animation: purpleFlash 0.6s ease; }
@keyframes purpleFlash { 0%,100% { filter: none; } 50% { filter: drop-shadow(0 0 12px rgba(139,92,246,0.9)); } }

/* === CFG STEP-THROUGH STYLES === */
.cfg-step-container { background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 16px; }
.cfg-step-info { font-size: 13px; color: #94a3b8; margin-bottom: 8px; }
.cfg-step-action { font-size: 14px; padding: 8px 12px; border-radius: 6px; margin: 8px 0; }
.cfg-step-action.expand { background: rgba(139,92,246,0.15); color: #a78bfa; border-left: 3px solid #8b5cf6; }
.cfg-step-action.match { background: rgba(34,197,94,0.15); color: #4ade80; border-left: 3px solid #22c55e; }
.cfg-step-action.start { background: rgba(59,130,246,0.15); color: #93c5fd; border-left: 3px solid #3b82f6; }
.cfg-step-action.accept { background: rgba(34,197,94,0.2); color: #4ade80; border-left: 3px solid #22c55e; font-weight: 700; }

/* === QUIZ STYLES === */
.quiz-container { max-width: 700px; margin: 0 auto; }
.quiz-question { background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 24px; margin-bottom: 16px; }
.quiz-question h3 { color: #93c5fd; margin-bottom: 16px; font-size: 1.1em; }
.quiz-btn-row { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 12px; }
.quiz-btn { background: #334155; border: 1px solid #475569; color: #e2e8f0; padding: 10px 24px; border-radius: 8px; cursor: pointer; font-size: 15px; transition: all 0.2s; min-width: 80px; }
.quiz-btn:hover { background: #475569; }
.quiz-btn.correct { background: rgba(34,197,94,0.3); border-color: #22c55e; color: #4ade80; }
.quiz-btn.wrong { background: rgba(239,68,68,0.3); border-color: #ef4444; color: #f87171; }
.quiz-btn:disabled { cursor: not-allowed; }
.quiz-explanation { font-size: 14px; color: #94a3b8; padding: 12px; background: #0f172a; border-radius: 8px; margin-top: 10px; display: none; line-height: 1.6; }
.quiz-score { font-size: 1.5em; text-align: center; margin-top: 20px; color: #93c5fd; }

/* === ENHANCEMENT: DFA vs PDA Race (Slide 3) === */
.pda-race-bar { display: flex; gap: 6px; margin-bottom: 12px; flex-wrap: wrap; }
.pda-race-bar button { background: #334155; border: 1px solid #475569; color: #e2e8f0; padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 13px; transition: all 0.2s; font-family: 'SF Mono', monospace; }
.pda-race-bar button:hover { background: #475569; }
.pda-race-bar button.active { background: rgba(59,130,246,0.3); border-color: #3b82f6; }
.pda-race-panels { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
.pda-race-panel { background: #1e293b; border: 1px solid #334155; border-radius: 10px; padding: 14px; min-height: 220px; }
.pda-race-panel h4 { font-size: 0.95em; margin-bottom: 10px; }
.pda-race-states { display: flex; gap: 4px; margin-bottom: 10px; flex-wrap: wrap; }
.pda-race-state { width: 38px; height: 30px; display: flex; align-items: center; justify-content: center; border: 2px solid #475569; border-radius: 6px; font-family: 'SF Mono', monospace; font-size: 12px; background: #0f172a; color: #94a3b8; transition: all 0.3s; }
.pda-race-state.lit { border-color: #3b82f6; color: #93c5fd; background: rgba(59,130,246,0.15); box-shadow: 0 0 8px rgba(59,130,246,0.4); }
.pda-race-state.fail { border-color: #ef4444; color: #f87171; background: rgba(239,68,68,0.15); box-shadow: 0 0 8px rgba(239,68,68,0.4); }
.pda-race-verdict { font-size: 13px; font-weight: 600; margin-top: 8px; min-height: 20px; }
.pda-race-stack-area { display: flex; flex-direction: column; align-items: center; gap: 2px; }
.pda-race-stack-cell { width: 36px; height: 24px; display: flex; align-items: center; justify-content: center; border: 1px solid #475569; border-radius: 4px; font-family: 'SF Mono', monospace; font-size: 13px; background: #0f172a; color: #93c5fd; transition: all 0.35s; }
.pda-race-stack-cell.push-in { animation: pushIn 0.35s ease-out; }
.pda-race-stack-cell.pop-out { animation: popOut 0.35s ease-in forwards; }

/* === ENHANCEMENT: Animated PDA Machine SVG (Slide 4) === */
.pda-mach-wrap { margin: 16px 0; }
.pda-mach-controls { display: flex; gap: 8px; margin-top: 10px; align-items: center; }
.pda-mach-controls button { background: #334155; border: 1px solid #475569; color: #e2e8f0; padding: 6px 16px; border-radius: 6px; cursor: pointer; font-size: 13px; transition: all 0.2s; }
.pda-mach-controls button:hover { background: #475569; }
.pda-mach-status { font-size: 14px; color: #94a3b8; font-family: 'SF Mono', monospace; margin-left: 12px; }
@keyframes pda-mach-cell-flash { 0%,100% { fill: #0f172a; } 50% { fill: rgba(250,204,21,0.3); } }
@keyframes pda-mach-state-glow { 0%,100% { filter: none; } 50% { filter: drop-shadow(0 0 10px rgba(34,197,94,0.8)); } }

/* === ENHANCEMENT: Transition Explorer (Slide 6) === */
.pda-trx-buttons { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 12px; }
.pda-trx-btn { background: #1e293b; border: 1px solid #475569; color: #cbd5e1; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 12px; font-family: 'SF Mono', monospace; transition: all 0.2s; text-align: left; flex: 1 1 45%; min-width: 160px; }
.pda-trx-btn:hover { background: #334155; }
.pda-trx-btn.active { background: rgba(139,92,246,0.2); border-color: #8b5cf6; color: #a78bfa; }
.pda-trx-anim-panel { background: #1e293b; border: 1px solid #334155; border-radius: 10px; padding: 16px; }
.pda-trx-stacks { display: flex; gap: 24px; justify-content: center; align-items: flex-start; margin-top: 12px; }
.pda-trx-stack-col { text-align: center; }
.pda-trx-stack-col h5 { font-size: 12px; color: #94a3b8; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 1px; }
.pda-trx-stack-wrap { display: flex; flex-direction: column; align-items: center; gap: 2px; min-height: 100px; }
.pda-trx-stack-cell { width: 40px; height: 26px; display: flex; align-items: center; justify-content: center; border: 1px solid #475569; border-radius: 4px; font-family: 'SF Mono', monospace; font-size: 14px; background: #0f172a; color: #93c5fd; transition: all 0.4s; }
.pda-trx-stack-cell.glow { box-shadow: 0 0 10px rgba(139,92,246,0.6); border-color: #8b5cf6; }
.pda-trx-stack-cell.new-cell { animation: pushIn 0.4s ease-out; }
.pda-trx-stack-cell.fade-out { animation: popOut 0.4s ease-in forwards; }
.pda-trx-explain { font-size: 13px; color: #94a3b8; margin-top: 10px; padding: 8px 12px; background: #0f172a; border-radius: 6px; min-height: 36px; line-height: 1.5; }
@keyframes pda-trx-arrow-pulse { 0%,100% { stroke: #8b5cf6; stroke-width: 2; } 50% { stroke: #a78bfa; stroke-width: 3; } }
</style>
</head>
<body>

<div class="progress" id="progress"></div>

<!-- ============================================================ -->
<!-- SLIDE 1: Title -->
<!-- ============================================================ -->
<div class="slide active" id="s1">
  <div class="center">
    <h1>Pushdown Automata (PDA)</h1>
    <p class="subtitle">CS305 -- Formal Language Theory</p>
    <div class="diagram" style="display:inline-block; text-align:left; font-size:0.9em;">
   _______________________________________________
  |                                               |
  |      NFA  +  Stack  =  Pushdown Automaton     |
  |                                               |
  |   Recognizes: Context-Free Languages (CFLs)   |
  |   Equivalent to: Context-Free Grammars (CFGs) |
  |_______________________________________________|
    </div>
    <p style="margin-top: 30px; color: #64748b;">Use arrow keys or buttons to navigate. ~21 slides.</p>
  </div>
  <div class="slide-number">1 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 2: Big Picture -->
<!-- ============================================================ -->
<div class="slide" id="s2">
  <h2>The Big Picture: PDA = NFA + Stack</h2>

  <div class="two-col">
    <div>
      <p>A <strong>Pushdown Automaton</strong> takes everything an NFA can do and adds a <strong>stack</strong> -- an infinite, last-in-first-out memory.</p>
      <ul class="mt">
        <li><strong>DFA/NFA</strong> -- recognizes regular languages</li>
        <li><strong>PDA</strong> -- recognizes context-free languages</li>
        <li><strong>Turing Machine</strong> -- recognizes recursively enumerable languages</li>
      </ul>
      <div class="key-idea mt">
        <h3>Key Idea</h3>
        <p>The stack lets the PDA "remember" unbounded amounts of information, but only in LIFO order. This is exactly the extra power needed to match things like nested parentheses and a<sup>n</sup>b<sup>n</sup>.</p>
      </div>
    </div>
    <div>
      <div class="diagram" style="font-size:0.85em;">
  The Chomsky Hierarchy
  =====================

  +-------------------------------+
  |  Recursively Enumerable       |
  |  (Turing Machine)             |
  |                               |
  |  +-------------------------+  |
  |  |  Context-Free           |  |
  |  |  (PDA) <-- YOU ARE HERE |  |
  |  |                         |  |
  |  |  +-------------------+  |  |
  |  |  |  Regular          |  |  |
  |  |  |  (DFA / NFA)      |  |  |
  |  |  +-------------------+  |  |
  |  +-------------------------+  |
  +-------------------------------+
      </div>
    </div>
  </div>

  <div class="slide-number">2 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 3: Why a Stack? -->
<!-- ============================================================ -->
<div class="slide" id="s3">
  <h2>Why Do We Need a Stack?</h2>

  <div class="two-col">
    <div>
      <p>A DFA has <strong>finite memory</strong> -- just its current state. It cannot count beyond a fixed bound.</p>
      <p class="mt">Consider the language L = { a<sup>n</sup>b<sup>n</sup> | n &ge; 0 }:</p>
      <ul>
        <li>A DFA would need a separate state for each count of a's</li>
        <li>But n can be <em>any</em> number -- we'd need infinitely many states</li>
        <li>The Pumping Lemma proves no DFA can do this</li>
      </ul>
      <p class="mt"><strong>Solution:</strong> Give the machine a stack! Push each <code>a</code>, then pop one for each <code>b</code>. Accept if stack is empty.</p>

      <div class="analogy mt">
        <h3>Analogy: Cafeteria Tray Stack</h3>
        <p>Think of a spring-loaded cafeteria tray dispenser. You can only see and grab the <strong>top tray</strong>. You push trays on and pop them off. You never reach into the middle. That's exactly how a PDA's stack works.</p>
      </div>
    </div>
    <div>
      <h3>DFA vs PDA Race Demo</h3>
      <div class="pda-race-bar" id="pda_race_bar">
        <button onclick="pda_raceRun(1)">Try a<sup>1</sup>b<sup>1</sup></button>
        <button onclick="pda_raceRun(2)">Try a<sup>2</sup>b<sup>2</sup></button>
        <button onclick="pda_raceRun(3)">Try a<sup>3</sup>b<sup>3</sup></button>
        <button onclick="pda_raceRun(4)">Try a<sup>4</sup>b<sup>4</sup></button>
        <button onclick="pda_raceRun(5)">Try a<sup>5</sup>b<sup>5</sup></button>
      </div>
      <div class="pda-race-panels">
        <div class="pda-race-panel">
          <h4 style="color:#f87171;">DFA (finite memory)</h4>
          <div style="font-size:11px;color:#94a3b8;margin-bottom:6px;">Only 3 counting states available:</div>
          <div class="pda-race-states" id="pda_race_dfa_states">
            <div class="pda-race-state" id="pda_race_dq0">q0</div>
            <div class="pda-race-state" id="pda_race_dq1">q1</div>
            <div class="pda-race-state" id="pda_race_dq2">q2</div>
            <div class="pda-race-state" id="pda_race_dq3">q3</div>
          </div>
          <div style="font-size:11px;color:#94a3b8;">Reading input:</div>
          <div id="pda_race_dfa_tape" style="font-family:'SF Mono',monospace;font-size:13px;color:#e2e8f0;min-height:20px;margin:4px 0;"></div>
          <div class="pda-race-verdict" id="pda_race_dfa_verdict"></div>
        </div>
        <div class="pda-race-panel">
          <h4 style="color:#4ade80;">PDA (stack memory)</h4>
          <div style="font-size:11px;color:#94a3b8;margin-bottom:6px;">Stack grows as needed:</div>
          <div class="pda-race-stack-area" id="pda_race_pda_stack"></div>
          <div style="font-size:11px;color:#94a3b8;margin-top:6px;">Reading input:</div>
          <div id="pda_race_pda_tape" style="font-family:'SF Mono',monospace;font-size:13px;color:#e2e8f0;min-height:20px;margin:4px 0;"></div>
          <div class="pda-race-verdict" id="pda_race_pda_verdict"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="slide-number">3 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 4: The PDA Machine Model -->
<!-- ============================================================ -->
<div class="slide" id="s4">
  <h2>The PDA Machine Model</h2>
  <p>A PDA has three components: an <strong>input tape</strong> (read left-to-right), a <strong>finite control</strong> (current state), and a <strong>stack</strong> (unbounded LIFO memory).</p>

  <div class="pda-mach-wrap">
    <svg id="pda_mach_svg" viewBox="0 0 700 350" style="width:100%;background:#0f172a;border:1px solid #334155;border-radius:12px;">
      <defs>
        <marker id="pda_mach_ah" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#475569"/></marker>
      </defs>
      <!-- Input tape label -->
      <text x="350" y="18" fill="#94a3b8" font-family="'SF Mono', monospace" font-size="11" text-anchor="middle">INPUT TAPE</text>
      <!-- Input tape cells -->
      <g id="pda_mach_tape"></g>
      <!-- Read head (triangle) -->
      <polygon id="pda_mach_head" points="0,-8 8,8 -8,8" fill="#ef4444" stroke="#ef4444" stroke-width="1" transform="translate(170,78)"/>
      <!-- Line: tape to control -->
      <line x1="350" y1="88" x2="350" y2="128" stroke="#475569" stroke-width="1.5" stroke-dasharray="4,3"/>
      <text x="378" y="112" fill="#64748b" font-family="'SF Mono', monospace" font-size="10">read</text>
      <!-- Finite control box -->
      <rect id="pda_mach_ctrl" x="270" y="128" width="160" height="72" rx="12" fill="#1e293b" stroke="#475569" stroke-width="2"/>
      <text x="350" y="150" fill="#94a3b8" font-family="'SF Mono', monospace" font-size="11" text-anchor="middle">FINITE CONTROL</text>
      <text id="pda_mach_state_label" x="350" y="180" fill="#93c5fd" font-family="'SF Mono', monospace" font-size="22" text-anchor="middle" font-weight="bold">q0</text>
      <!-- Line: control to stack -->
      <line x1="500" y1="168" x2="540" y2="168" stroke="#475569" stroke-width="1.5" stroke-dasharray="4,3"/>
      <text x="520" y="158" fill="#64748b" font-family="'SF Mono', monospace" font-size="10" text-anchor="middle">push/pop</text>
      <!-- Stack label -->
      <text x="590" y="145" fill="#94a3b8" font-family="'SF Mono', monospace" font-size="11" text-anchor="middle">STACK</text>
      <!-- Stack cells -->
      <g id="pda_mach_stack"></g>
      <!-- Status text -->
      <text id="pda_mach_status_text" x="350" y="340" fill="#94a3b8" font-family="'SF Mono', monospace" font-size="13" text-anchor="middle">Press Step or Run to begin</text>
    </svg>
    <div class="pda-mach-controls">
      <button onclick="pda_machStep()">Step</button>
      <button onclick="pda_machRun()" id="pda_mach_runBtn">Run</button>
      <button onclick="pda_machReset()">Reset</button>
      <span class="pda-mach-status" id="pda_mach_step_counter">Step 0 / 7</span>
    </div>
  </div>

  <div style="background:#1e293b;border:1px solid #334155;border-radius:10px;padding:14px;margin-top:8px;font-size:0.95em;color:#cbd5e1;line-height:1.6;">
    At each step the PDA: <strong>1.</strong> Reads the current input symbol (or &epsilon; -- no read) &nbsp; <strong>2.</strong> Peeks at the top of the stack &nbsp; <strong>3.</strong> Based on (state, input_symbol, stack_top), transitions to a new state and replaces the stack top with a string (push, pop, or no-change)
  </div>

  <div class="slide-number">4 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 5: Formal Definition -->
<!-- ============================================================ -->
<div class="slide" id="s5">
  <h2>Formal Definition of a PDA</h2>

  <div class="two-col">
    <div>
      <p>A PDA is a <strong>7-tuple</strong>:</p>
      <div class="diagram" style="font-size:1.05em;">
  M = (Q, &Sigma;, &Gamma;, &delta;, q0, Z0, F)
      </div>
      <table class="mt">
        <tr><th>Symbol</th><th>Meaning</th></tr>
        <tr><td><strong>Q</strong></td><td>Finite set of states</td></tr>
        <tr><td><strong>&Sigma;</strong></td><td>Input alphabet</td></tr>
        <tr><td><strong>&Gamma;</strong></td><td>Stack alphabet</td></tr>
        <tr><td><strong>&delta;</strong></td><td>Transition function</td></tr>
        <tr><td><strong>q<sub>0</sub></strong></td><td>Start state (q<sub>0</sub> &in; Q)</td></tr>
        <tr><td><strong>Z<sub>0</sub></strong></td><td>Initial stack symbol (Z<sub>0</sub> &in; &Gamma;)</td></tr>
        <tr><td><strong>F</strong></td><td>Set of accept (final) states</td></tr>
      </table>
    </div>
    <div>
      <h3>The Transition Function</h3>
      <div class="diagram" style="font-size:0.95em;">
  &delta; : Q x (&Sigma; &cup; {&epsilon;}) x &Gamma;  -->  P(Q x &Gamma;*)

  domain:                    range:
  (state, input_or_eps,    finite subsets of
   stack_top)               (new_state, string_to_push)
      </div>

      <div class="key-idea mt">
        <h3>Key Idea</h3>
        <p>The range is a <strong>set</strong> of (state, string) pairs -- this makes PDAs <strong>nondeterministic</strong>. The PDA can "choose" among multiple possible moves. It accepts if <em>any</em> choice sequence leads to acceptance.</p>
      </div>

      <div class="warning mt">
        <h3>Watch Out</h3>
        <p>&Sigma; is the input alphabet (e.g., {a, b}). &Gamma; is the stack alphabet (e.g., {a, b, $}). They can overlap, but &Gamma; often has extra symbols like the bottom marker $.</p>
      </div>
    </div>
  </div>

  <div class="slide-number">5 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 6: Reading PDA Transitions -->
<!-- ============================================================ -->
<div class="slide" id="s6">
  <h2>Reading PDA Transitions</h2>

  <div class="two-col">
    <div>
      <p>Each transition is written as:</p>
      <div class="diagram" style="font-size:1.1em;">
  &delta;(q, a, X) contains (p, Y)
      </div>
      <p>Read this as:</p>
      <ul>
        <li>"In state <strong>q</strong>,"</li>
        <li>"reading input symbol <strong>a</strong> (or &epsilon; for no read),"</li>
        <li>"with <strong>X</strong> on top of stack,"</li>
        <li>"move to state <strong>p</strong>,"</li>
        <li>"and replace X with string <strong>Y</strong> on the stack."</li>
      </ul>
      <div class="key-idea mt">
        <h3>Key Idea</h3>
        <p>The string <strong>Y</strong> is pushed so that its <em>leftmost</em> symbol ends up on top of the stack. If Y = ABC, then A is on top, B below it, C at the bottom of the pushed portion.</p>
      </div>
    </div>
    <div>
      <h3>Transition Explorer</h3>
      <div class="pda-trx-buttons">
        <button class="pda-trx-btn" onclick="pda_trxSelect(0)"><strong>Push</strong><br>&delta;(q0, a, $) = (q0, a$)</button>
        <button class="pda-trx-btn" onclick="pda_trxSelect(1)"><strong>Pop</strong><br>&delta;(q1, b, a) = (q1, &epsilon;)</button>
        <button class="pda-trx-btn" onclick="pda_trxSelect(2)"><strong>No-change</strong><br>&delta;(q, a, X) = (p, X)</button>
        <button class="pda-trx-btn" onclick="pda_trxSelect(3)"><strong>Multi-push</strong><br>&delta;(q, a, X) = (p, ABC)</button>
      </div>
      <div class="pda-trx-anim-panel">
        <svg id="pda_trx_svg" viewBox="0 0 400 80" style="width:100%;background:#0f172a;border-radius:8px;">
          <defs><marker id="pda_trx_ah" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#8b5cf6"/></marker></defs>
          <!-- State q -->
          <circle cx="80" cy="40" r="26" fill="#1e293b" stroke="#475569" stroke-width="2"/>
          <text x="80" y="40" fill="#e2e8f0" font-family="'SF Mono', monospace" font-size="14" text-anchor="middle" dominant-baseline="central" id="pda_trx_q_label">q</text>
          <!-- Arrow -->
          <line id="pda_trx_arrow" x1="108" y1="40" x2="290" y2="40" stroke="#8b5cf6" stroke-width="2" marker-end="url(#pda_trx_ah)"/>
          <!-- Arrow label -->
          <text id="pda_trx_arrow_label" x="200" y="28" fill="#a78bfa" font-family="'SF Mono', monospace" font-size="12" text-anchor="middle">click a transition above</text>
          <!-- State p -->
          <circle cx="320" cy="40" r="26" fill="#1e293b" stroke="#475569" stroke-width="2"/>
          <text x="320" y="40" fill="#e2e8f0" font-family="'SF Mono', monospace" font-size="14" text-anchor="middle" dominant-baseline="central" id="pda_trx_p_label">p</text>
        </svg>
        <div class="pda-trx-stacks">
          <div class="pda-trx-stack-col">
            <h5>Before</h5>
            <div class="pda-trx-stack-wrap" id="pda_trx_before"></div>
          </div>
          <div style="font-size:24px;color:#475569;align-self:center;margin-top:18px;">&rarr;</div>
          <div class="pda-trx-stack-col">
            <h5>After</h5>
            <div class="pda-trx-stack-wrap" id="pda_trx_after"></div>
          </div>
        </div>
        <div class="pda-trx-explain" id="pda_trx_explain">Select a transition type above to see how the stack changes.</div>
      </div>
    </div>
  </div>

  <div class="slide-number">6 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 7: Push, Pop, No-change -->
<!-- ============================================================ -->
<div class="slide" id="s7">
  <h2>Push, Pop, and No-Change Operations</h2>
  <p>Every transition pops the stack top and pushes a replacement string. We encode push, pop, and no-change using this single mechanism.</p>

  <div class="two-col mt">
    <div>
      <h3>PUSH (add B on top of X)</h3>
      <div class="diagram small">
  &delta;(q, a, X) = {(p, BX)}

  Before:       After:
  +---+         +---+
  | X | top     | B | top  (B pushed on top!)
  +---+         +---+
  | . |         | X |
  +---+         +---+
                | . |
  "Replace X    +---+
   with BX"
      </div>

      <h3 class="mt">POP (remove X)</h3>
      <div class="diagram small">
  &delta;(q, a, X) = {(p, &epsilon;)}

  Before:       After:
  +---+         +---+
  | X | top     | . | top  (X is gone!)
  +---+         +---+
  | . |
  +---+
  "Replace X
   with &epsilon; (nothing)"
      </div>
    </div>
    <div>
      <h3>NO-CHANGE (leave X on top)</h3>
      <div class="diagram small">
  &delta;(q, a, X) = {(p, X)}

  Before:       After:
  +---+         +---+
  | X | top     | X | top  (same!)
  +---+         +---+
  | . |         | . |
  +---+         +---+
  "Replace X
   with X (itself)"
      </div>

      <h3 class="mt">PUSH MULTIPLE (replace X with ABC)</h3>
      <div class="diagram small">
  &delta;(q, a, X) = {(p, ABC)}

  Before:       After:
  +---+         +---+
  | X | top     | A | top  (leftmost = top)
  +---+         +---+
  | . |         | B |
  +---+         +---+
                | C |
                +---+
                | . |
                +---+
      </div>
    </div>
  </div>

  <div class="slide-number">7 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 8: Example 1 - a^n b^n -->
<!-- ============================================================ -->
<div class="slide" id="s8">
  <h2>Example 1: PDA for { a<sup>n</sup>b<sup>n</sup> | n &ge; 0 }</h2>

  <div class="two-col">
    <div>
      <h3>Strategy</h3>
      <ol>
        <li>Start with bottom marker $ on the stack</li>
        <li>For each <code>a</code> read: <strong>push</strong> an <code>a</code> onto the stack</li>
        <li>Switch to "b-reading" mode</li>
        <li>For each <code>b</code> read: <strong>pop</strong> one <code>a</code> from the stack</li>
        <li>Accept if stack has only $ (all a's matched)</li>
      </ol>

      <div class="key-idea mt">
        <h3>Key Idea</h3>
        <p>The stack <strong>counts</strong> the a's. Each b cancels one a by popping. If counts match, the stack returns to just $, and we accept.</p>
      </div>

      <div class="warning mt">
        <h3>Watch Out</h3>
        <p>The empty string &epsilon; is in this language (n=0). We must accept it! That's why q<sub>0</sub> transitions directly to accept on seeing $.</p>
      </div>
    </div>
    <div>
      <h3>State Diagram</h3>
      <div class="diagram" style="font-size:0.82em;">
             a, $ / a$         b, a / &epsilon;
             a, a / aa
          +----------+      +----------+
          |          |      |          |
          v          |      v          |
  ---> ( q0 ) ---->  ( q1 ) ----> ( q2 )
         |     &epsilon;,$/$ |    b,a/&epsilon;     |
         |           |              |
         |     &epsilon;, $ / $          &epsilon;, $ / $
         |           |              |
         +-----+----+---------+----+
               |               |
               v               v
            (( q_accept ))

  States:
    q0 : start (reading a's, pushing)
    q1 : reading b's (popping a's)
    q_accept : accept state
      </div>
      <h3 class="mt">Formal Transitions</h3>
      <div class="diagram small">
  &delta;(q0, a, $) = {(q0, a$)}   -- first a
  &delta;(q0, a, a) = {(q0, aa)}   -- more a's
  &delta;(q0, &epsilon;, $) = {(q_acc, $)} -- accept &epsilon;
  &delta;(q0, b, a) = {(q1, &epsilon;)}   -- first b
  &delta;(q1, b, a) = {(q1, &epsilon;)}   -- more b's
  &delta;(q1, &epsilon;, $) = {(q_acc, $)} -- done!
      </div>
    </div>
  </div>

  <div class="slide-number">8 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 9: Interactive PDA Simulator for a^n b^n -->
<!-- ============================================================ -->
<div class="slide" id="s9">
  <h2>Interactive Simulator: PDA for { a<sup>n</sup>b<sup>n</sup> | n &ge; 0 }</h2>
  <p>Try it yourself! Enter a string of a's and b's and step through the PDA execution.</p>

  <div class="sim-inner-two-col mt">
    <div>
      <svg id="pda_anbn_svg" viewBox="0 0 400 200" style="width:100%;background:#0f172a;border-radius:8px;">
        <defs>
          <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#475569"/></marker>
          <marker id="arrowheadBlue" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#3b82f6"/></marker>
        </defs>
        <!-- Start arrow -->
        <line x1="30" y1="60" x2="68" y2="60" class="sim-svg-arrow"/>
        <!-- q0 -->
        <circle id="pda_anbn_q0" cx="100" cy="60" r="28" class="sim-svg-state active-state"/>
        <text x="100" y="60" class="sim-svg-text">q0</text>
        <!-- q1 -->
        <circle id="pda_anbn_q1" cx="300" cy="60" r="28" class="sim-svg-state"/>
        <text x="300" y="60" class="sim-svg-text">q1</text>
        <!-- q_acc (double circle) -->
        <circle id="pda_anbn_qacc" cx="200" cy="170" r="28" class="sim-svg-state"/>
        <circle cx="200" cy="170" r="23" class="sim-svg-state" style="fill:none;"/>
        <text x="200" y="170" class="sim-svg-text" style="font-size:11px;">q_acc</text>
        <!-- Self-loop on q0 -->
        <path d="M 85 34 C 60 -5, 140 -5, 115 34" class="sim-svg-arrow"/>
        <text x="100" y="10" class="sim-svg-label">a,$/a$ | a,a/aa</text>
        <!-- q0 -> q1 -->
        <line x1="130" y1="60" x2="270" y2="60" class="sim-svg-arrow"/>
        <text x="200" y="50" class="sim-svg-label">b, a/&epsilon;</text>
        <!-- Self-loop on q1 -->
        <path d="M 285 34 C 260 -5, 340 -5, 315 34" class="sim-svg-arrow"/>
        <text x="300" y="10" class="sim-svg-label">b, a/&epsilon;</text>
        <!-- q0 -> q_acc -->
        <line x1="82" y1="84" x2="180" y2="148" class="sim-svg-arrow"/>
        <text x="110" y="130" class="sim-svg-label">&epsilon;,$/$ </text>
        <!-- q1 -> q_acc -->
        <line x1="318" y1="84" x2="220" y2="148" class="sim-svg-arrow"/>
        <text x="290" y="130" class="sim-svg-label">&epsilon;,$/$ </text>
      </svg>

      <div style="margin-top:10px;">
        <strong style="color:#94a3b8;font-size:13px;">Stack:</strong>
        <div id="pda_anbn_stack" class="sim-stack-wrap" style="margin-top:4px;">
          <div class="sim-stack-cell">$</div>
        </div>
      </div>
    </div>

    <div>
      <div class="sim-container" style="padding:12px;">
        <div class="sim-controls">
          <input type="text" id="pda_anbn_input" placeholder="e.g. aabb" maxlength="20"/>
          <button onclick="pda_anbn_step()">Step</button>
          <button onclick="pda_anbn_run()" id="pda_anbn_runBtn">Run</button>
          <button onclick="pda_anbn_reset()">Reset</button>
        </div>
        <div><strong style="color:#94a3b8;font-size:13px;">Tape:</strong></div>
        <div id="pda_anbn_tape" class="sim-tape"></div>
        <div id="pda_anbn_verdict"></div>
        <div><strong style="color:#94a3b8;font-size:13px;">Step Log:</strong></div>
        <div id="pda_anbn_log" class="sim-log"></div>
      </div>
    </div>
  </div>

  <div class="slide-number">9 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 10: Acceptance Modes -->
<!-- ============================================================ -->
<div class="slide" id="s10">
  <h2>Acceptance: Final State vs. Empty Stack</h2>
  <p>There are <strong>two equivalent</strong> ways a PDA can accept a string.</p>

  <div class="two-col mt">
    <div>
      <h3>1. Acceptance by Final State</h3>
      <div class="diagram small">
  Accept if:
  - ALL input has been consumed
  - PDA is in a state q &in; F

  (Stack contents don't matter!)

       +-----+
       |     |  <-- could have stuff
       +-----+      on the stack,
       |     |      we don't care
       +-----+

  State: q &in; F   --> ACCEPT
      </div>
      <p>This is the more common definition in textbooks. The accept states F determine acceptance.</p>
    </div>
    <div>
      <h3>2. Acceptance by Empty Stack</h3>
      <div class="diagram small">
  Accept if:
  - ALL input has been consumed
  - Stack is completely EMPTY

  (Current state doesn't matter!)

       (empty)     <-- stack is empty
                       that's all we check

  State: any      --> ACCEPT
      </div>
      <p>Here, F is ignored (or F = Q). The PDA accepts purely by emptying its stack after reading all input.</p>
    </div>
  </div>

  <div class="key-idea mt">
    <h3>Key Idea</h3>
    <p>These two acceptance modes are <strong>equivalent in power</strong>. Any language accepted by a PDA using final states can also be accepted by some (different) PDA using empty stack, and vice versa. We can mechanically convert between the two.</p>
  </div>

  <div class="slide-number">10 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 11: Converting Between Acceptance Modes -->
<!-- ============================================================ -->
<div class="slide" id="s11">
  <h2>Converting Between Acceptance Modes</h2>

  <div class="two-col">
    <div>
      <h3>Final State --> Empty Stack</h3>
      <div class="diagram small">
  Idea: When original PDA reaches a
  final state, drain the entire stack.

         &epsilon;, Z0' / Z0'
  (q0')  -----------> (q0)
  new                  original
  start                start

  For each q &in; F:
               &epsilon;, any / &epsilon;
  (q) ---------> (q_drain)
                    |
                    | &epsilon;, any / &epsilon;  (loop: pop everything)
                    v
                 (q_drain)

  Steps:
  1. Add new start state q0', push
     new bottom marker Z0' under Z0
  2. From every final state, add
     &epsilon;-transition to q_drain
  3. q_drain pops everything
      </div>
    </div>
    <div>
      <h3>Empty Stack --> Final State</h3>
      <div class="diagram small">
  Idea: When stack empties, transition
  to a new accept state.

         &epsilon;, Z0' / Z0 Z0'
  (q0')  ----------------> (q0)
  new                       original
  start                     start

  For each state q:
               &epsilon;, Z0' / &epsilon;
  (q) ---------> (( q_f ))
                  new final state

  Steps:
  1. Add new start state q0', push
     new bottom marker Z0' under Z0
  2. From EVERY state, add
     &epsilon;-transition to q_f when
     Z0' is on top (= original stack
     is empty)
  3. q_f is the only accept state
      </div>
    </div>
  </div>

  <div class="warning mt">
    <h3>Watch Out</h3>
    <p>The new bottom marker Z<sub>0</sub>' is essential! Without it, the original PDA might empty its stack prematurely (not at a final state), and the conversion would accept strings it shouldn't.</p>
  </div>

  <div class="slide-number">11 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 12: Balanced Parentheses -->
<!-- ============================================================ -->
<div class="slide" id="s12">
  <h2>Example 2: PDA for Balanced Parentheses</h2>
  <p>Language: { w &in; {(, )}* | w has properly nested, balanced parentheses }</p>

  <div class="two-col mt">
    <div>
      <h3>Strategy</h3>
      <ul>
        <li>Push a marker for each <code>(</code></li>
        <li>Pop a marker for each <code>)</code></li>
        <li>Accept if stack returns to just $</li>
        <li>If we see <code>)</code> but stack has only $ -- reject (unmatched close)</li>
      </ul>

      <h3 class="mt">State Diagram</h3>
      <div class="diagram small">
         (, $ / L$        ), L / &epsilon;
         (, L / LL
        +--------+      +--------+
        |        |      |        |
        v        |      v        |
  ---> ( q0 ) ---------> ( q0 )
         |                  |
         |     &epsilon;, $ / $      |
         +--------+---------+
                  |
                  v
            (( q_acc ))
      </div>
      <p><em>Note: We can use a single state q<sub>0</sub>! The transitions for ( and ) just loop on q<sub>0</sub>.</em></p>
    </div>
    <div>
      <h3>Formal Transitions</h3>
      <div class="diagram small">
  &delta;(q0,  (,  $) = {(q0,  L$)}  push L
  &delta;(q0,  (,  L) = {(q0,  LL)}  push L
  &delta;(q0,  ),  L) = {(q0,  &epsilon;)}   pop L
  &delta;(q0,  &epsilon;,  $) = {(q_acc, $)} accept

  L = marker for open paren
      </div>

      <h3 class="mt">Try It: Interactive Simulator</h3>
      <div class="sim-container" style="padding:12px;">
        <svg id="pda_par_svg" viewBox="0 0 340 140" style="width:100%;background:#0f172a;border-radius:8px;">
          <defs><marker id="ah2" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#475569"/></marker></defs>
          <line x1="20" y1="50" x2="58" y2="50" stroke="#475569" stroke-width="1.5" marker-end="url(#ah2)"/>
          <circle id="pda_par_q0" cx="90" cy="50" r="26" class="sim-svg-state active-state"/>
          <text x="90" y="50" class="sim-svg-text">q0</text>
          <path d="M 76 26 C 55 -10, 125 -10, 104 26" stroke="#475569" stroke-width="1.5" fill="none" marker-end="url(#ah2)"/>
          <text x="90" y="6" class="sim-svg-label">(,$/L$ | (,L/LL | ),L/&epsilon;</text>
          <line x1="118" y1="50" x2="218" y2="50" stroke="#475569" stroke-width="1.5" marker-end="url(#ah2)"/>
          <text x="168" y="40" class="sim-svg-label">&epsilon;,$/$ </text>
          <circle id="pda_par_qacc" cx="250" cy="50" r="26" class="sim-svg-state"/>
          <circle cx="250" cy="50" r="21" class="sim-svg-state" style="fill:none;"/>
          <text x="250" y="50" class="sim-svg-text" style="font-size:10px;">q_acc</text>
        </svg>
        <div class="sim-controls">
          <input type="text" id="pda_par_input" placeholder="e.g. (())" maxlength="20"/>
          <button onclick="pda_par_step()">Step</button>
          <button onclick="pda_par_run()" id="pda_par_runBtn">Run</button>
          <button onclick="pda_par_reset()">Reset</button>
        </div>
        <div id="pda_par_tape" class="sim-tape"></div>
        <div style="display:flex;gap:16px;margin-top:6px;">
          <div style="flex:1;">
            <strong style="color:#94a3b8;font-size:12px;">Stack:</strong>
            <div id="pda_par_stack" class="sim-stack-wrap" style="min-height:80px;margin-top:2px;">
              <div class="sim-stack-cell">$</div>
            </div>
          </div>
          <div style="flex:1;">
            <div id="pda_par_verdict"></div>
            <div id="pda_par_log" class="sim-log" style="max-height:80px;"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="slide-number">12 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 13: Palindromes ww^R -->
<!-- ============================================================ -->
<div class="slide" id="s13">
  <h2>Example 3: PDA for { ww<sup>R</sup> | w &in; {0,1}* }</h2>
  <p>Even-length palindromes! The string's second half is the reverse of the first.</p>

  <div class="two-col mt">
    <div>
      <h3>The Problem</h3>
      <p>Consider <code>01 10</code>: the first half is <code>01</code>, the second half <code>10</code> is <code>01</code> reversed.</p>
      <p class="mt">But how does the PDA know where the <strong>middle</strong> is?</p>

      <div class="key-idea mt">
        <h3>Key Idea: Nondeterminism!</h3>
        <p>The PDA <strong>guesses</strong> the midpoint! At every position, it nondeterministically branches into two choices:</p>
        <ol>
          <li>"I haven't reached the middle yet" -- keep pushing</li>
          <li>"This is the middle!" -- switch to popping mode</li>
        </ol>
        <p>It accepts if <em>any</em> guess leads to acceptance. The "correct" guess (at the true midpoint) will succeed.</p>
      </div>

      <div class="analogy mt">
        <h3>Analogy</h3>
        <p>Imagine cloning yourself at every step. One clone keeps pushing, the other switches to matching. Most clones die. The one who guessed right survives.</p>
      </div>
    </div>
    <div>
      <h3>Try It: Palindrome Simulator</h3>
      <div class="sim-container" style="padding:12px;">
        <svg id="pda_pal_svg" viewBox="0 0 400 220" style="width:100%;background:#0f172a;border-radius:8px;">
          <defs><marker id="ah3" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#475569"/></marker></defs>
          <line x1="10" y1="80" x2="48" y2="80" stroke="#475569" stroke-width="1.5" marker-end="url(#ah3)"/>
          <circle id="pda_pal_q0" cx="80" cy="80" r="26" class="sim-svg-state active-state"/>
          <text x="80" y="80" class="sim-svg-text">q0</text>
          <path d="M 66 56 C 45 15, 115 15, 94 56" stroke="#475569" stroke-width="1.5" fill="none" marker-end="url(#ah3)"/>
          <text x="80" y="28" class="sim-svg-label">0,1 push</text>
          <line x1="108" y1="80" x2="268" y2="80" stroke="#475569" stroke-width="1.5" marker-end="url(#ah3)"/>
          <text x="188" y="70" class="sim-svg-label" style="fill:#a78bfa;">&epsilon; (guess mid!)</text>
          <circle id="pda_pal_q1" cx="300" cy="80" r="26" class="sim-svg-state"/>
          <text x="300" y="80" class="sim-svg-text">q1</text>
          <path d="M 286 56 C 265 15, 335 15, 314 56" stroke="#475569" stroke-width="1.5" fill="none" marker-end="url(#ah3)"/>
          <text x="300" y="28" class="sim-svg-label">match & pop</text>
          <line x1="68" y1="104" x2="172" y2="162" stroke="#475569" stroke-width="1.5" marker-end="url(#ah3)"/>
          <text x="98" y="148" class="sim-svg-label">&epsilon;,$/$ </text>
          <line x1="312" y1="104" x2="218" y2="162" stroke="#475569" stroke-width="1.5" marker-end="url(#ah3)"/>
          <text x="288" y="148" class="sim-svg-label">&epsilon;,$/$ </text>
          <circle id="pda_pal_qacc" cx="190" cy="180" r="26" class="sim-svg-state"/>
          <circle cx="190" cy="180" r="21" class="sim-svg-state" style="fill:none;"/>
          <text x="190" y="180" class="sim-svg-text" style="font-size:10px;">q_acc</text>
        </svg>
        <div class="sim-controls">
          <input type="text" id="pda_pal_input" placeholder="e.g. 0110" maxlength="20"/>
          <button onclick="pda_pal_step()">Step</button>
          <button onclick="pda_pal_run()" id="pda_pal_runBtn">Run</button>
          <button onclick="pda_pal_reset()">Reset</button>
        </div>
        <div id="pda_pal_tape" class="sim-tape"></div>
        <div style="display:flex;gap:12px;margin-top:4px;">
          <div style="flex:0 0 70px;">
            <strong style="color:#94a3b8;font-size:12px;">Stack:</strong>
            <div id="pda_pal_stack" class="sim-stack-wrap" style="min-height:80px;margin-top:2px;"></div>
          </div>
          <div style="flex:1;">
            <div id="pda_pal_verdict"></div>
            <div id="pda_pal_log" class="sim-log" style="max-height:80px;"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="slide-number">13 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 14: PDA vs DPDA -->
<!-- ============================================================ -->
<div class="slide" id="s14">
  <h2>PDA vs. DPDA: Nondeterminism Matters!</h2>

  <div class="two-col">
    <div>
      <h3>Recall: DFA vs NFA</h3>
      <p>For finite automata, deterministic = nondeterministic in power.</p>
      <div class="diagram small">
  DFA = NFA
  (same languages: regular)
      </div>

      <h3 class="mt">For PDAs: NOT the same!</h3>
      <div class="diagram small">
  DPDA  &lt;  PDA  (strict subset!)

  +---------------------------+
  | Context-Free Languages    |
  | (PDA)                     |
  |                           |
  |  +---------------------+  |
  |  | Deterministic CFLs  |  |
  |  | (DPDA)              |  |
  |  |                     |  |
  |  |  +---------------+  |  |
  |  |  | Regular       |  |  |
  |  |  | (DFA)         |  |  |
  |  |  +---------------+  |  |
  |  +---------------------+  |
  +---------------------------+
      </div>
    </div>
    <div>
      <h3>What is a DPDA?</h3>
      <p>A <strong>deterministic PDA</strong> has at most <strong>one</strong> move at each step. Formally: for every (state, input, stack_top), there is at most one transition, and if there's an &epsilon;-transition, there are no other transitions for that (state, stack_top).</p>

      <div class="warning mt">
        <h3>Critical Difference</h3>
        <p>The language { ww<sup>R</sup> | w &in; {0,1}* } is context-free but <strong>NOT</strong> deterministic context-free. No DPDA can recognize it -- the "guess the middle" trick <em>requires</em> nondeterminism.</p>
      </div>

      <div class="key-idea mt">
        <h3>Key Idea</h3>
        <p>Languages recognized by DPDAs are called <strong>Deterministic CFLs</strong>. They are important in practice because most programming languages are designed to be deterministic CFLs (so parsers are efficient).</p>
      </div>

      <h3 class="mt">Examples</h3>
      <table>
        <tr><th>Language</th><th>DPDA?</th><th>PDA?</th></tr>
        <tr><td>a<sup>n</sup>b<sup>n</sup></td><td>Yes</td><td>Yes</td></tr>
        <tr><td>ww<sup>R</sup></td><td>No</td><td>Yes</td></tr>
        <tr><td>wcw<sup>R</sup> (with center marker)</td><td>Yes</td><td>Yes</td></tr>
      </table>
    </div>
  </div>

  <div class="slide-number">14 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 15: CFG to PDA Conversion -->
<!-- ============================================================ -->
<div class="slide" id="s15">
  <h2>CFG to PDA Conversion</h2>
  <p>Given any CFG G, we can build a PDA M such that L(M) = L(G). This uses a <strong>top-down parsing</strong> strategy.</p>

  <div class="two-col mt">
    <div>
      <h3>The Construction (3 states!)</h3>
      <div class="diagram" style="font-size:0.82em;">
           &epsilon;, $ / S$
  (q_start) ----------> (q_loop) -------> ((q_acc))
                           |  ^       &epsilon;, $ / $
                           |  |
                           +--+
              For each rule A -> w:
                &epsilon;, A / w
              For each terminal a:
                a, a / &epsilon;
      </div>
      <p class="mt">The PDA has essentially <strong>one working state</strong> (q<sub>loop</sub>) that does all the work.</p>
    </div>
    <div>
      <h3>How It Works</h3>
      <ol>
        <li><strong>Start:</strong> Push start variable S onto stack</li>
        <li><strong>Loop:</strong> Repeat until stack is empty:
          <ul>
            <li>If top of stack is a <strong>variable</strong> A: nondeterministically pick a rule A &rarr; w and replace A with w</li>
            <li>If top of stack is a <strong>terminal</strong> a: match it against the next input symbol (pop a, consume input a)</li>
          </ul>
        </li>
        <li><strong>Accept:</strong> Stack is empty (just $) and all input consumed</li>
      </ol>

      <div class="key-idea mt">
        <h3>Key Idea</h3>
        <p>The stack holds the "prediction" of what the rest of the input should look like. Variables get expanded (replaced by rule right-hand sides). Terminals get matched and consumed. This is a <strong>leftmost derivation simulation</strong>.</p>
      </div>
    </div>
  </div>

  <div class="slide-number">15 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 16: CFG to PDA Example -->
<!-- ============================================================ -->
<div class="slide" id="s16">
  <h2>CFG to PDA: Worked Example</h2>

  <div class="two-col">
    <div>
      <h3>Grammar G</h3>
      <div class="diagram">
  S &rarr; aSb | &epsilon;
      </div>
      <p>This generates { a<sup>n</sup>b<sup>n</sup> | n &ge; 0 }.</p>

      <h3 class="mt">Resulting PDA Transitions</h3>
      <div class="diagram small">
  From the construction:

  Start:
    &delta;(q_start, &epsilon;, $) = {(q_loop, S$)}

  Variable rules (replace on stack):
    &delta;(q_loop, &epsilon;, S) = {(q_loop, aSb),
                          (q_loop, &epsilon;)}

  Terminal matching:
    &delta;(q_loop, a, a) = {(q_loop, &epsilon;)}
    &delta;(q_loop, b, b) = {(q_loop, &epsilon;)}

  Accept:
    &delta;(q_loop, &epsilon;, $) = {(q_acc, $)}
      </div>
    </div>
    <div>
      <h3>Step-Through: Parsing "aabb"</h3>
      <div class="cfg-step-container" id="pda_cfg_container">
        <div class="sim-controls">
          <button onclick="pda_cfg_next()">Next</button>
          <button onclick="pda_cfg_auto()" id="pda_cfg_autoBtn">Auto</button>
          <button onclick="pda_cfg_reset()">Reset</button>
          <span id="pda_cfg_counter" style="color:#94a3b8;font-size:13px;">Step 0 / 9</span>
        </div>
        <div style="display:flex;gap:16px;">
          <div style="flex:0 0 80px;">
            <strong style="color:#94a3b8;font-size:12px;">Stack:</strong>
            <div id="pda_cfg_stack" class="sim-stack-wrap" style="min-height:160px;margin-top:4px;">
              <div class="sim-stack-cell">$</div>
            </div>
          </div>
          <div style="flex:1;">
            <div><strong style="color:#94a3b8;font-size:12px;">Input remaining:</strong> <span id="pda_cfg_input" style="font-family:'SF Mono',monospace;color:#e2e8f0;">aabb</span></div>
            <div id="pda_cfg_action" class="cfg-step-action start" style="margin-top:8px;">Start: stack=[$], input="aabb"</div>
            <div id="pda_cfg_log" class="sim-log" style="max-height:140px;margin-top:8px;"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="slide-number">16 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 17: PDA to CFG Conversion -->
<!-- ============================================================ -->
<div class="slide" id="s17">
  <h2>PDA to CFG Conversion</h2>
  <p>The harder direction: given a PDA, build an equivalent CFG. This proves every PDA language is context-free.</p>

  <div class="two-col mt">
    <div>
      <h3>The Main Idea</h3>
      <p>Create a variable <strong>A<sub>pq</sub></strong> for every pair of states (p, q). This variable generates exactly the strings that take the PDA:</p>
      <ul>
        <li>From state p to state q</li>
        <li>Starting and ending with the <strong>same stack</strong> (net effect: nothing added or removed)</li>
      </ul>

      <div class="diagram small">
  A_pq generates all strings w such that:

  (p, w, empty) |-*-> (q, &epsilon;, empty)

   state p                    state q
     |                          ^
     |   reading w              |
     |   stack: push/pop/...    |
     |   but NET stack change   |
     +-------- = 0 ------------+
      </div>
    </div>
    <div>
      <h3>Construction Rules</h3>
      <div class="diagram small">
  Rule 1: A_pp &rarr; &epsilon;   (for all states p)
    "Zero-length path, no net stack change"

  Rule 2: A_pq &rarr; A_pr A_rq
    (for all states p, r, q)
    "Concatenate two net-zero paths"

  Rule 3: If &delta;(p,a,X) contains (r,Y)
    and &delta;(s,b,Y) contains (q,&epsilon;):
    A_pq &rarr; a A_rs b
    "Push X, do stuff, pop X"
      </div>

      <div class="warning mt">
        <h3>Watch Out</h3>
        <p>This construction can produce a <em>huge</em> number of rules (|Q|<sup>3</sup> rules just from Rule 2). Many rules may be useless (generating no terminal strings), but the grammar is correct.</p>
      </div>

      <div class="key-idea mt">
        <h3>Key Idea</h3>
        <p>The start variable is <strong>A<sub>q0,qf</sub></strong> for accept states q<sub>f</sub>. The grammar works because every computation that starts with an empty stack and ends with an empty stack can be decomposed into paired push/pop segments.</p>
      </div>
    </div>
  </div>

  <div class="slide-number">17 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 18: PDA = CFG Equivalence -->
<!-- ============================================================ -->
<div class="slide" id="s18">
  <h2>The Big Equivalence: PDA = CFG</h2>

  <div class="two-col">
    <div>
      <div class="diagram" style="font-size:0.95em;">
  +------------------------------+
  |                              |
  |   Context-Free Languages     |
  |                              |
  |   +--------+    +--------+  |
  |   |  CFG   |<==>|  PDA   |  |
  |   +--------+    +--------+  |
  |                              |
  |   Both describe EXACTLY the  |
  |   same class of languages.   |
  +------------------------------+

  CFG ---> PDA : Top-down parsing
                 (Slide 15-16)

  PDA ---> CFG : A_pq construction
                 (Slide 17)
      </div>

      <div class="key-idea mt">
        <h3>Key Idea</h3>
        <p>This is one of the fundamental theorems of formal language theory. It says that the <strong>generative</strong> model (grammars deriving strings) and the <strong>recognition</strong> model (automata accepting strings) agree perfectly for context-free languages.</p>
      </div>
    </div>
    <div>
      <h3>The Complete Picture</h3>
      <div class="diagram" style="font-size:0.85em;">
    Language Class     Generator    Recognizer
  +-----------------+-----------+------------+
  | Regular         | Regular   | DFA / NFA  |
  |                 | Expr / RG |            |
  +-----------------+-----------+------------+
  | Det. CF         | LR(1)     | DPDA       |
  |                 | Grammar   |            |
  +-----------------+-----------+------------+
  | Context-Free    | CFG       | PDA        |
  +-----------------+-----------+------------+
  | Context-        | CSG       | Linear     |
  |  Sensitive      |           | Bounded    |
  +-----------------+-----------+------------+
  | Recursively     | Unrestr.  | Turing     |
  |  Enumerable     | Grammar   | Machine    |
  +-----------------+-----------+------------+
      </div>

      <div class="analogy mt">
        <h3>Analogy</h3>
        <p>Think of CFGs as <strong>blueprints</strong> (how to build strings) and PDAs as <strong>inspectors</strong> (how to verify strings). The theorem says: anything one can build, the other can check -- and vice versa. They're two views of the same reality.</p>
      </div>
    </div>
  </div>

  <div class="slide-number">18 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 19: Limitations of PDAs -->
<!-- ============================================================ -->
<div class="slide" id="s19">
  <h2>Limitations: What PDAs Cannot Do</h2>

  <div class="two-col">
    <div>
      <h3>Languages Beyond PDAs</h3>
      <table>
        <tr><th>Language</th><th>PDA?</th><th>Why Not</th></tr>
        <tr><td>{ a<sup>n</sup>b<sup>n</sup>c<sup>n</sup> }</td><td>No</td><td>Can't count 3 things</td></tr>
        <tr><td>{ ww } (copy)</td><td>No</td><td>Can't match forward</td></tr>
        <tr><td>{ a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>d<sup>n</sup> }</td><td>No</td><td>Same reason</td></tr>
        <tr><td>{ a<sup>i</sup>b<sup>j</sup>c<sup>k</sup> | i<j<k }</td><td>No</td><td>Two independent counts</td></tr>
      </table>

      <h3 class="mt">Why a<sup>n</sup>b<sup>n</sup>c<sup>n</sup> Fails</h3>
      <div class="diagram small">
  Push a's:     +---+
                | a |
                +---+  Count of a's on stack
                | a |
                +---+
                | $ |
                +---+

  Pop for b's:  Stack tracks a=b. Good.

  But now the stack is EMPTY.
  How do we check c count = n too?

  The stack was "used up" matching
  a's and b's. No memory left for c's!
      </div>
    </div>
    <div>
      <h3>Why ww (Copy Language) Fails</h3>
      <div class="diagram small">
  Input:  0 1 1 | 0 1 1
          first   second (copy of first)
                   half    half

  After pushing first half:
      +---+
      | 1 |  top
      +---+
      | 1 |
      +---+
      | 0 |
      +---+
      | $ |
      +---+

  But popping gives REVERSE: 1,1,0
  We need FORWARD match:    0,1,1

  Stack is LIFO -- it reverses!
  That's why ww^R works but ww doesn't.
      </div>

      <div class="key-idea mt">
        <h3>Key Idea</h3>
        <p>A stack is <strong>LIFO</strong> (last-in, first-out). It naturally handles <strong>reversal</strong> (palindromes, nesting) but cannot handle <strong>copying</strong> or <strong>three-way matching</strong>. These require a Turing machine's tape.</p>
      </div>

      <div class="warning mt">
        <h3>Proving Non-CFL</h3>
        <p>Use the <strong>Pumping Lemma for CFLs</strong> to formally prove a language is not context-free (and hence no PDA can recognize it).</p>
      </div>
    </div>
  </div>

  <div class="slide-number">19 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 20: Summary & Cheat Sheet -->
<!-- ============================================================ -->
<div class="slide" id="s20">
  <h2>Summary & Cheat Sheet</h2>

  <div class="two-col">
    <div>
      <h3>PDA at a Glance</h3>
      <div class="diagram small">
  PDA = NFA + Stack

  7-tuple: (Q, &Sigma;, &Gamma;, &delta;, q0, Z0, F)

  Transition: &delta;(q, a, X) = {(p, Y)}
    "state q, read a, pop X, push Y, goto p"

  Push:      replace X with BX
  Pop:       replace X with &epsilon;
  No-change: replace X with X
      </div>

      <h3 class="mt">Acceptance Modes</h3>
      <div class="diagram small">
  Final State: end in q &in; F, input consumed
  Empty Stack: stack empty, input consumed
  (Equivalent in power!)
      </div>

      <h3 class="mt">Key Equivalence</h3>
      <div class="diagram small">
        CFG  &lt;====&gt;  PDA
  Both describe Context-Free Languages.

  CFG &rarr; PDA: top-down parsing (3 states)
  PDA &rarr; CFG: A_pq variable construction
      </div>
    </div>
    <div>
      <h3>What PDAs Can and Can't Do</h3>
      <table style="font-size:0.9em;">
        <tr><th>Language</th><th>Regular?</th><th>CFL?</th></tr>
        <tr><td>a*b*</td><td>Yes</td><td>Yes</td></tr>
        <tr><td>a<sup>n</sup>b<sup>n</sup></td><td>No</td><td>Yes</td></tr>
        <tr><td>balanced parens</td><td>No</td><td>Yes</td></tr>
        <tr><td>ww<sup>R</sup></td><td>No</td><td>Yes (nondet)</td></tr>
        <tr><td>wcw<sup>R</sup></td><td>No</td><td>Yes (det)</td></tr>
        <tr><td>a<sup>n</sup>b<sup>n</sup>c<sup>n</sup></td><td>No</td><td>No</td></tr>
        <tr><td>ww (copy)</td><td>No</td><td>No</td></tr>
      </table>

      <h3 class="mt">PDA vs DPDA</h3>
      <div class="key-idea">
        <h3>Remember</h3>
        <p><strong>DPDA &lt; PDA</strong> (unlike DFA = NFA). Some CFLs fundamentally require nondeterminism. Example: ww<sup>R</sup> (even palindromes) needs nondeterministic "guess the middle."</p>
      </div>

      <div class="analogy mt">
        <h3>Mental Model</h3>
        <p><strong>DFA</strong> = person with a notecard (finite notes).<br>
        <strong>PDA</strong> = person with a stack of plates (LIFO memory).<br>
        <strong>TM</strong> = person with a scroll (random-access memory).</p>
      </div>
    </div>
  </div>

  <div class="slide-number">20 / 21</div>
</div>

<!-- ============================================================ -->
<!-- SLIDE 21: Challenge Quiz -->
<!-- ============================================================ -->
<div class="slide" id="s21">
  <h2>Challenge Quiz: Test Your PDA Knowledge</h2>
  <p class="subtitle">3 random questions from a pool of 6. Pick the correct answer!</p>

  <div class="quiz-container" id="pda_q1_container">
    <div id="pda_q1_area"></div>
    <div id="pda_q1_score" class="quiz-score" style="display:none;"></div>
  </div>

  <div class="slide-number">21 / 21</div>
</div>

<!-- ============================================================ -->
<!-- NAVIGATION -->
<!-- ============================================================ -->
<div class="nav">
  <button id="prevBtn" onclick="changeSlide(-1)">&larr; Prev</button>
  <button id="nextBtn" onclick="changeSlide(1)">Next &rarr;</button>
</div>

<script>
const totalSlides = 21;
let current = 1;
function showSlide(n) {
  document.querySelectorAll('.slide').forEach(s => s.classList.remove('active'));
  const slide = document.getElementById('s' + n);
  if (slide) { slide.classList.add('active'); slide.classList.add('fade-in'); }
  document.getElementById('prevBtn').disabled = (n === 1);
  document.getElementById('nextBtn').disabled = (n === totalSlides);
  document.getElementById('progress').style.width = ((n / totalSlides) * 100) + '%';
}
function changeSlide(delta) {
  const next = current + delta;
  if (next >= 1 && next <= totalSlides) { current = next; showSlide(current); }
}
document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowRight' || e.key === 'ArrowDown' || e.key === ' ') { e.preventDefault(); changeSlide(1); }
  else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') { e.preventDefault(); changeSlide(-1); }
  else if (e.key === 's' || e.key === 'S') {
    const slide = document.getElementById('s' + current);
    const steps = slide.querySelectorAll('.step:not(.revealed)');
    if (steps.length > 0) steps[0].classList.add('revealed');
  }
});
// ===================================================================
// ENHANCEMENT 1: PDA Simulator for a^n b^n (Slide 9)
// ===================================================================
var pda_anbn_steps = [];
var pda_anbn_cur = 0;
var pda_anbn_timers = [];
var pda_anbn_running = false;
var pda_anbn_initialized = false;

function pda_anbn_buildSteps(input) {
  var steps = [];
  var stack = ['$'];
  var state = 'q0';
  var pos = 0;
  steps.push({ state: 'q0', pos: 0, stack: ['$'], action: 'Start', consumed: false });

  while (true) {
    var ch = pos < input.length ? input[pos] : null;
    var top = stack.length > 0 ? stack[0] : null;

    if (state === 'q0' && ch === 'a' && top === '$') {
      stack = ['a'].concat(stack);
      pos++;
      steps.push({ state: 'q0', pos: pos, stack: stack.slice(), action: "Read 'a', push a (first a)" });
    } else if (state === 'q0' && ch === 'a' && top === 'a') {
      stack = ['a'].concat(stack);
      pos++;
      steps.push({ state: 'q0', pos: pos, stack: stack.slice(), action: "Read 'a', push a" });
    } else if (state === 'q0' && ch === 'b' && top === 'a') {
      stack.shift();
      pos++;
      state = 'q1';
      steps.push({ state: 'q1', pos: pos, stack: stack.slice(), action: "Read 'b', pop a, go to q1" });
    } else if (state === 'q0' && ch === null && top === '$') {
      state = 'q_acc';
      steps.push({ state: 'q_acc', pos: pos, stack: stack.slice(), action: "\u03b5-move, see $, ACCEPT!", accept: true });
      break;
    } else if (state === 'q1' && ch === 'b' && top === 'a') {
      stack.shift();
      pos++;
      steps.push({ state: 'q1', pos: pos, stack: stack.slice(), action: "Read 'b', pop a" });
    } else if (state === 'q1' && ch === null && top === '$') {
      state = 'q_acc';
      steps.push({ state: 'q_acc', pos: pos, stack: stack.slice(), action: "\u03b5-move, see $, ACCEPT!", accept: true });
      break;
    } else {
      steps.push({ state: state, pos: pos, stack: stack.slice(), action: "No valid transition. REJECT!", reject: true });
      break;
    }
  }
  return steps;
}

function pda_anbn_renderTape(input, pos) {
  var el = document.getElementById('pda_anbn_tape');
  var html = '';
  for (var i = 0; i < input.length; i++) {
    var cls = 'sim-tape-cell';
    if (i < pos) cls += ' consumed';
    else if (i === pos) cls += ' current';
    html += '<div class="' + cls + '">' + input[i] + '</div>';
  }
  if (pos >= input.length) {
    html += '<div class="sim-tape-cell current" style="color:#94a3b8;">\u03b5</div>';
  }
  el.innerHTML = html;
}

function pda_anbn_renderStack(stack) {
  var el = document.getElementById('pda_anbn_stack');
  var html = '';
  for (var i = 0; i < stack.length; i++) {
    html += '<div class="sim-stack-cell push-anim">' + stack[i] + '</div>';
  }
  el.innerHTML = html;
}

function pda_anbn_highlightState(s) {
  ['q0', 'q1', 'qacc'].forEach(function(id) {
    document.getElementById('pda_anbn_' + id).classList.remove('active-state');
  });
  var map = { 'q0': 'q0', 'q1': 'q1', 'q_acc': 'qacc' };
  if (map[s]) document.getElementById('pda_anbn_' + map[s]).classList.add('active-state');
}

function pda_anbn_addLog(msg) {
  var el = document.getElementById('pda_anbn_log');
  el.innerHTML += '<div class="log-entry">' + pda_anbn_cur + ': ' + msg + '</div>';
  el.scrollTop = el.scrollHeight;
}

function pda_anbn_init() {
  var raw = document.getElementById('pda_anbn_input').value.trim();
  if (!/^[ab]*$/.test(raw)) { alert('Only a and b characters allowed!'); return false; }
  pda_anbn_steps = pda_anbn_buildSteps(raw);
  pda_anbn_cur = 0;
  pda_anbn_initialized = true;
  document.getElementById('pda_anbn_log').innerHTML = '';
  document.getElementById('pda_anbn_verdict').innerHTML = '';
  var step = pda_anbn_steps[0];
  pda_anbn_renderTape(raw, step.pos);
  pda_anbn_renderStack(step.stack);
  pda_anbn_highlightState(step.state);
  pda_anbn_addLog(step.action);
  return true;
}

function pda_anbn_step() {
  if (!pda_anbn_initialized) { if (!pda_anbn_init()) return; }
  if (pda_anbn_cur >= pda_anbn_steps.length - 1) return;
  pda_anbn_cur++;
  var step = pda_anbn_steps[pda_anbn_cur];
  var raw = document.getElementById('pda_anbn_input').value.trim();
  pda_anbn_renderTape(raw, step.pos);
  pda_anbn_renderStack(step.stack);
  pda_anbn_highlightState(step.state);
  pda_anbn_addLog(step.action);
  if (step.accept) {
    document.getElementById('pda_anbn_verdict').innerHTML = '<div class="sim-verdict accept">ACCEPT</div>';
  } else if (step.reject) {
    document.getElementById('pda_anbn_verdict').innerHTML = '<div class="sim-verdict reject">REJECT</div>';
  }
}

function pda_anbn_run() {
  if (!pda_anbn_initialized) { if (!pda_anbn_init()) return; }
  if (pda_anbn_running) return;
  pda_anbn_running = true;
  function tick() {
    if (pda_anbn_cur >= pda_anbn_steps.length - 1) { pda_anbn_running = false; return; }
    pda_anbn_step();
    var t = setTimeout(tick, 700);
    pda_anbn_timers.push(t);
  }
  tick();
}

function pda_anbn_reset() {
  pda_anbn_timers.forEach(function(t) { clearTimeout(t); });
  pda_anbn_timers = [];
  pda_anbn_running = false;
  pda_anbn_initialized = false;
  pda_anbn_cur = 0;
  pda_anbn_steps = [];
  document.getElementById('pda_anbn_tape').innerHTML = '';
  document.getElementById('pda_anbn_stack').innerHTML = '<div class="sim-stack-cell">$</div>';
  document.getElementById('pda_anbn_log').innerHTML = '';
  document.getElementById('pda_anbn_verdict').innerHTML = '';
  pda_anbn_highlightState('q0');
}

// ===================================================================
// ENHANCEMENT 2: Balanced Parentheses Simulator (Slide 12)
// ===================================================================
var pda_par_steps = [];
var pda_par_cur = 0;
var pda_par_timers = [];
var pda_par_running = false;
var pda_par_initialized = false;

function pda_par_buildSteps(input) {
  var steps = [];
  var stack = ['$'];
  var state = 'q0';
  var pos = 0;
  steps.push({ state: 'q0', pos: 0, stack: ['$'], action: 'Start' });

  while (true) {
    var ch = pos < input.length ? input[pos] : null;
    var top = stack.length > 0 ? stack[0] : null;

    if (state === 'q0' && ch === '(' && top === '$') {
      stack = ['L'].concat(stack);
      pos++;
      steps.push({ state: 'q0', pos: pos, stack: stack.slice(), action: "Read '(', push L" });
    } else if (state === 'q0' && ch === '(' && top === 'L') {
      stack = ['L'].concat(stack);
      pos++;
      steps.push({ state: 'q0', pos: pos, stack: stack.slice(), action: "Read '(', push L" });
    } else if (state === 'q0' && ch === ')' && top === 'L') {
      stack.shift();
      pos++;
      steps.push({ state: 'q0', pos: pos, stack: stack.slice(), action: "Read ')', pop L" });
    } else if (state === 'q0' && ch === null && top === '$') {
      state = 'q_acc';
      steps.push({ state: 'q_acc', pos: pos, stack: stack.slice(), action: "\u03b5-move, see $, ACCEPT!", accept: true });
      break;
    } else {
      steps.push({ state: state, pos: pos, stack: stack.slice(), action: "No valid transition. REJECT!", reject: true });
      break;
    }
  }
  return steps;
}

function pda_par_renderTape(input, pos) {
  var el = document.getElementById('pda_par_tape');
  var html = '';
  for (var i = 0; i < input.length; i++) {
    var cls = 'sim-tape-cell';
    if (i < pos) cls += ' consumed';
    else if (i === pos) cls += ' current';
    html += '<div class="' + cls + '">' + input[i] + '</div>';
  }
  if (pos >= input.length) {
    html += '<div class="sim-tape-cell current" style="color:#94a3b8;">\u03b5</div>';
  }
  el.innerHTML = html;
}

function pda_par_renderStack(stack) {
  var el = document.getElementById('pda_par_stack');
  var html = '';
  for (var i = 0; i < stack.length; i++) {
    html += '<div class="sim-stack-cell push-anim">' + stack[i] + '</div>';
  }
  el.innerHTML = html;
}

function pda_par_highlightState(s) {
  document.getElementById('pda_par_q0').classList.remove('active-state');
  document.getElementById('pda_par_qacc').classList.remove('active-state');
  var map = { 'q0': 'pda_par_q0', 'q_acc': 'pda_par_qacc' };
  if (map[s]) document.getElementById(map[s]).classList.add('active-state');
}

function pda_par_addLog(msg) {
  var el = document.getElementById('pda_par_log');
  el.innerHTML += '<div class="log-entry">' + pda_par_cur + ': ' + msg + '</div>';
  el.scrollTop = el.scrollHeight;
}

function pda_par_init() {
  var raw = document.getElementById('pda_par_input').value.trim();
  if (!/^[()]*$/.test(raw)) { alert('Only ( and ) characters allowed!'); return false; }
  pda_par_steps = pda_par_buildSteps(raw);
  pda_par_cur = 0;
  pda_par_initialized = true;
  document.getElementById('pda_par_log').innerHTML = '';
  document.getElementById('pda_par_verdict').innerHTML = '';
  var step = pda_par_steps[0];
  pda_par_renderTape(raw, step.pos);
  pda_par_renderStack(step.stack);
  pda_par_highlightState(step.state);
  pda_par_addLog(step.action);
  return true;
}

function pda_par_step() {
  if (!pda_par_initialized) { if (!pda_par_init()) return; }
  if (pda_par_cur >= pda_par_steps.length - 1) return;
  pda_par_cur++;
  var step = pda_par_steps[pda_par_cur];
  var raw = document.getElementById('pda_par_input').value.trim();
  pda_par_renderTape(raw, step.pos);
  pda_par_renderStack(step.stack);
  pda_par_highlightState(step.state);
  pda_par_addLog(step.action);
  if (step.accept) {
    document.getElementById('pda_par_verdict').innerHTML = '<div class="sim-verdict accept">ACCEPT</div>';
  } else if (step.reject) {
    document.getElementById('pda_par_verdict').innerHTML = '<div class="sim-verdict reject">REJECT</div>';
  }
}

function pda_par_run() {
  if (!pda_par_initialized) { if (!pda_par_init()) return; }
  if (pda_par_running) return;
  pda_par_running = true;
  function tick() {
    if (pda_par_cur >= pda_par_steps.length - 1) { pda_par_running = false; return; }
    pda_par_step();
    var t = setTimeout(tick, 700);
    pda_par_timers.push(t);
  }
  tick();
}

function pda_par_reset() {
  pda_par_timers.forEach(function(t) { clearTimeout(t); });
  pda_par_timers = [];
  pda_par_running = false;
  pda_par_initialized = false;
  pda_par_cur = 0;
  pda_par_steps = [];
  document.getElementById('pda_par_tape').innerHTML = '';
  document.getElementById('pda_par_stack').innerHTML = '<div class="sim-stack-cell">$</div>';
  document.getElementById('pda_par_log').innerHTML = '';
  document.getElementById('pda_par_verdict').innerHTML = '';
  pda_par_highlightState('q0');
}

// ===================================================================
// ENHANCEMENT 3: Palindrome Simulator (Slide 13)
// ===================================================================
var pda_pal_steps = [];
var pda_pal_cur = 0;
var pda_pal_timers = [];
var pda_pal_running = false;
var pda_pal_initialized = false;

function pda_pal_buildSteps(input) {
  var steps = [];
  var stack = ['$'];
  var state = 'q0';
  var pos = 0;
  var mid = Math.floor(input.length / 2);
  steps.push({ state: 'q0', pos: 0, stack: ['$'], action: 'Start' });

  // Push phase: read first half
  for (var i = 0; i < mid; i++) {
    var ch = input[pos];
    if (stack[0] === '$') {
      stack = [ch].concat(stack);
    } else {
      stack = [ch].concat(stack);
    }
    pos++;
    steps.push({ state: 'q0', pos: pos, stack: stack.slice(), action: "Read '" + ch + "', push " + ch });
  }

  // Nondeterministic guess: epsilon-transition to q1
  if (input.length > 0 && input.length % 2 === 0) {
    state = 'q1';
    steps.push({ state: 'q1', pos: pos, stack: stack.slice(), action: "\u03b5-move: GUESS midpoint! (q0 \u2192 q1)", guess: true });
  }

  // Pop/match phase
  if (state === 'q1') {
    var ok = true;
    while (pos < input.length) {
      var ch2 = input[pos];
      var top = stack.length > 0 ? stack[0] : null;
      if (top === ch2) {
        stack.shift();
        pos++;
        steps.push({ state: 'q1', pos: pos, stack: stack.slice(), action: "Read '" + ch2 + "', pop " + ch2 + " (match!)" });
      } else {
        ok = false;
        steps.push({ state: 'q1', pos: pos, stack: stack.slice(), action: "Read '" + ch2 + "' but top is '" + top + "'. REJECT!", reject: true });
        break;
      }
    }
    if (ok) {
      if (stack.length > 0 && stack[0] === '$' && pos === input.length) {
        steps.push({ state: 'q_acc', pos: pos, stack: stack.slice(), action: "\u03b5-move, see $, ACCEPT!", accept: true });
      } else if (pos === input.length) {
        steps.push({ state: 'q1', pos: pos, stack: stack.slice(), action: "Stack not at $. REJECT!", reject: true });
      }
    }
  } else if (input.length === 0) {
    // Empty string: accept directly
    steps.push({ state: 'q_acc', pos: 0, stack: ['$'], action: "\u03b5-move, see $, ACCEPT!", accept: true });
  } else {
    // Odd length or cannot match
    steps.push({ state: state, pos: pos, stack: stack.slice(), action: "Odd length / no valid guess. REJECT!", reject: true });
  }
  return steps;
}

function pda_pal_renderTape(input, pos) {
  var el = document.getElementById('pda_pal_tape');
  var html = '';
  for (var i = 0; i < input.length; i++) {
    var cls = 'sim-tape-cell';
    if (i < pos) cls += ' consumed';
    else if (i === pos) cls += ' current';
    html += '<div class="' + cls + '">' + input[i] + '</div>';
  }
  if (pos >= input.length) {
    html += '<div class="sim-tape-cell current" style="color:#94a3b8;">\u03b5</div>';
  }
  el.innerHTML = html;
}

function pda_pal_renderStack(stack) {
  var el = document.getElementById('pda_pal_stack');
  var html = '';
  for (var i = 0; i < stack.length; i++) {
    html += '<div class="sim-stack-cell push-anim">' + stack[i] + '</div>';
  }
  el.innerHTML = html;
}

function pda_pal_highlightState(s) {
  ['q0', 'q1', 'qacc'].forEach(function(id) {
    document.getElementById('pda_pal_' + id).classList.remove('active-state');
    document.getElementById('pda_pal_' + id).classList.remove('purple-flash');
  });
  var map = { 'q0': 'q0', 'q1': 'q1', 'q_acc': 'qacc' };
  if (map[s]) document.getElementById('pda_pal_' + map[s]).classList.add('active-state');
}

function pda_pal_addLog(msg) {
  var el = document.getElementById('pda_pal_log');
  el.innerHTML += '<div class="log-entry">' + pda_pal_cur + ': ' + msg + '</div>';
  el.scrollTop = el.scrollHeight;
}

function pda_pal_init() {
  var raw = document.getElementById('pda_pal_input').value.trim();
  if (!/^[01]*$/.test(raw)) { alert('Only 0 and 1 characters allowed!'); return false; }
  pda_pal_steps = pda_pal_buildSteps(raw);
  pda_pal_cur = 0;
  pda_pal_initialized = true;
  document.getElementById('pda_pal_log').innerHTML = '';
  document.getElementById('pda_pal_verdict').innerHTML = '';
  var step = pda_pal_steps[0];
  pda_pal_renderTape(raw, step.pos);
  pda_pal_renderStack(step.stack);
  pda_pal_highlightState(step.state);
  pda_pal_addLog(step.action);
  return true;
}

function pda_pal_step() {
  if (!pda_pal_initialized) { if (!pda_pal_init()) return; }
  if (pda_pal_cur >= pda_pal_steps.length - 1) return;
  pda_pal_cur++;
  var step = pda_pal_steps[pda_pal_cur];
  var raw = document.getElementById('pda_pal_input').value.trim();
  pda_pal_renderTape(raw, step.pos);
  pda_pal_renderStack(step.stack);
  pda_pal_highlightState(step.state);
  pda_pal_addLog(step.action);
  // Purple flash for guess moment
  if (step.guess) {
    var q1el = document.getElementById('pda_pal_q1');
    q1el.classList.add('purple-flash');
    setTimeout(function() { q1el.classList.remove('purple-flash'); }, 700);
  }
  if (step.accept) {
    document.getElementById('pda_pal_verdict').innerHTML = '<div class="sim-verdict accept">ACCEPT</div>';
  } else if (step.reject) {
    document.getElementById('pda_pal_verdict').innerHTML = '<div class="sim-verdict reject">REJECT</div>';
  }
}

function pda_pal_run() {
  if (!pda_pal_initialized) { if (!pda_pal_init()) return; }
  if (pda_pal_running) return;
  pda_pal_running = true;
  function tick() {
    if (pda_pal_cur >= pda_pal_steps.length - 1) { pda_pal_running = false; return; }
    pda_pal_step();
    var t = setTimeout(tick, 700);
    pda_pal_timers.push(t);
  }
  tick();
}

function pda_pal_reset() {
  pda_pal_timers.forEach(function(t) { clearTimeout(t); });
  pda_pal_timers = [];
  pda_pal_running = false;
  pda_pal_initialized = false;
  pda_pal_cur = 0;
  pda_pal_steps = [];
  document.getElementById('pda_pal_tape').innerHTML = '';
  document.getElementById('pda_pal_stack').innerHTML = '<div class="sim-stack-cell">$</div>';
  document.getElementById('pda_pal_log').innerHTML = '';
  document.getElementById('pda_pal_verdict').innerHTML = '';
  pda_pal_highlightState('q0');
}

// ===================================================================
// ENHANCEMENT 4: CFG->PDA Step-Through (Slide 16)
// ===================================================================
var pda_cfg_steps = [
  { stack: ['$'], input: 'aabb', action: 'Start: stack=[$], input="aabb"', type: 'start' },
  { stack: ['S', '$'], input: 'aabb', action: 'Push S: stack=[S, $], input="aabb"', type: 'start' },
  { stack: ['a', 'S', 'b', '$'], input: 'aabb', action: 'Expand S \u2192 aSb: stack=[a, S, b, $]', type: 'expand' },
  { stack: ['S', 'b', '$'], input: 'abb', action: "Match 'a': consume input, pop a", type: 'match' },
  { stack: ['a', 'S', 'b', 'b', '$'], input: 'abb', action: 'Expand S \u2192 aSb again: stack=[a, S, b, b, $]', type: 'expand' },
  { stack: ['S', 'b', 'b', '$'], input: 'bb', action: "Match 'a': consume input, pop a", type: 'match' },
  { stack: ['b', 'b', '$'], input: 'bb', action: 'Expand S \u2192 \u03b5 (base case): S removed', type: 'expand' },
  { stack: ['b', '$'], input: 'b', action: "Match 'b': consume input, pop b", type: 'match' },
  { stack: ['$'], input: '', action: "Match 'b': consume input, pop b", type: 'match' },
  { stack: ['$'], input: '', action: 'Stack has only $, input consumed. ACCEPT!', type: 'accept' }
];
var pda_cfg_cur = 0;
var pda_cfg_timers = [];
var pda_cfg_running = false;

function pda_cfg_render() {
  var step = pda_cfg_steps[pda_cfg_cur];
  // Stack
  var sel = document.getElementById('pda_cfg_stack');
  var html = '';
  for (var i = 0; i < step.stack.length; i++) {
    var sym = step.stack[i];
    var style = '';
    if (sym === 'S') style = 'color:#a78bfa;';
    else if (sym === '$') style = 'color:#64748b;';
    else style = 'color:#4ade80;';
    html += '<div class="sim-stack-cell push-anim" style="' + style + '">' + sym + '</div>';
  }
  sel.innerHTML = html;
  // Input
  document.getElementById('pda_cfg_input').textContent = step.input.length > 0 ? '"' + step.input + '"' : '(empty)';
  // Action
  var ael = document.getElementById('pda_cfg_action');
  ael.textContent = step.action;
  ael.className = 'cfg-step-action ' + step.type;
  // Counter
  document.getElementById('pda_cfg_counter').textContent = 'Step ' + pda_cfg_cur + ' / 9';
  // Log
  var lel = document.getElementById('pda_cfg_log');
  lel.innerHTML += '<div class="log-entry">' + pda_cfg_cur + ': ' + step.action + '</div>';
  lel.scrollTop = lel.scrollHeight;
}

function pda_cfg_next() {
  if (pda_cfg_cur >= pda_cfg_steps.length - 1) return;
  pda_cfg_cur++;
  pda_cfg_render();
}

function pda_cfg_auto() {
  if (pda_cfg_running) return;
  pda_cfg_running = true;
  function tick() {
    if (pda_cfg_cur >= pda_cfg_steps.length - 1) { pda_cfg_running = false; return; }
    pda_cfg_next();
    var t = setTimeout(tick, 900);
    pda_cfg_timers.push(t);
  }
  tick();
}

function pda_cfg_reset() {
  pda_cfg_timers.forEach(function(t) { clearTimeout(t); });
  pda_cfg_timers = [];
  pda_cfg_running = false;
  pda_cfg_cur = 0;
  document.getElementById('pda_cfg_log').innerHTML = '';
  pda_cfg_render();
}

// Initialize CFG display
(function() {
  // Will render on first view; safe to call now since DOM elements exist
  setTimeout(function() { pda_cfg_render(); }, 50);
})();

// ===================================================================
// ENHANCEMENT 5: Challenge Quiz (Slide 21)
// ===================================================================
var pda_q1_pool = [
  {
    q: "PDA for a\u207fb\u207f: Does it accept 'aab'?",
    options: ['Yes', 'No'],
    correct: 1,
    explanation: "After reading aa (stack: a a $) and b (stack: a $), input is empty but stack still has 'a'. No transition to accept state."
  },
  {
    q: "PDA for a\u207fb\u207f: What's on the stack after reading 'aaa'?",
    options: ['a $', 'a a $', 'a a a $', '$ a a a'],
    correct: 2,
    explanation: "Each 'a' pushes one 'a' onto the stack above $. After three a's: a a a $ (top to bottom)."
  },
  {
    q: "Can a DPDA recognize {ww\u1d3f | w \u2208 {0,1}*}?",
    options: ['Yes', 'No'],
    correct: 1,
    explanation: "Recognizing even palindromes requires guessing the midpoint, which needs nondeterminism. No DPDA can do this."
  },
  {
    q: "PDA for balanced parens: Does it accept '(()'?",
    options: ['Yes', 'No'],
    correct: 1,
    explanation: "After reading (( (stack: L L $) and ) (stack: L $), input is empty but stack has L above $. Unmatched open paren."
  },
  {
    q: "True or False: Every DPDA language is also a CFL.",
    options: ['True', 'False'],
    correct: 0,
    explanation: "DPDA \u2282 PDA. Every deterministic CFL is context-free. The converse is false -- some CFLs need nondeterminism."
  },
  {
    q: "In the CFG\u2192PDA construction, how many states does the resulting PDA have?",
    options: ['1', '2', '3', '4'],
    correct: 2,
    explanation: "The construction uses exactly 3 states: q_start, q_loop (does all the work), and q_accept."
  }
];

var pda_q1_selected = [];
var pda_q1_currentQ = 0;
var pda_q1_score = 0;
var pda_q1_timers = [];
var pda_q1_started = false;

function pda_q1_shuffle(arr) {
  var a = arr.slice();
  for (var i = a.length - 1; i > 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    var tmp = a[i]; a[i] = a[j]; a[j] = tmp;
  }
  return a;
}

function pda_q1_start() {
  pda_q1_timers.forEach(function(t) { clearTimeout(t); });
  pda_q1_timers = [];
  pda_q1_selected = pda_q1_shuffle(pda_q1_pool).slice(0, 3);
  pda_q1_currentQ = 0;
  pda_q1_score = 0;
  pda_q1_started = true;
  document.getElementById('pda_q1_score').style.display = 'none';
  pda_q1_showQuestion();
}

function pda_q1_showQuestion() {
  if (pda_q1_currentQ >= 3) {
    pda_q1_showFinal();
    return;
  }
  var q = pda_q1_selected[pda_q1_currentQ];
  var area = document.getElementById('pda_q1_area');
  var html = '<div class="quiz-question">';
  html += '<h3>Question ' + (pda_q1_currentQ + 1) + ' of 3</h3>';
  html += '<p style="margin-bottom:16px;font-size:1.1em;">' + q.q + '</p>';
  html += '<div class="quiz-btn-row">';
  for (var i = 0; i < q.options.length; i++) {
    html += '<button class="quiz-btn" onclick="pda_q1_answer(' + i + ')" id="pda_q1_opt' + i + '">' + q.options[i] + '</button>';
  }
  html += '</div>';
  html += '<div class="quiz-explanation" id="pda_q1_expl">' + q.explanation + '</div>';
  html += '</div>';
  area.innerHTML = html;
}

function pda_q1_answer(idx) {
  var q = pda_q1_selected[pda_q1_currentQ];
  // Disable all buttons
  for (var i = 0; i < q.options.length; i++) {
    var btn = document.getElementById('pda_q1_opt' + i);
    btn.disabled = true;
    if (i === q.correct) btn.classList.add('correct');
    if (i === idx && i !== q.correct) btn.classList.add('wrong');
  }
  if (idx === q.correct) pda_q1_score++;
  document.getElementById('pda_q1_expl').style.display = 'block';
  var t = setTimeout(function() {
    pda_q1_currentQ++;
    pda_q1_showQuestion();
  }, 2500);
  pda_q1_timers.push(t);
}

function pda_q1_showFinal() {
  var area = document.getElementById('pda_q1_area');
  area.innerHTML = '';
  var sel = document.getElementById('pda_q1_score');
  var color = pda_q1_score === 3 ? '#4ade80' : pda_q1_score >= 2 ? '#fbbf24' : '#f87171';
  sel.innerHTML = 'Score: ' + pda_q1_score + ' / 3<br><span style="font-size:0.6em;color:#94a3b8;">Click below to retry with new questions</span><br><button class="quiz-btn" onclick="pda_q1_start()" style="margin-top:12px;">Try Again</button>';
  sel.style.display = 'block';
  sel.style.color = color;
}

// Auto-start quiz when slide 21 becomes visible
var pda_q1_observer = new MutationObserver(function(mutations) {
  mutations.forEach(function(m) {
    if (m.target.id === 's21' && m.target.classList.contains('active') && !pda_q1_started) {
      pda_q1_start();
    }
  });
});
(function() {
  var s21 = document.getElementById('s21');
  if (s21) pda_q1_observer.observe(s21, { attributes: true, attributeFilter: ['class'] });
})();

// ===================================================================
// ENHANCEMENT: DFA vs PDA Race Demo (Slide 3)
// ===================================================================
var pda_raceTimers = [];
var pda_raceRunning = false;

function pda_raceReset() {
  pda_raceTimers.forEach(function(t) { clearTimeout(t); });
  pda_raceTimers = [];
  pda_raceRunning = false;
  // Reset DFA states
  ['pda_race_dq0','pda_race_dq1','pda_race_dq2','pda_race_dq3'].forEach(function(id) {
    var el = document.getElementById(id);
    el.classList.remove('lit','fail');
  });
  document.getElementById('pda_race_dfa_tape').innerHTML = '';
  document.getElementById('pda_race_dfa_verdict').innerHTML = '';
  document.getElementById('pda_race_pda_stack').innerHTML = '';
  document.getElementById('pda_race_pda_tape').innerHTML = '';
  document.getElementById('pda_race_pda_verdict').innerHTML = '';
  // Reset button active states
  var btns = document.getElementById('pda_race_bar').querySelectorAll('button');
  for (var i = 0; i < btns.length; i++) btns[i].classList.remove('active');
}

function pda_raceRun(n) {
  if (pda_raceRunning) return;
  pda_raceReset();
  pda_raceRunning = true;

  // Mark active button
  var btns = document.getElementById('pda_race_bar').querySelectorAll('button');
  btns[n - 1].classList.add('active');

  var input = '';
  for (var i = 0; i < n; i++) input += 'a';
  for (var i = 0; i < n; i++) input += 'b';

  var delay = 400;
  var step = 0;

  // DFA: can handle n <= 3
  var dfaStates = ['pda_race_dq0','pda_race_dq1','pda_race_dq2','pda_race_dq3'];
  var dfaFailed = false;
  var dfaCount = 0;

  for (var idx = 0; idx < input.length; idx++) {
    (function(idx, ch) {
      var t = setTimeout(function() {
        // Update DFA tape
        var tapeHtml = '';
        for (var j = 0; j < input.length; j++) {
          var style = j < idx ? 'color:#475569;' : j === idx ? 'color:#fbbf24;font-weight:bold;' : 'color:#e2e8f0;';
          tapeHtml += '<span style="'+style+'">' + input[j] + ' </span>';
        }
        document.getElementById('pda_race_dfa_tape').innerHTML = tapeHtml;

        if (!dfaFailed) {
          // Clear previous lit
          dfaStates.forEach(function(id) { document.getElementById(id).classList.remove('lit','fail'); });

          if (ch === 'a') {
            dfaCount++;
            if (dfaCount <= 3) {
              document.getElementById(dfaStates[dfaCount]).classList.add('lit');
            } else {
              dfaFailed = true;
              document.getElementById(dfaStates[3]).classList.add('fail');
              document.getElementById('pda_race_dfa_verdict').innerHTML = '<span style="color:#f87171;">\u2718 DFA fails! Only 3 counting states.</span>';
            }
          } else {
            // reading b
            dfaCount--;
            if (dfaCount >= 0 && dfaCount <= 3) {
              document.getElementById(dfaStates[dfaCount]).classList.add('lit');
            }
          }
        }

        // Update PDA tape
        var pdaTapeHtml = '';
        for (var j = 0; j < input.length; j++) {
          var style2 = j < idx ? 'color:#475569;' : j === idx ? 'color:#fbbf24;font-weight:bold;' : 'color:#e2e8f0;';
          pdaTapeHtml += '<span style="'+style2+'">' + input[j] + ' </span>';
        }
        document.getElementById('pda_race_pda_tape').innerHTML = pdaTapeHtml;

        // Update PDA stack
        var stackArea = document.getElementById('pda_race_pda_stack');
        if (ch === 'a') {
          // push
          var cell = document.createElement('div');
          cell.className = 'pda-race-stack-cell push-in';
          cell.textContent = 'a';
          stackArea.insertBefore(cell, stackArea.firstChild);
        } else {
          // pop
          if (stackArea.firstChild) {
            stackArea.firstChild.classList.add('pop-out');
            var toRemove = stackArea.firstChild;
            setTimeout(function() { if (toRemove.parentNode) toRemove.parentNode.removeChild(toRemove); }, 350);
          }
        }
      }, step * delay);
      pda_raceTimers.push(t);
      step++;
    })(idx, input[idx]);
  }

  // Final verdicts
  var t1 = setTimeout(function() {
    if (!dfaFailed && n <= 3) {
      // Clear previous lit
      dfaStates.forEach(function(id) { document.getElementById(id).classList.remove('lit','fail'); });
      document.getElementById(dfaStates[0]).classList.add('lit');
      document.getElementById('pda_race_dfa_verdict').innerHTML = '<span style="color:#4ade80;">\u2714 DFA handles this!</span>';
    }
    // PDA: show $ marker, always succeeds
    var stackArea = document.getElementById('pda_race_pda_stack');
    var dollarCell = document.createElement('div');
    dollarCell.className = 'pda-race-stack-cell';
    dollarCell.textContent = '$';
    dollarCell.style.color = '#64748b';
    stackArea.appendChild(dollarCell);
    document.getElementById('pda_race_pda_verdict').innerHTML = '<span style="color:#4ade80;">\u2714 PDA handles ANY n!</span>';
    pda_raceRunning = false;
  }, step * delay + 200);
  pda_raceTimers.push(t1);

  // Show initial $ on PDA stack
  var stackArea = document.getElementById('pda_race_pda_stack');
  var initDollar = document.createElement('div');
  initDollar.className = 'pda-race-stack-cell';
  initDollar.textContent = '$';
  initDollar.style.color = '#64748b';
  stackArea.appendChild(initDollar);
}

// ===================================================================
// ENHANCEMENT: Animated PDA Machine SVG (Slide 4)
// ===================================================================
var pda_machSteps = [
  { state: 'q0', pos: -1, stack: ['$'], msg: 'Ready: input "aaabbb", state q0' },
  { state: 'q0', pos: 0,  stack: ['a','$'], msg: 'Read a, push a' },
  { state: 'q0', pos: 1,  stack: ['a','a','$'], msg: 'Read a, push a' },
  { state: 'q0', pos: 2,  stack: ['a','a','a','$'], msg: 'Read a, push a' },
  { state: 'q1', pos: 3,  stack: ['a','a','$'], msg: 'Read b, pop a \u2192 go to q1' },
  { state: 'q1', pos: 4,  stack: ['a','$'], msg: 'Read b, pop a' },
  { state: 'q1', pos: 5,  stack: ['$'], msg: 'Read b, pop a' },
  { state: 'q_acc', pos: 6, stack: ['$'], msg: '\u03b5-move, see $, ACCEPT!' }
];
var pda_machCur = 0;
var pda_machTimers = [];
var pda_machIsRunning = false;
var pda_machTapeSymbols = ['a','a','a','b','b','b','',''];

function pda_machRender() {
  var step = pda_machSteps[pda_machCur];
  var svg = document.getElementById('pda_mach_svg');

  // Render tape cells
  var tapeG = document.getElementById('pda_mach_tape');
  var tapeHtml = '';
  for (var i = 0; i < 8; i++) {
    var x = 110 + i * 65;
    var fillColor = '#0f172a';
    var strokeColor = '#475569';
    if (i === step.pos) { fillColor = 'rgba(250,204,21,0.2)'; strokeColor = '#fbbf24'; }
    else if (i < step.pos) { fillColor = '#1e293b'; }
    tapeHtml += '<rect x="'+x+'" y="30" width="60" height="36" rx="4" fill="'+fillColor+'" stroke="'+strokeColor+'" stroke-width="1.5"/>';
    var textColor = i < step.pos ? '#475569' : '#e2e8f0';
    if (i === step.pos) textColor = '#fbbf24';
    tapeHtml += '<text x="'+(x+30)+'" y="54" fill="'+textColor+'" font-family="\'SF Mono\', monospace" font-size="16" text-anchor="middle">' + pda_machTapeSymbols[i] + '</text>';
  }
  tapeG.innerHTML = tapeHtml;

  // Move read head
  var head = document.getElementById('pda_mach_head');
  var headPos = step.pos >= 0 && step.pos < 8 ? step.pos : 0;
  var headX = 110 + headPos * 65 + 30;
  head.setAttribute('transform', 'translate('+headX+', 78)');
  head.style.transition = 'transform 0.3s ease';
  head.style.opacity = step.pos >= 0 && step.pos < 6 ? '1' : '0.3';

  // Update state label
  var stateLabel = document.getElementById('pda_mach_state_label');
  var displayState = step.state === 'q_acc' ? 'q_acc' : step.state;
  stateLabel.textContent = displayState;
  stateLabel.style.transition = 'fill 0.3s';

  // Update control box
  var ctrl = document.getElementById('pda_mach_ctrl');
  if (step.state === 'q_acc') {
    ctrl.setAttribute('stroke', '#22c55e');
    ctrl.setAttribute('stroke-width', '3');
    stateLabel.setAttribute('fill', '#4ade80');
  } else {
    ctrl.setAttribute('stroke', '#475569');
    ctrl.setAttribute('stroke-width', '2');
    stateLabel.setAttribute('fill', '#93c5fd');
  }

  // Render stack
  var stackG = document.getElementById('pda_mach_stack');
  var stackHtml = '';
  for (var i = 0; i < step.stack.length; i++) {
    var sy = 158 + i * 32;
    var sym = step.stack[i];
    var sColor = sym === '$' ? '#64748b' : '#93c5fd';
    var sBg = i === 0 ? 'rgba(59,130,246,0.1)' : '#0f172a';
    var sStroke = i === 0 ? '#3b82f6' : '#475569';
    stackHtml += '<rect x="560" y="'+sy+'" width="60" height="28" rx="4" fill="'+sBg+'" stroke="'+sStroke+'" stroke-width="1.5"/>';
    stackHtml += '<text x="590" y="'+(sy+18)+'" fill="'+sColor+'" font-family="\'SF Mono\', monospace" font-size="14" text-anchor="middle">' + sym + '</text>';
  }
  stackG.innerHTML = stackHtml;

  // Status text
  document.getElementById('pda_mach_status_text').textContent = step.msg;
  document.getElementById('pda_mach_step_counter').textContent = 'Step ' + pda_machCur + ' / 7';
}

function pda_machStep() {
  if (pda_machCur >= pda_machSteps.length - 1) return;
  pda_machCur++;
  pda_machRender();
}

function pda_machRun() {
  if (pda_machIsRunning) return;
  pda_machIsRunning = true;
  function tick() {
    if (pda_machCur >= pda_machSteps.length - 1) { pda_machIsRunning = false; return; }
    pda_machStep();
    var t = setTimeout(tick, 800);
    pda_machTimers.push(t);
  }
  tick();
}

function pda_machReset() {
  pda_machTimers.forEach(function(t) { clearTimeout(t); });
  pda_machTimers = [];
  pda_machIsRunning = false;
  pda_machCur = 0;
  pda_machRender();
}

// Initial render of slide 4 machine
setTimeout(function() { pda_machRender(); }, 60);

// ===================================================================
// ENHANCEMENT: Transition Explorer (Slide 6)
// ===================================================================
var pda_trxTimers = [];
var pda_trxData = [
  {
    qLabel: 'q0', pLabel: 'q0',
    arrowText: 'a, $ / a$',
    before: ['$'],
    after: ['a', '$'],
    explain: '<strong>Push:</strong> Read input "a", pop $ from stack, push a$ (a on top, $ below). Net effect: "a" is added above $.'
  },
  {
    qLabel: 'q1', pLabel: 'q1',
    arrowText: 'b, a / \u03b5',
    before: ['a', 'Y', '$'],
    after: ['Y', '$'],
    explain: '<strong>Pop:</strong> Read input "b", pop "a" from stack, push \u03b5 (nothing). Net effect: "a" is removed from the stack.'
  },
  {
    qLabel: 'q', pLabel: 'p',
    arrowText: 'a, X / X',
    before: ['X', 'Y', '$'],
    after: ['X', 'Y', '$'],
    explain: '<strong>No-change:</strong> Read "a", pop X, push X back. The stack is unchanged \u2014 X stays on top.'
  },
  {
    qLabel: 'q', pLabel: 'p',
    arrowText: 'a, X / ABC',
    before: ['X', 'Y', '$'],
    after: ['A', 'B', 'C', 'Y', '$'],
    explain: '<strong>Multi-push:</strong> Pop X, push ABC (A on top). X is replaced by three symbols. Stack grows!'
  }
];
var pda_trxSelected = -1;

function pda_trxReset() {
  pda_trxTimers.forEach(function(t) { clearTimeout(t); });
  pda_trxTimers = [];
  document.getElementById('pda_trx_before').innerHTML = '';
  document.getElementById('pda_trx_after').innerHTML = '';
}

function pda_trxSelect(idx) {
  pda_trxReset();
  pda_trxSelected = idx;
  var data = pda_trxData[idx];

  // Update button active states
  var btns = document.querySelectorAll('.pda-trx-btn');
  for (var i = 0; i < btns.length; i++) {
    btns[i].classList.toggle('active', i === idx);
  }

  // Update SVG labels
  document.getElementById('pda_trx_q_label').textContent = data.qLabel;
  document.getElementById('pda_trx_p_label').textContent = data.pLabel;
  document.getElementById('pda_trx_arrow_label').textContent = data.arrowText;

  // Show "Before" stack immediately
  var beforeEl = document.getElementById('pda_trx_before');
  var bHtml = '';
  for (var i = 0; i < data.before.length; i++) {
    var c = data.before[i] === '$' ? '#64748b' : '#93c5fd';
    bHtml += '<div class="pda-trx-stack-cell" style="color:'+c+';">' + data.before[i] + '</div>';
  }
  beforeEl.innerHTML = bHtml;

  // Pulse the arrow
  var arrow = document.getElementById('pda_trx_arrow');
  arrow.style.animation = 'pda-trx-arrow-pulse 0.6s ease 2';
  var t0 = setTimeout(function() { arrow.style.animation = ''; }, 1200);
  pda_trxTimers.push(t0);

  // After 600ms, show "After" stack with animation
  var t1 = setTimeout(function() {
    pda_trxAnimate(idx);
  }, 600);
  pda_trxTimers.push(t1);

  // Show explanation
  document.getElementById('pda_trx_explain').innerHTML = data.explain;
}

function pda_trxAnimate(idx) {
  var data = pda_trxData[idx];
  var afterEl = document.getElementById('pda_trx_after');
  var aHtml = '';
  for (var i = 0; i < data.after.length; i++) {
    var c = data.after[i] === '$' ? '#64748b' : '#93c5fd';
    var cls = 'pda-trx-stack-cell';
    // Determine if this cell is "new"
    if (idx === 0 && i === 0) cls += ' new-cell'; // push: 'a' is new
    if (idx === 2 && i === 0) cls += ' glow';      // no-change: X glows
    if (idx === 3 && i < 3) cls += ' new-cell';   // multi-push: A,B,C are new
    aHtml += '<div class="'+cls+'" style="color:'+c+';">' + data.after[i] + '</div>';
  }
  afterEl.innerHTML = aHtml;
}

// INITIALIZATION
showSlide(1);
</script>

</body>
</html>
