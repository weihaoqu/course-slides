<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Context-Free Grammars (CFG) - CS305</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; background: #0f172a; color: #e2e8f0; }
.slide { display: none; min-height: 100vh; padding: 40px 60px; position: relative; }
.slide.active { display: flex; flex-direction: column; justify-content: center; }
.slide-number { position: absolute; bottom: 20px; right: 40px; color: #64748b; font-size: 14px; }
.nav { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; z-index: 100; }
.nav button { background: #334155; border: 1px solid #475569; color: #e2e8f0; padding: 8px 20px; border-radius: 8px; cursor: pointer; font-size: 14px; transition: all 0.2s; }
.nav button:hover { background: #475569; }
.nav button:disabled { opacity: 0.3; cursor: not-allowed; }
.progress { position: fixed; top: 0; left: 0; height: 3px; background: linear-gradient(90deg, #3b82f6, #8b5cf6); transition: width 0.3s; z-index: 100; }
h1 { font-size: 2.8em; margin-bottom: 20px; background: linear-gradient(135deg, #3b82f6, #8b5cf6); -webkit-background-clip: text; -webkit-text-fill-color: transparent; line-height: 1.2; }
h2 { font-size: 2em; margin-bottom: 16px; color: #93c5fd; }
h3 { font-size: 1.4em; margin-bottom: 12px; color: #a5b4fc; }
p, li { font-size: 1.15em; line-height: 1.7; color: #cbd5e1; margin-bottom: 10px; }
.subtitle { font-size: 1.3em; color: #94a3b8; margin-bottom: 30px; }
.two-col { display: grid; grid-template-columns: 1fr 1fr; gap: 40px; align-items: start; }
.center { text-align: center; }
.mt { margin-top: 20px; }
.diagram { background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 24px; font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; font-size: 1em; line-height: 1.6; white-space: pre; overflow-x: auto; margin: 16px 0; color: #a5f3fc; }
.diagram.small { font-size: 0.85em; }
.key-idea { background: linear-gradient(135deg, rgba(59,130,246,0.15), rgba(139,92,246,0.15)); border-left: 4px solid #3b82f6; border-radius: 0 12px 12px 0; padding: 20px 24px; margin: 16px 0; }
.key-idea h3 { margin-bottom: 8px; }
.warning { background: rgba(245,158,11,0.12); border-left: 4px solid #f59e0b; border-radius: 0 12px 12px 0; padding: 20px 24px; margin: 16px 0; }
.warning h3 { color: #fbbf24; }
.analogy { background: rgba(16,185,129,0.12); border-left: 4px solid #10b981; border-radius: 0 12px 12px 0; padding: 20px 24px; margin: 16px 0; }
.analogy h3 { color: #34d399; }
table { border-collapse: collapse; margin: 16px 0; width: auto; }
th, td { border: 1px solid #475569; padding: 10px 16px; text-align: center; }
th { background: #334155; color: #93c5fd; font-weight: 600; }
td { background: #1e293b; color: #e2e8f0; }
tr.highlight td { background: rgba(59,130,246,0.2); }
.fade-in { animation: fadeIn 0.5s ease-in; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
ul { padding-left: 24px; }
ul li { margin-bottom: 8px; }
.deriv-step { font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; font-size: 1.05em; color: #a5f3fc; padding: 4px 0; }
.deriv-step .replaced { color: #f472b6; font-weight: bold; }
.deriv-step .arrow { color: #64748b; margin: 0 8px; }

/* Derivation Stepper */
.cfg-der-container { background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 24px; margin: 12px 0; }
.cfg-der-controls { display: flex; gap: 10px; align-items: center; margin-bottom: 16px; flex-wrap: wrap; }
.cfg-der-btn { background: #334155; border: 1px solid #475569; color: #e2e8f0; padding: 8px 18px; border-radius: 8px; cursor: pointer; font-size: 0.95em; transition: all 0.2s; }
.cfg-der-btn:hover { background: #475569; }
.cfg-der-btn:disabled { opacity: 0.3; cursor: not-allowed; }
.cfg-der-btn.active { background: rgba(59,130,246,0.3); border-color: #3b82f6; }
.cfg-der-form { font-family: 'SF Mono', monospace; font-size: 1.2em; color: #a5f3fc; padding: 8px 0; }
.cfg-der-form .hl-left { color: #f472b6; font-weight: 700; text-decoration: underline; }
.cfg-der-form .hl-right { color: #34d399; font-weight: 700; text-decoration: underline; }
.cfg-der-log { background: #0f172a; border: 1px solid #334155; border-radius: 8px; padding: 12px; max-height: 150px; overflow-y: auto; font-family: 'SF Mono', monospace; font-size: 0.85em; line-height: 1.8; margin-top: 12px; }
.cfg-der-log-item { color: #64748b; }
.cfg-der-log-item.done { color: #34d399; }
.cfg-der-log-item.current { color: #f59e0b; font-weight: 600; }

/* Parse Tree Builder */
.cfg-pt-container { background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 20px; margin: 12px 0; }
.cfg-pt-controls { display: flex; gap: 10px; align-items: center; margin-bottom: 12px; flex-wrap: wrap; }
.cfg-pt-step-label { color: #94a3b8; font-size: 0.9em; margin-left: auto; }
.cfg-pt-tree { display: flex; flex-direction: column; align-items: center; gap: 4px; min-height: 250px; padding: 16px; background: #0f172a; border-radius: 8px; border: 1px solid #334155; }
.cfg-pt-node { display: inline-flex; align-items: center; justify-content: center; min-width: 36px; height: 32px; padding: 0 10px; border-radius: 6px; font-family: 'SF Mono', monospace; font-size: 0.9em; font-weight: 600; opacity: 0; transform: scale(0.7); transition: opacity 0.4s, transform 0.4s; }
.cfg-pt-node.visible { opacity: 1; transform: scale(1); }
.cfg-pt-node.variable { background: rgba(59,130,246,0.2); border: 2px solid #3b82f6; color: #93c5fd; }
.cfg-pt-node.terminal { background: rgba(16,185,129,0.2); border: 2px solid #10b981; color: #34d399; }
.cfg-pt-node.operator { background: rgba(245,158,11,0.2); border: 2px solid #f59e0b; color: #fbbf24; }
.cfg-pt-node.highlight { box-shadow: 0 0 12px rgba(59,130,246,0.5); }

/* Ambiguity Explorer */
.cfg-amb-container { background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 20px; margin: 12px 0; }
.cfg-amb-controls { display: flex; gap: 10px; margin-bottom: 16px; justify-content: center; flex-wrap: wrap; }
.cfg-amb-compare { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
.cfg-amb-panel { background: #0f172a; border-radius: 10px; padding: 16px; border: 2px solid #334155; text-align: center; transition: all 0.3s; }
.cfg-amb-panel.active { border-color: #3b82f6; }
.cfg-amb-panel.wrong { border-color: #ef4444; }
.cfg-amb-panel.correct { border-color: #10b981; }
.cfg-amb-eval { margin-top: 12px; padding: 8px; border-radius: 6px; font-family: monospace; }

/* CNF Conversion Visualizer */
.cfg-cnf-container { background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 20px; margin: 12px 0; }
.cfg-cnf-controls { display: flex; gap: 10px; align-items: center; margin-bottom: 16px; flex-wrap: wrap; }
.cfg-cnf-display { display: grid; grid-template-columns: 1fr auto 1fr; gap: 12px; align-items: start; }
.cfg-cnf-box { background: #0f172a; border: 1px solid #334155; border-radius: 8px; padding: 16px; font-family: 'SF Mono', monospace; font-size: 0.9em; line-height: 1.8; color: #a5f3fc; }
.cfg-cnf-arrow { color: #f59e0b; font-size: 1.5em; display: flex; align-items: center; }
.cfg-cnf-highlight { color: #f472b6; font-weight: 700; }

/* Quiz */
.cfg-quiz-container { background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 30px; margin: 16px 0; text-align: center; }
.cfg-quiz-question { font-size: 1.3em; color: #e2e8f0; margin-bottom: 24px; line-height: 1.6; }
.cfg-quiz-options { display: flex; gap: 16px; justify-content: center; flex-wrap: wrap; }
.cfg-quiz-btn { background: #334155; border: 2px solid #475569; color: #e2e8f0; padding: 12px 28px; border-radius: 10px; cursor: pointer; font-size: 1.05em; transition: all 0.3s; min-width: 160px; }
.cfg-quiz-btn:hover { background: #475569; }
.cfg-quiz-btn.correct { background: rgba(16,185,129,0.3); border-color: #10b981; color: #34d399; }
.cfg-quiz-btn.wrong { background: rgba(239,68,68,0.3); border-color: #ef4444; color: #f87171; }
.cfg-quiz-btn:disabled { cursor: default; }
.cfg-quiz-explanation { margin-top: 16px; font-size: 1em; color: #94a3b8; opacity: 0; transition: opacity 0.4s; }
.cfg-quiz-explanation.visible { opacity: 1; }
.cfg-quiz-score { font-size: 1.6em; color: #93c5fd; margin-top: 20px; }
.cfg-quiz-progress { color: #64748b; font-size: 0.9em; margin-bottom: 16px; }
/* Ambiguity Elimination Playground */
.cfg-fix-container { background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 20px; margin: 12px 0; }
.cfg-fix-btns { display: flex; gap: 10px; margin-bottom: 16px; justify-content: center; flex-wrap: wrap; }
.cfg-fix-btn { background: #334155; border: 1px solid #475569; color: #e2e8f0; padding: 8px 18px; border-radius: 8px; cursor: pointer; font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; font-size: 0.95em; transition: all 0.2s; }
.cfg-fix-btn:hover { background: #475569; }
.cfg-fix-btn.active { background: rgba(59,130,246,0.3); border-color: #3b82f6; color: #93c5fd; }
.cfg-fix-compare { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
.cfg-fix-panel { background: #0f172a; border-radius: 10px; padding: 16px; border: 2px solid #334155; }
.cfg-fix-panel.ambiguous { border-color: #f59e0b; }
.cfg-fix-panel.unambiguous { border-color: #10b981; }
.cfg-fix-panel h4 { margin-bottom: 8px; }
.cfg-fix-grammar { font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; font-size: 0.8em; color: #64748b; margin-bottom: 12px; line-height: 1.5; }
.cfg-fix-trees { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
.cfg-fix-tree { font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; font-size: 0.78em; line-height: 1.35; color: #a5f3fc; white-space: pre; padding: 8px; border-radius: 6px; overflow-x: auto; }
.cfg-fix-tree.wrong { background: rgba(239,68,68,0.1); border: 1px solid rgba(239,68,68,0.3); }
.cfg-fix-tree.correct { background: rgba(16,185,129,0.1); border: 1px solid rgba(16,185,129,0.3); }
.cfg-fix-eval { font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; font-size: 0.9em; margin-top: 8px; padding: 6px 10px; border-radius: 4px; }
.cfg-fix-eval.wrong { color: #f87171; }
.cfg-fix-eval.correct { color: #34d399; }
.cfg-fix-single-tree { font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; font-size: 0.78em; line-height: 1.35; color: #a5f3fc; white-space: pre; padding: 10px; background: rgba(16,185,129,0.08); border: 1px solid rgba(16,185,129,0.3); border-radius: 6px; overflow-x: auto; }
.cfg-fix-label { font-size: 0.85em; font-weight: 600; margin-bottom: 4px; }
.cfg-fix-label.warn { color: #fbbf24; }
.cfg-fix-label.ok { color: #34d399; }
.cfg-fix-prompt { color: #64748b; text-align: center; padding: 30px; font-size: 1.1em; }
@media (max-width: 900px) {
  .cfg-fix-compare { grid-template-columns: 1fr; }
  .cfg-fix-trees { grid-template-columns: 1fr; }
}
</style>
</head>
<body>

<div class="progress" id="progress"></div>

<!-- ==================== SLIDE 1: Title ==================== -->
<div class="slide" id="s1">
  <div class="center">
    <h1>Context-Free Grammars (CFG)</h1>
    <p class="subtitle">CS305 -- Formal Language Theory</p>
    <div class="diagram" style="display:inline-block; text-align:left; font-size:0.85em;">
   _____ ______ _____
  / ____|  ____|/ ____|
 | |    | |__ | |  __
 | |    |  __|| | |_ |
 | |____| |   | |__| |
  \_____|_|    \_____|

  "The grammar that builds languages
   beyond the reach of finite automata."
    </div>
    <p style="margin-top:30px; color:#64748b;">Use arrow keys or buttons to navigate. Press S to reveal steps.</p>
  </div>
  <div class="slide-number">1 / 21</div>
</div>

<!-- ==================== SLIDE 2: Chomsky Hierarchy ==================== -->
<div class="slide" id="s2">
  <h2>The Big Picture: Chomsky Hierarchy</h2>
  <p>Where do context-free grammars fit in the world of formal languages?</p>
  <div class="diagram">
  +-----------------------------------------------------------+
  |  Type 0: Recursively Enumerable (Turing Machines)         |
  |                                                           |
  |   +---------------------------------------------------+   |
  |   |  Type 1: Context-Sensitive (Linear Bounded Auto.) |   |
  |   |                                                   |   |
  |   |   +-------------------------------------------+   |   |
  |   |   |  Type 2: Context-Free  (Pushdown Auto.)   |   |   |
  |   |   |                                           |   |   |
  |   |   |   +-----------------------------------+   |   |   |
  |   |   |   |  Type 3: Regular  (Finite Auto.)  |   |   |   |
  |   |   |   |                                   |   |   |   |
  |   |   |   |   a*, ab+, (a|b)*                 |   |   |   |
  |   |   |   +-----------------------------------+   |   |   |
  |   |   |                                           |   |   |
  |   |   |   a^n b^n, balanced parens, palindromes   |   |   |
  |   |   +-------------------------------------------+   |   |
  |   |                                                   |   |
  |   |   a^n b^n c^n                                     |   |
  |   +---------------------------------------------------+   |
  |                                                           |
  |   { descriptions of Turing machines that halt }           |
  +-----------------------------------------------------------+
  </div>
  <div class="key-idea">
    <h3>Key Idea</h3>
    <p>Each level is <strong>strictly more powerful</strong> than the one inside it. Today we jump from Type 3 (regular) to Type 2 (context-free). The new superpower: <strong>a stack</strong> (via pushdown automata) or equivalently, <strong>recursive production rules</strong>.</p>
  </div>
  <div class="slide-number">2 / 21</div>
</div>

<!-- ==================== SLIDE 3: Motivation ==================== -->
<div class="slide" id="s3">
  <h2>Motivation: The Limits of Regular Languages</h2>
  <div class="two-col">
    <div>
      <h3>What DFAs/NFAs CAN'T do</h3>
      <p>The Pumping Lemma showed us these are NOT regular:</p>
      <ul>
        <li><strong>{ a<sup>n</sup>b<sup>n</sup> | n &ge; 0 }</strong> -- equal counts of a's then b's</li>
        <li><strong>Balanced parentheses</strong> -- (()(())), but not (()( </li>
        <li><strong>Palindromes</strong> -- strings that read the same forwards and backwards</li>
        <li><strong>Nested structures</strong> -- HTML tags, math expressions</li>
      </ul>
      <div class="warning">
        <h3>Why DFAs fail</h3>
        <p>Finite automata have <strong>finite memory</strong> (just the current state). They can't "count" unboundedly or "match" things seen earlier.</p>
      </div>
    </div>
    <div>
      <h3>The common pattern</h3>
      <div class="diagram small">
All these languages need NESTING:

  a^n b^n :
  aaaa....bbbb
  |          |
  +--match!--+

  Balanced parens:
  ( ( ) ( ( ) ) )
  | |_| | |_| | |
  |     |_____|_|
  |_____________|

  Palindromes:
  a b c b a
  |   |   |
  +---+---+
    match!
      </div>
      <div class="analogy">
        <h3>Analogy</h3>
        <p>A DFA is like a person counting on their fingers -- they run out. A CFG is like a person with a <strong>notepad</strong>: they can write down what to remember and check it later.</p>
      </div>
    </div>
  </div>
  <div class="slide-number">3 / 21</div>
</div>

<!-- ==================== SLIDE 4: What is a Grammar? ==================== -->
<div class="slide" id="s4">
  <h2>What is a Grammar?</h2>
  <div class="two-col">
    <div>
      <h3>Intuition: Grammars as Recipes</h3>
      <p>A grammar is a set of <strong>rewriting rules</strong> that tell you how to build strings in a language, step by step.</p>
      <div class="diagram small">
Recipe for a SENTENCE:

  SENTENCE  -->  SUBJECT  VERB  OBJECT
  SUBJECT   -->  "the dog" | "a cat"
  VERB      -->  "chased"  | "ate"
  OBJECT    -->  "the ball" | "a fish"

One derivation:
  SENTENCE
  => SUBJECT VERB OBJECT
  => "the dog" VERB OBJECT
  => "the dog" "chased" OBJECT
  => "the dog" "chased" "the ball"
      </div>
    </div>
    <div>
      <h3>Key Terminology</h3>
      <ul>
        <li><strong>Variables</strong> (non-terminals): Placeholders that get replaced. Written in UPPERCASE. Examples: S, A, B, SENTENCE</li>
        <li><strong>Terminals</strong>: The actual characters in the final string. Written in lowercase. Examples: a, b, 0, 1, +, (, )</li>
        <li><strong>Productions</strong>: The rewriting rules. "A --> w" means "A can be replaced by w"</li>
        <li><strong>Start symbol</strong>: Where every derivation begins (usually S)</li>
      </ul>
      <div class="analogy">
        <h3>Analogy</h3>
        <p>Think of variables as <strong>categories</strong> in a recipe book. "DESSERT" isn't something you eat -- it's a category that expands into "chocolate cake" or "apple pie." Terminals are the actual food you eat!</p>
      </div>
    </div>
  </div>
  <div class="slide-number">4 / 21</div>
</div>

<!-- ==================== SLIDE 5: Formal Definition ==================== -->
<div class="slide" id="s5">
  <h2>Formal Definition of a CFG</h2>
  <div class="key-idea">
    <h3>Definition</h3>
    <p>A context-free grammar is a 4-tuple <strong>G = (V, T, P, S)</strong> where:</p>
  </div>
  <div class="two-col">
    <div>
      <table style="width:100%;">
        <tr><th>Component</th><th>Description</th></tr>
        <tr><td><strong>V</strong></td><td>A finite set of <em>variables</em> (non-terminals)</td></tr>
        <tr><td><strong>T</strong></td><td>A finite set of <em>terminals</em> (the alphabet)</td></tr>
        <tr><td><strong>P</strong></td><td>A finite set of <em>productions</em> of the form A &rarr; w, where A &isin; V and w &isin; (V &cup; T)*</td></tr>
        <tr><td><strong>S</strong></td><td>The <em>start symbol</em>, S &isin; V</td></tr>
      </table>
      <div class="warning">
        <h3>Why "Context-Free"?</h3>
        <p>Every production has a <strong>single variable</strong> on the left side: A &rarr; w. The variable A can be replaced <strong>regardless of context</strong> (what's around it). In context-<em>sensitive</em> grammars, the surrounding symbols matter.</p>
      </div>
    </div>
    <div>
      <h3>Example: { a<sup>n</sup>b<sup>n</sup> | n &ge; 0 }</h3>
      <div class="diagram">
G = (V, T, P, S)

V = { S }
T = { a, b }
P = { S &rarr; aSb,
      S &rarr; &epsilon;   }
Start = S
      </div>
      <p>Let's trace how this generates <strong>aabb</strong>:</p>
      <div class="diagram small">
S  ==>  aSb        (used S &rarr; aSb)
   ==>  aaSbb      (used S &rarr; aSb)
   ==>  aa&epsilon;bb     (used S &rarr; &epsilon;)
   =    aabb
      </div>
      <p>The recursion in S &rarr; aSb "wraps" matching a's and b's around each other. That's the power regular languages don't have!</p>
    </div>
  </div>
  <div class="slide-number">5 / 21</div>
</div>

<!-- ==================== SLIDE 6: Interactive Derivation Stepper ==================== -->
<div class="slide" id="s6">
  <h2>Derivations: Leftmost vs. Rightmost</h2>
  <p>A <strong>derivation</strong> is a sequence of rule applications that transforms S into a string of terminals. Pick a mode and step through the derivation of <strong>"aabb"</strong>.</p>

  <div class="diagram small" style="margin-bottom:8px;">Grammar:  S &rarr; AB,  A &rarr; aA | a,  B &rarr; bB | b</div>

  <div class="cfg-der-container">
    <div class="cfg-der-controls">
      <button class="cfg-der-btn" id="cfg_derLeftBtn" onclick="cfg_derSelect('left')">Leftmost</button>
      <button class="cfg-der-btn" id="cfg_derRightBtn" onclick="cfg_derSelect('right')">Rightmost</button>
      <span style="color:#475569; margin:0 4px;">|</span>
      <button class="cfg-der-btn" id="cfg_derNextBtn" onclick="cfg_derNext()" disabled>Next Step</button>
      <button class="cfg-der-btn" id="cfg_derResetBtn" onclick="cfg_derReset()">Reset</button>
    </div>
    <div class="cfg-der-form" id="cfg_derCurrent">Current: <span style="color:#f59e0b;">S</span> &nbsp; <span style="color:#64748b;">(select a mode to begin)</span></div>
    <div id="cfg_derRule" style="color:#94a3b8; font-size:0.95em; margin-top:6px;"></div>
    <div class="cfg-der-log" id="cfg_derLog" style="display:none;"></div>
  </div>

  <div class="key-idea">
    <h3>Key Idea</h3>
    <p>For an <strong>unambiguous</strong> grammar, different derivation orders produce the <strong>same parse tree</strong>. The derivation order is just the order you visit the tree -- the tree itself is what matters.</p>
  </div>
  <div class="slide-number">6 / 21</div>
</div>

<!-- ==================== SLIDE 7: Arithmetic Grammar ==================== -->
<div class="slide" id="s7">
  <h2>Classic Example: Simple Arithmetic Grammar</h2>
  <div class="two-col">
    <div>
      <div class="diagram">
Grammar for Arithmetic:

  E &rarr; E + T  |  T
  T &rarr; T * F  |  F
  F &rarr; ( E )  |  id
      </div>
      <p><strong>E</strong> = Expression, <strong>T</strong> = Term, <strong>F</strong> = Factor</p>
      <p>This grammar encodes <strong>precedence</strong>:</p>
      <ul>
        <li><strong>*</strong> binds tighter than <strong>+</strong> (multiplication first)</li>
        <li>Both are <strong>left-associative</strong></li>
        <li>Parentheses override everything</li>
      </ul>
      <div class="analogy">
        <h3>Analogy</h3>
        <p>Think of E, T, F as layers of "binding strength." F is the tightest (atoms and parens). T groups multiplications. E groups additions. Like layers of an onion -- inner layers bind first.</p>
      </div>
    </div>
    <div>
      <h3>Derive: id + id * id</h3>
      <div class="diagram small">
Leftmost derivation:

  <span style="color:#f472b6">E</span>
  ==> <span style="color:#f472b6">E</span> + T            (E &rarr; E + T)
  ==> <span style="color:#f472b6">T</span> + T            (E &rarr; T)
  ==> <span style="color:#f472b6">F</span> + T            (T &rarr; F)
  ==> <span style="color:#f472b6">id</span> + T           (F &rarr; id)
  ==> id + <span style="color:#f472b6">T</span> * F      (T &rarr; T * F)
  ==> id + <span style="color:#f472b6">F</span> * F      (T &rarr; F)
  ==> id + <span style="color:#f472b6">id</span> * F     (F &rarr; id)
  ==> id + id * <span style="color:#f472b6">id</span>   (F &rarr; id)
      </div>
      <div class="key-idea">
        <h3>Notice!</h3>
        <p>The grammar <strong>forces</strong> "id * id" to be grouped under T, while "+" connects at the E level. This gives multiplication <strong>higher precedence</strong> than addition.</p>
      </div>
    </div>
  </div>
  <div class="slide-number">7 / 21</div>
</div>

<!-- ==================== SLIDE 8: Parse Trees ==================== -->
<div class="slide" id="s8">
  <h2>Parse Trees</h2>
  <p>A parse tree is a visual representation of a derivation. It shows the structure of how a string is generated.</p>
  <div class="two-col">
    <div>
      <h3>Rules for Parse Trees</h3>
      <ul>
        <li><strong>Root</strong> = start symbol S</li>
        <li><strong>Internal nodes</strong> = variables (non-terminals)</li>
        <li><strong>Leaves</strong> = terminals (read left-to-right = the string)</li>
        <li>Each internal node + its children = one production rule</li>
      </ul>
      <div class="analogy">
        <h3>Analogy: Family Tree</h3>
        <p>A parse tree is like a family tree for strings. The start symbol S is the ancestor. Each production rule is a "parent has these children." The terminals at the bottom are the youngest generation -- the actual string!</p>
      </div>
    </div>
    <div>
      <h3>Example: S &rarr; aSb | &epsilon;</h3>
      <p>Parse tree for <strong>aabb</strong>:</p>
      <div class="diagram">
           S
          /|\
         / | \
        a  S  b
          /|\
         / | \
        a  S  b
           |
           &epsilon;
      </div>
      <p>Reading the leaves left to right: <strong>a a &epsilon; b b = aabb</strong></p>
      <div class="key-idea">
        <h3>Key Idea</h3>
        <p>The tree structure shows the <strong>nesting</strong>. The outer S wraps a...b around the inner S. This is the recursive structure that DFAs cannot capture.</p>
      </div>
    </div>
  </div>
  <div class="slide-number">8 / 21</div>
</div>

<!-- ==================== SLIDE 9: Interactive Parse Tree Builder ==================== -->
<div class="slide" id="s9">
  <h2>Parse Tree Builder: id + id * id</h2>
  <p>Grammar: E &rarr; E+T | T, &nbsp; T &rarr; T*F | F, &nbsp; F &rarr; (E) | id. Watch the tree grow step by step.</p>

  <div class="cfg-pt-container">
    <div class="cfg-pt-controls">
      <button class="cfg-der-btn" id="cfg_ptNextBtn" onclick="cfg_ptNext()">Next Step</button>
      <button class="cfg-der-btn" id="cfg_ptAutoBtn" onclick="cfg_ptAuto()">Auto Play</button>
      <button class="cfg-der-btn" onclick="cfg_ptReset()">Reset</button>
      <span class="cfg-pt-step-label" id="cfg_ptStepLabel">Step 0 / 8</span>
    </div>
    <div class="cfg-pt-tree" id="cfg_ptTree"></div>
    <div class="cfg-der-log" id="cfg_ptLog" style="margin-top:12px;"></div>
  </div>

  <div class="key-idea">
    <h3>Why This Tree is Correct</h3>
    <p>The <strong>*</strong> operation sits <strong>deeper</strong> in the tree (under T), so it is evaluated <strong>first</strong>. The <strong>+</strong> is at the top (under E), so it is evaluated <strong>last</strong>. This gives us: id + (id * id).</p>
  </div>
  <div class="slide-number">9 / 21</div>
</div>

<!-- ==================== SLIDE 10: Ambiguity Explorer ==================== -->
<div class="slide" id="s10">
  <h2>Ambiguity Explorer: id + id * id</h2>
  <p>The ambiguous grammar <strong>E &rarr; E+E | E*E | (E) | id</strong> gives TWO parse trees!</p>

  <div class="cfg-amb-container">
    <div class="cfg-amb-controls">
      <button class="cfg-der-btn" id="cfg_ambBtn1" onclick="cfg_ambSelect(1)">Show Tree 1: (id+id)*id</button>
      <button class="cfg-der-btn" id="cfg_ambBtn2" onclick="cfg_ambSelect(2)">Show Tree 2: id+(id*id)</button>
      <button class="cfg-der-btn" id="cfg_ambBtnC" onclick="cfg_ambCompare()">Compare Both</button>
    </div>
    <div class="cfg-amb-compare" id="cfg_ambPanels">
      <div class="cfg-amb-panel" id="cfg_ambPanel1">
        <h3 style="color:#a5b4fc; margin-bottom:10px;">Tree 1: (id + id) * id</h3>
        <div class="diagram small" style="margin:8px 0; text-align:left;" id="cfg_ambTree1">
          E
        / | \
       E  *  E
      /|\    |
     E + E  id
     |   |
    id  id</div>
        <div class="cfg-amb-eval" id="cfg_ambEval1" style="color:#64748b;">
          Click "Show Tree 1" to evaluate
        </div>
      </div>
      <div class="cfg-amb-panel" id="cfg_ambPanel2">
        <h3 style="color:#a5b4fc; margin-bottom:10px;">Tree 2: id + (id * id)</h3>
        <div class="diagram small" style="margin:8px 0; text-align:left;" id="cfg_ambTree2">
          E
        / | \
       E  +  E
       |    /|\
      id   E * E
           |   |
          id  id</div>
        <div class="cfg-amb-eval" id="cfg_ambEval2" style="color:#64748b;">
          Click "Show Tree 2" to evaluate
        </div>
      </div>
    </div>
  </div>

  <div class="warning">
    <h3>The "Dangling Else" Problem</h3>
    <p>Another famous ambiguity: <code style="color:#fbbf24;">if E then if E then S else S</code> -- does "else" belong to the outer or inner "if"? Most languages resolve this by matching "else" to the <strong>nearest</strong> unmatched "if."</p>
  </div>
  <div class="slide-number">10 / 21</div>
</div>

<!-- ==================== SLIDE 11: Why Ambiguity Matters ==================== -->
<div class="slide" id="s11">
  <h2>Why Ambiguity Matters</h2>
  <p>Different parse trees mean <strong>different meanings</strong>. The tree defines the evaluation order!</p>
  <div class="two-col">
    <div>
      <h3>Parsing: 2 + 3 * 4</h3>
      <div class="diagram small">
  Tree A:  (2 + 3) * 4          Tree B:  2 + (3 * 4)

       E                              E
      /|\                            /|\
     E  *  E                        E  +  E
    /|\    |                        |    /|\
   E + E   4                        2  E * E
   |   |                               |   |
   2   3                               3   4

  = 5 * 4                          = 2 + 12
  = 20  <span style="color:#ef4444;">WRONG!</span>                    = 14  <span style="color:#22c55e;">CORRECT!</span>
      </div>
    </div>
    <div>
      <h3>Ambiguity = Multiple Interpretations</h3>
      <ul>
        <li>Compilers need <strong>exactly one</strong> parse tree per program</li>
        <li>If two trees exist, the compiler might pick the wrong one</li>
        <li>Different trees &rarr; different compiled code &rarr; different results</li>
      </ul>
      <div class="key-idea">
        <h3>Key Idea</h3>
        <p>Ambiguity is a property of the <strong>grammar</strong>, not the <strong>language</strong>. A language might have an ambiguous grammar but also an unambiguous one. The fix: <strong>rewrite the grammar</strong> to enforce the intended structure.</p>
      </div>
      <div class="warning">
        <h3>Caution</h3>
        <p>You cannot "test" for ambiguity in general -- it is <strong>undecidable</strong> whether an arbitrary CFG is ambiguous!</p>
      </div>
    </div>
  </div>
  <div class="slide-number">11 / 21</div>
</div>

<!-- ==================== SLIDE 12: Eliminating Ambiguity ==================== -->
<div class="slide" id="s12">
  <h2>Eliminating Ambiguity: See the Difference</h2>
  <p>Pick an expression to see how each grammar parses it (using id=2, id=3, id=4 left to right):</p>

  <div class="cfg-fix-container">
    <div class="cfg-fix-btns">
      <button class="cfg-fix-btn" onclick="cfg_fixSelect(0)">id + id * id</button>
      <button class="cfg-fix-btn" onclick="cfg_fixSelect(1)">id * id + id</button>
      <button class="cfg-fix-btn" onclick="cfg_fixSelect(2)">id + id + id</button>
    </div>

    <div id="cfg_fixDisplay">
      <div class="cfg-fix-prompt">&#8593; Click an expression above to compare parse trees</div>
    </div>
  </div>

  <div class="key-idea" style="margin-top:14px;">
    <h3>The Recipe for Eliminating Ambiguity</h3>
    <ol>
      <li>Create one variable per <strong>precedence level</strong></li>
      <li>Lowest precedence at the <strong>top</strong> (start symbol)</li>
      <li>Each level references the <strong>next tighter</strong> level</li>
      <li>Left-recursive rules &rarr; <strong>left-associative</strong> operators</li>
      <li>Right-recursive rules &rarr; <strong>right-associative</strong> operators</li>
    </ol>
  </div>
  <div class="slide-number">12 / 21</div>
</div>

<!-- ==================== SLIDE 13: Chomsky Normal Form ==================== -->
<div class="slide" id="s13">
  <h2>Chomsky Normal Form (CNF)</h2>
  <p>A restricted but equally powerful form of context-free grammars.</p>
  <div class="two-col">
    <div>
      <div class="key-idea">
        <h3>CNF Rules</h3>
        <p>Every production must be one of exactly two forms:</p>
        <ul>
          <li><strong>A &rarr; BC</strong> &nbsp; (two variables, no terminals)</li>
          <li><strong>A &rarr; a</strong> &nbsp;&nbsp;&nbsp; (exactly one terminal)</li>
        </ul>
        <p>Plus optionally: <strong>S &rarr; &epsilon;</strong> (only for the start symbol, only if &epsilon; is in the language)</p>
      </div>
      <div class="diagram">
  CNF:             NOT CNF:
  S &rarr; AB          S &rarr; AaB
  A &rarr; BC          A &rarr; BCD
  A &rarr; a           A &rarr; B
  B &rarr; b           A &rarr; aB
      </div>
    </div>
    <div>
      <h3>Why CNF Matters</h3>
      <ul>
        <li><strong>CYK Algorithm</strong>: A parsing algorithm that works in O(n&sup3;) time -- but it <em>requires</em> the grammar to be in CNF</li>
        <li><strong>Proofs</strong>: Many theoretical results are easier to prove when the grammar has a restricted form</li>
        <li><strong>Binary trees</strong>: CNF guarantees every parse tree is a <em>binary</em> tree (each internal node has exactly 2 children)</li>
      </ul>
      <div class="analogy">
        <h3>Analogy</h3>
        <p>CNF is like putting equations in "standard form" in algebra. It doesn't change what the equation describes -- it just reorganizes it into a form that's easier to work with systematically.</p>
      </div>
    </div>
  </div>
  <div class="slide-number">13 / 21</div>
</div>

<!-- ==================== SLIDE 14: Converting to CNF ==================== -->
<div class="slide" id="s14">
  <h2>Converting to CNF: The 4-Step Recipe</h2>
  <div class="diagram small">
  Step 1           Step 2           Step 3               Step 4
  Remove           Remove           Break long           Replace lone
  &epsilon;-prods        unit prods       productions          terminals
  A &rarr; &epsilon;           A &rarr; B            A &rarr; BCD             A &rarr; aB

     |                |                |                    |
     v                v                v                    v

  Propagate        Substitute       A &rarr; BX             A &rarr; T_a B
  nullable         chains           X &rarr; CD             T_a &rarr; a
  </div>
  <div class="two-col">
    <div>
      <h3>Step 1: Remove &epsilon;-Productions</h3>
      <ul>
        <li>Find all <strong>nullable</strong> variables (those that can derive &epsilon;)</li>
        <li>For each production with a nullable var on the right, add versions with and without it</li>
        <li>Delete all A &rarr; &epsilon; rules (except possibly S &rarr; &epsilon;)</li>
      </ul>
      <h3>Step 2: Remove Unit Productions</h3>
      <ul>
        <li>A <strong>unit production</strong> is A &rarr; B (single variable)</li>
        <li>If A &rarr; B and B &rarr; w, replace with A &rarr; w</li>
        <li>Repeat until no unit productions remain</li>
      </ul>
    </div>
    <div>
      <h3>Step 3: Fix Long Productions</h3>
      <ul>
        <li>If A &rarr; B<sub>1</sub>B<sub>2</sub>...B<sub>k</sub> where k > 2</li>
        <li>Break into pairs using new variables:</li>
        <li>A &rarr; B<sub>1</sub>C<sub>1</sub>, C<sub>1</sub> &rarr; B<sub>2</sub>C<sub>2</sub>, ..., C<sub>k-2</sub> &rarr; B<sub>k-1</sub>B<sub>k</sub></li>
      </ul>
      <h3>Step 4: Fix Terminal Mixing</h3>
      <ul>
        <li>If a production mixes terminals and variables like A &rarr; aB</li>
        <li>Replace each terminal <em>a</em> with a new variable T<sub>a</sub></li>
        <li>Add T<sub>a</sub> &rarr; a</li>
      </ul>
      <div class="warning">
        <h3>Order matters!</h3>
        <p>Do the steps in order (1 &rarr; 2 &rarr; 3 &rarr; 4). Each step can create situations the next step fixes.</p>
      </div>
    </div>
  </div>
  <div class="slide-number">14 / 21</div>
</div>

<!-- ==================== SLIDE 15: Interactive CNF Conversion ==================== -->
<div class="slide" id="s15">
  <h2>CNF Conversion: Step-Through</h2>
  <p>Walk through the CNF conversion of: <strong>S &rarr; ASB | &epsilon;, &nbsp; A &rarr; aAS | a, &nbsp; B &rarr; SbS | A | bb</strong></p>

  <div class="cfg-cnf-container">
    <div class="cfg-cnf-controls">
      <button class="cfg-der-btn" id="cfg_cnfNextBtn" onclick="cfg_cnfNext()">Next Step</button>
      <button class="cfg-der-btn" id="cfg_cnfAutoBtn" onclick="cfg_cnfAuto()">Auto Play</button>
      <button class="cfg-der-btn" onclick="cfg_cnfReset()">Reset</button>
      <span class="cfg-pt-step-label" id="cfg_cnfStepLabel">Step 0 / 9</span>
    </div>
    <div class="cfg-cnf-display" id="cfg_cnfDisplay">
      <div class="cfg-cnf-box" id="cfg_cnfBefore" style="white-space:pre-wrap;"></div>
      <div class="cfg-cnf-arrow">&rArr;</div>
      <div class="cfg-cnf-box" id="cfg_cnfAfter" style="white-space:pre-wrap;"></div>
    </div>
    <div id="cfg_cnfDesc" style="color:#94a3b8; margin-top:12px; font-size:0.95em;"></div>
    <div class="cfg-der-log" id="cfg_cnfLog" style="margin-top:12px;"></div>
  </div>

  <div class="key-idea">
    <h3>Result</h3>
    <p>Every production ends up as A &rarr; BC or A &rarr; a. The grammar is in CNF, ready for the CYK parsing algorithm!</p>
  </div>
  <div class="slide-number">15 / 21</div>
</div>

<!-- ==================== SLIDE 16: Context-Free Languages Properties ==================== -->
<div class="slide" id="s16">
  <h2>Properties of Context-Free Languages</h2>
  <div class="two-col">
    <div>
      <h3>Closure Properties</h3>
      <table>
        <tr><th>Operation</th><th>Closed?</th></tr>
        <tr><td>Union</td><td style="color:#22c55e;">YES</td></tr>
        <tr><td>Concatenation</td><td style="color:#22c55e;">YES</td></tr>
        <tr><td>Kleene Star</td><td style="color:#22c55e;">YES</td></tr>
        <tr><td>Intersection</td><td style="color:#ef4444;">NO</td></tr>
        <tr><td>Complement</td><td style="color:#ef4444;">NO</td></tr>
        <tr><td>Intersection with Regular</td><td style="color:#22c55e;">YES</td></tr>
      </table>
      <div class="key-idea">
        <h3>How to prove closure under union</h3>
        <p>Given CFGs G<sub>1</sub> (start S<sub>1</sub>) and G<sub>2</sub> (start S<sub>2</sub>), create a new grammar with start S and rule: <strong>S &rarr; S<sub>1</sub> | S<sub>2</sub></strong>. Done!</p>
      </div>
    </div>
    <div>
      <h3>NOT Closed Under Intersection</h3>
      <div class="diagram small">
L1 = { a^n b^n c^m  |  n,m &ge; 0 }
      (match a's and b's)     -- CFL!

L2 = { a^m b^n c^n  |  n,m &ge; 0 }
      (match b's and c's)     -- CFL!

L1 &cap; L2 = { a^n b^n c^n | n &ge; 0 }

This is NOT context-free!
(Provable by CFL pumping lemma)
      </div>
      <div class="warning">
        <h3>Consequence</h3>
        <p>Since CFLs are closed under union but NOT under complement, and L<sub>1</sub> &cap; L<sub>2</sub> = complement(complement(L<sub>1</sub>) &cup; complement(L<sub>2</sub>)), closure under complement would imply closure under intersection. So both must fail!</p>
      </div>
    </div>
  </div>
  <div class="slide-number">16 / 21</div>
</div>

<!-- ==================== SLIDE 17: Inherently Ambiguous ==================== -->
<div class="slide" id="s17">
  <h2>Inherently Ambiguous Languages</h2>
  <p>Some context-free languages are so "tangled" that <strong>every possible grammar</strong> for them is ambiguous.</p>
  <div class="two-col">
    <div>
      <div class="key-idea">
        <h3>Definition</h3>
        <p>A CFL L is <strong>inherently ambiguous</strong> if every CFG that generates L is ambiguous. There is no way to "fix" the grammar -- the ambiguity is built into the language itself.</p>
      </div>
      <h3>Classic Example</h3>
      <div class="diagram">
L = { a^i b^j c^k |
       i=j  OR  j=k }

In other words: either the
a's match the b's, OR the
b's match the c's (or both).
      </div>
    </div>
    <div>
      <h3>Why it's inherently ambiguous</h3>
      <div class="diagram small">
Consider: a^n b^n c^n

This string is in L because:
  - i=j=n (a's match b's)  YES
  - j=k=n (b's match c's)  YES

Any grammar must handle BOTH
reasons separately, creating
two parse trees for a^n b^n c^n.
      </div>
      <div class="analogy">
        <h3>Analogy</h3>
        <p>Imagine a language with two overlapping "reasons" a string can be included. When both reasons apply simultaneously, any grammar must use one path or the other -- giving two different trees. It's like a Venn diagram overlap that can't be un-overlapped.</p>
      </div>
      <div class="warning">
        <h3>Important Distinction</h3>
        <p>An ambiguous <strong>grammar</strong> might be fixable (rewrite it). An inherently ambiguous <strong>language</strong> cannot be fixed -- no grammar for it is unambiguous.</p>
      </div>
    </div>
  </div>
  <div class="slide-number">17 / 21</div>
</div>

<!-- ==================== SLIDE 18: CFG vs Regular ==================== -->
<div class="slide" id="s18">
  <h2>CFG vs. Regular: Head-to-Head Comparison</h2>
  <table style="width:100%; margin-top:10px;">
    <tr>
      <th style="width:25%;">Feature</th>
      <th style="width:37%;">Regular Languages</th>
      <th style="width:38%;">Context-Free Languages</th>
    </tr>
    <tr>
      <td><strong>Machine model</strong></td>
      <td>DFA / NFA</td>
      <td>Pushdown Automaton (PDA)</td>
    </tr>
    <tr>
      <td><strong>Memory</strong></td>
      <td>Finite (states only)</td>
      <td>Infinite stack</td>
    </tr>
    <tr>
      <td><strong>Described by</strong></td>
      <td>Regular expressions</td>
      <td>Context-free grammars</td>
    </tr>
    <tr>
      <td><strong>Closure</strong></td>
      <td>&cup;, &cap;, *, complement, concat</td>
      <td>&cup;, *, concat (NOT &cap;, complement)</td>
    </tr>
    <tr>
      <td><strong>Parsing</strong></td>
      <td>O(n) -- linear scan</td>
      <td>O(n&sup3;) CYK; O(n) for some subclasses</td>
    </tr>
    <tr>
      <td><strong>Pumping lemma</strong></td>
      <td>xy<sup>k</sup>z (one pump)</td>
      <td>uv<sup>k</sup>xy<sup>k</sup>z (two pumps)</td>
    </tr>
    <tr>
      <td><strong>Can do</strong></td>
      <td>a*b*, (ab)*, keyword matching</td>
      <td>a<sup>n</sup>b<sup>n</sup>, balanced parens, palindromes</td>
    </tr>
    <tr>
      <td><strong>Can't do</strong></td>
      <td>a<sup>n</sup>b<sup>n</sup>, matching, counting</td>
      <td>a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>, cross-serial dependencies</td>
    </tr>
    <tr class="highlight">
      <td><strong>Relationship</strong></td>
      <td colspan="2" style="text-align:center;">Every regular language is context-free, but NOT vice versa</td>
    </tr>
  </table>
  <div class="key-idea" style="margin-top:16px;">
    <h3>Key Idea</h3>
    <p>Regular languages are a <strong>proper subset</strong> of CFLs. A DFA is just a PDA that never uses its stack. So anything a DFA can do, a PDA can also do -- plus more.</p>
  </div>
  <div class="slide-number">18 / 21</div>
</div>

<!-- ==================== SLIDE 19: Applications ==================== -->
<div class="slide" id="s19">
  <h2>Real-World Applications of CFGs</h2>
  <div class="two-col">
    <div>
      <h3>Compilers & Programming Languages</h3>
      <div class="diagram small">
Source code:  if (x > 0) { y = x + 1; }

        STATEMENT
        /   |   \
      IF   COND  BLOCK
       |   / \     |
      if  x > 0  ASSIGN
                 / | \
                y  =  EXPR
                     / | \
                    x  +  1
      </div>
      <p>Every programming language has a CFG (the "syntax") that defines what valid programs look like. Compilers use <strong>parsers</strong> (LL, LR, LALR) to build parse trees from source code.</p>

      <h3>XML / HTML</h3>
      <p>Nested tags are inherently context-free:</p>
      <div class="diagram small">
&lt;div&gt;&lt;p&gt;Hello &lt;b&gt;world&lt;/b&gt;&lt;/p&gt;&lt;/div&gt;
      </div>
    </div>
    <div>
      <h3>Natural Language Processing</h3>
      <div class="diagram small">
         SENTENCE
          / \
        NP    VP
        |    / \
       Det  V   NP
        |   |   / \
      "the" |  Det  N
          "ate" |    |
              "a"  "fish"
      </div>
      <p>Linguists use CFGs to model the structure of human language sentences.</p>

      <h3>Other Applications</h3>
      <ul>
        <li><strong>JSON / YAML parsing</strong> -- nested data formats</li>
        <li><strong>Mathematical expressions</strong> -- calculators, CAS</li>
        <li><strong>DNA/RNA structure</strong> -- folding patterns modeled by stochastic CFGs</li>
        <li><strong>Protocol specification</strong> -- BNF grammars in RFCs</li>
      </ul>
      <div class="analogy">
        <h3>Analogy</h3>
        <p>CFGs are the <strong>blueprints</strong> of structured languages. Wherever you see nesting, hierarchy, or recursive structure, there's likely a CFG underneath.</p>
      </div>
    </div>
  </div>
  <div class="slide-number">19 / 21</div>
</div>

<!-- ==================== SLIDE 20: Summary & Cheat Sheet ==================== -->
<div class="slide" id="s20">
  <h2>Summary & Cheat Sheet</h2>
  <div class="two-col">
    <div>
      <h3>The Big Ideas</h3>
      <div class="diagram small">
  CFG = (V, T, P, S)
  =====================
  V = variables       (non-terminals)
  T = terminals       (alphabet)
  P = productions     (rewrite rules)
  S = start symbol

  "Context-free" means:
   Left side of every rule is a
   SINGLE variable. No context needed.

  Power:  Regular  &sub;  Context-Free
  Machine: DFA     &sub;  PDA (+ stack)
      </div>
      <h3>What to Remember</h3>
      <ul>
        <li>CFGs can express <strong>nesting</strong> and <strong>matching</strong></li>
        <li><strong>Parse trees</strong> show derivation structure</li>
        <li><strong>Ambiguity</strong> = multiple parse trees for one string</li>
        <li><strong>CNF</strong>: A &rarr; BC | a (useful for CYK parsing)</li>
        <li>Closed under &cup;, concat, * but <strong>NOT</strong> &cap; or complement</li>
      </ul>
    </div>
    <div>
      <h3>Common Grammar Patterns</h3>
      <div class="diagram small">
a^n b^n:         S &rarr; aSb | &epsilon;
palindromes:     S &rarr; aSa | bSb | a | b | &epsilon;
balanced parens: S &rarr; SS | (S) | &epsilon;
arithmetic:      E &rarr; E+T | T
                 T &rarr; T*F | F
                 F &rarr; (E) | id
      </div>
      <h3>CNF Conversion Steps</h3>
      <div class="diagram small">
1. Remove &epsilon;-productions  (propagate nullables)
2. Remove unit productions  (substitute chains)
3. Break long productions   (A&rarr;BCD ==> A&rarr;BX, X&rarr;CD)
4. Fix terminal mixing      (A&rarr;aB ==> A&rarr;T_aB, T_a&rarr;a)
      </div>
      <div class="key-idea">
        <h3>Coming Next</h3>
        <p>Pushdown Automata (PDA) -- the machine model equivalent of CFGs. Think of it as an NFA with a stack. We will prove that PDAs and CFGs recognize exactly the same class of languages.</p>
      </div>
    </div>
  </div>
  <div class="slide-number">20 / 21</div>
</div>

<!-- ==================== SLIDE 21: Challenge Quiz ==================== -->
<div class="slide" id="s21">
  <h2>Challenge Quiz: Test Your CFG Knowledge</h2>
  <p>Answer 3 randomly selected questions to test your understanding of context-free grammars.</p>

  <div class="cfg-quiz-container" id="cfg_quizBox">
    <div class="cfg-quiz-progress" id="cfg_quizProgress"></div>
    <div class="cfg-quiz-question" id="cfg_quizQuestion"></div>
    <div class="cfg-quiz-options" id="cfg_quizOptions"></div>
    <div class="cfg-quiz-explanation" id="cfg_quizExplanation"></div>
    <div class="cfg-quiz-score" id="cfg_quizScore"></div>
  </div>

  <div style="text-align:center; margin-top:16px;">
    <button class="cfg-der-btn" onclick="cfg_q1Init()" style="font-size:1.05em; padding:10px 24px;">Restart Quiz</button>
  </div>
  <div class="slide-number">21 / 21</div>
</div>

<!-- Navigation -->
<div class="nav">
  <button id="prevBtn" onclick="changeSlide(-1)">&larr; Prev</button>
  <button id="nextBtn" onclick="changeSlide(1)">Next &rarr;</button>
</div>

<script>
const totalSlides = 21;
let current = 1;
function showSlide(n) {
  document.querySelectorAll('.slide').forEach(s => s.classList.remove('active'));
  const slide = document.getElementById('s' + n);
  if (slide) { slide.classList.add('active'); slide.classList.add('fade-in'); }
  document.getElementById('prevBtn').disabled = (n === 1);
  document.getElementById('nextBtn').disabled = (n === totalSlides);
  document.getElementById('progress').style.width = ((n / totalSlides) * 100) + '%';
}
function changeSlide(delta) {
  const next = current + delta;
  if (next >= 1 && next <= totalSlides) { current = next; showSlide(current); }
}
document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowRight' || e.key === 'ArrowDown' || e.key === ' ') { e.preventDefault(); changeSlide(1); }
  else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') { e.preventDefault(); changeSlide(-1); }
  else if (e.key === 's' || e.key === 'S') {
    const slide = document.getElementById('s' + current);
    const steps = slide.querySelectorAll('.step:not(.revealed)');
    if (steps.length > 0) steps[0].classList.add('revealed');
  }
});
/* ============================================================
   Slide 12: Interactive Ambiguity Elimination Playground
   ============================================================ */
const cfg_fixData = [
  {
    expr: "id + id * id",
    ambLabel: "\u26a0 TWO possible parse trees!",
    treeA: {
      title: "Tree A: groups + first",
      art:
"       E\n" +
"     / | \\\n" +
"    E  *  E\n" +
"  / | \\   |\n" +
" E  +  E  id\n" +
" |     |  (4)\n" +
"id    id\n" +
"(2)   (3)",
      interp: "= (id+id)*id = (2+3)*4 = 20",
      verdict: "\u2717 WRONG precedence",
      cls: "wrong"
    },
    treeB: {
      title: "Tree B: groups * first",
      art:
"    E\n" +
"  / | \\\n" +
" E  +  E\n" +
" |   / | \\\n" +
"id  E  *  E\n" +
"(2) |     |\n" +
"   id    id\n" +
"   (3)   (4)",
      interp: "= id+(id*id) = 2+(3*4) = 14",
      verdict: "\u2713 Correct precedence",
      cls: "correct"
    },
    unambTree: {
      art:
"        E\n" +
"      / | \\\n" +
"     E  +  T\n" +
"     |    /|\\\n" +
"     T  T  *  F\n" +
"     |  |     |\n" +
"     F  F    id\n" +
"     |  |    (4)\n" +
"    id  id\n" +
"    (2) (3)",
      interp: "= id+(id*id) = 2+(3*4) = 14",
      verdict: "\u2713 Only one tree \u2014 correct!",
      cls: "correct"
    }
  },
  {
    expr: "id * id + id",
    ambLabel: "\u26a0 TWO possible parse trees!",
    treeA: {
      title: "Tree A: groups * first",
      art:
"    E\n" +
"  / | \\\n" +
" E  +  E\n" +
"/|\\    |\n" +
"E * E  id\n" +
"|   |  (4)\n" +
"id  id\n" +
"(2) (3)",
      interp: "= (id*id)+id = (2*3)+4 = 10",
      verdict: "\u2713 Correct precedence",
      cls: "correct"
    },
    treeB: {
      title: "Tree B: groups + first",
      art:
"       E\n" +
"     / | \\\n" +
"    E  *  E\n" +
"    |    /|\\\n" +
"   id  E + E\n" +
"   (2) |   |\n" +
"      id  id\n" +
"      (3) (4)",
      interp: "= id*(id+id) = 2*(3+4) = 14",
      verdict: "\u2717 WRONG precedence",
      cls: "wrong"
    },
    unambTree: {
      art:
"      E\n" +
"    / | \\\n" +
"   E  +  T\n" +
"   |     |\n" +
"   T     F\n" +
"  /|\\    |\n" +
" T * F  id\n" +
" |   |  (4)\n" +
" F  id\n" +
" |  (3)\n" +
"id\n" +
"(2)",
      interp: "= (id*id)+id = (2*3)+4 = 10",
      verdict: "\u2713 Only one tree \u2014 correct!",
      cls: "correct"
    }
  },
  {
    expr: "id + id + id",
    ambLabel: "\u26a0 TWO possible parse trees!",
    treeA: {
      title: "Tree A: left-associative",
      art:
"      E\n" +
"    / | \\\n" +
"   E  +  E\n" +
" / | \\   |\n" +
"E  +  E  id\n" +
"|     |  (4)\n" +
"id   id\n" +
"(2)  (3)",
      interp: "= (id+id)+id = (2+3)+4 = 9",
      verdict: "\u2713 Left-associative",
      cls: "correct"
    },
    treeB: {
      title: "Tree B: right-associative",
      art:
"    E\n" +
"  / | \\\n" +
" E  +  E\n" +
" |   / | \\\n" +
"id  E  +  E\n" +
"(2) |     |\n" +
"   id    id\n" +
"   (3)   (4)",
      interp: "= id+(id+id) = 2+(3+4) = 9",
      verdict: "\u2713 Right-associative",
      cls: "correct"
    },
    note: "Same value for +, but different structure! For subtraction (5\u22123\u22121), left-assoc gives 1, right-assoc gives 3. Structure matters!",
    unambTree: {
      art:
"       E\n" +
"     / | \\\n" +
"    E  +  T\n" +
"  / | \\   |\n" +
" E  +  T  F\n" +
" |     |  |\n" +
" T     F  id\n" +
" |     |  (4)\n" +
" F    id\n" +
" |    (3)\n" +
"id\n" +
"(2)",
      interp: "= (id+id)+id = (2+3)+4 = 9",
      verdict: "\u2713 Only one tree \u2014 left-associative (forced by left recursion)",
      cls: "correct"
    }
  }
];

let cfg_fixCurrent = -1;

function cfg_fixSelect(idx) {
  cfg_fixCurrent = idx;
  var d = cfg_fixData[idx];
  // Update buttons
  var btns = document.querySelectorAll('.cfg-fix-btn');
  btns.forEach(function(b, i) { b.classList.toggle('active', i === idx); });

  var html = '<div class="cfg-fix-compare">';

  // Ambiguous panel
  html += '<div class="cfg-fix-panel ambiguous">';
  html += '<h4 style="color:#fbbf24;">\u26a0 Ambiguous Grammar</h4>';
  html += '<div class="cfg-fix-grammar">E \u2192 E+E | E*E | (E) | id</div>';
  html += '<div class="cfg-fix-label warn">' + cfg_fixEsc(d.ambLabel) + '</div>';
  html += '<div class="cfg-fix-trees">';
  // Tree A
  html += '<div>';
  html += '<div style="color:#94a3b8;font-size:0.82em;margin-bottom:4px;font-weight:600;">' + cfg_fixEsc(d.treeA.title) + '</div>';
  html += '<div class="cfg-fix-tree ' + d.treeA.cls + '">' + cfg_fixEsc(d.treeA.art) + '</div>';
  html += '<div class="cfg-fix-eval ' + d.treeA.cls + '">' + cfg_fixEsc(d.treeA.interp) + '<br>' + cfg_fixEsc(d.treeA.verdict) + '</div>';
  html += '</div>';
  // Tree B
  html += '<div>';
  html += '<div style="color:#94a3b8;font-size:0.82em;margin-bottom:4px;font-weight:600;">' + cfg_fixEsc(d.treeB.title) + '</div>';
  html += '<div class="cfg-fix-tree ' + d.treeB.cls + '">' + cfg_fixEsc(d.treeB.art) + '</div>';
  html += '<div class="cfg-fix-eval ' + d.treeB.cls + '">' + cfg_fixEsc(d.treeB.interp) + '<br>' + cfg_fixEsc(d.treeB.verdict) + '</div>';
  html += '</div>';
  html += '</div>'; // end trees
  if (d.note) {
    html += '<div style="margin-top:10px;padding:8px 12px;background:rgba(245,158,11,0.1);border-radius:6px;color:#fbbf24;font-size:0.88em;">\ud83d\udca1 ' + cfg_fixEsc(d.note) + '</div>';
  }
  html += '</div>'; // end ambiguous panel

  // Unambiguous panel
  html += '<div class="cfg-fix-panel unambiguous">';
  html += '<h4 style="color:#34d399;">\u2713 Unambiguous Grammar</h4>';
  html += '<div class="cfg-fix-grammar">E \u2192 E+T | T<br>T \u2192 T*F | F<br>F \u2192 (E) | id</div>';
  html += '<div class="cfg-fix-label ok">Only ONE parse tree:</div>';
  html += '<div class="cfg-fix-single-tree">' + cfg_fixEsc(d.unambTree.art) + '</div>';
  html += '<div class="cfg-fix-eval correct">' + cfg_fixEsc(d.unambTree.interp) + '<br>' + cfg_fixEsc(d.unambTree.verdict) + '</div>';
  html += '</div>'; // end unambiguous panel

  html += '</div>'; // end compare

  document.getElementById('cfg_fixDisplay').innerHTML = html;
}

function cfg_fixEsc(s) {
  var div = document.createElement('div');
  div.textContent = s;
  return div.innerHTML;
}

showSlide(1);

/* ============================================================
   Enhancement 1: Slide 6  Interactive Derivation Stepper
   ============================================================ */
var cfg_derMode = null;
var cfg_derStep = 0;
var cfg_derSteps = [];

var cfg_derLeftSteps = [
  { form: 'S', hl: '<span class="hl-left">S</span>', rule: null, desc: 'Start' },
  { form: 'AB', hl: '<span class="hl-left">A</span>B', rule: 'S \u2192 AB', desc: 'Replace S' },
  { form: 'aAB', hl: '<span class="hl-left">a</span><span class="hl-left">A</span>B', rule: 'A \u2192 aA', desc: 'Replace leftmost A' },
  { form: 'aaB', hl: 'a<span class="hl-left">a</span>B', rule: 'A \u2192 a', desc: 'Replace leftmost A' },
  { form: 'aabB', hl: 'aa<span class="hl-left">b</span><span class="hl-left">B</span>', rule: 'B \u2192 bB', desc: 'Replace leftmost B' },
  { form: 'aabb', hl: 'aab<span class="hl-left">b</span>', rule: 'B \u2192 b', desc: 'Replace leftmost B' }
];

var cfg_derRightSteps = [
  { form: 'S', hl: '<span class="hl-right">S</span>', rule: null, desc: 'Start' },
  { form: 'AB', hl: 'A<span class="hl-right">B</span>', rule: 'S \u2192 AB', desc: 'Replace S' },
  { form: 'AbB', hl: 'A<span class="hl-right">b</span><span class="hl-right">B</span>', rule: 'B \u2192 bB', desc: 'Replace rightmost B' },
  { form: 'Abb', hl: 'A<span class="hl-right">b</span>b', rule: 'B \u2192 b', desc: 'Replace rightmost B' },
  { form: 'aAbb', hl: '<span class="hl-right">a</span><span class="hl-right">A</span>bb', rule: 'A \u2192 aA', desc: 'Replace rightmost A' },
  { form: 'aabb', hl: '<span class="hl-right">a</span>abb', rule: 'A \u2192 a', desc: 'Replace rightmost A' }
];

function cfg_derSelect(mode) {
  cfg_derMode = mode;
  cfg_derStep = 0;
  cfg_derSteps = mode === 'left' ? cfg_derLeftSteps : cfg_derRightSteps;
  document.getElementById('cfg_derLeftBtn').classList.toggle('active', mode === 'left');
  document.getElementById('cfg_derRightBtn').classList.toggle('active', mode === 'right');
  document.getElementById('cfg_derNextBtn').disabled = false;
  document.getElementById('cfg_derLog').style.display = 'block';
  document.getElementById('cfg_derLog').innerHTML = '';
  cfg_derRender();
}

function cfg_derNext() {
  if (!cfg_derMode || cfg_derStep >= cfg_derSteps.length - 1) return;
  cfg_derStep++;
  cfg_derRender();
  if (cfg_derStep >= cfg_derSteps.length - 1) {
    document.getElementById('cfg_derNextBtn').disabled = true;
  }
}

function cfg_derReset() {
  cfg_derMode = null;
  cfg_derStep = 0;
  cfg_derSteps = [];
  document.getElementById('cfg_derLeftBtn').classList.remove('active');
  document.getElementById('cfg_derRightBtn').classList.remove('active');
  document.getElementById('cfg_derNextBtn').disabled = true;
  document.getElementById('cfg_derCurrent').innerHTML = 'Current: <span style="color:#f59e0b;">S</span> &nbsp; <span style="color:#64748b;">(select a mode to begin)</span>';
  document.getElementById('cfg_derRule').textContent = '';
  document.getElementById('cfg_derLog').style.display = 'none';
  document.getElementById('cfg_derLog').innerHTML = '';
}

function cfg_derRender() {
  var s = cfg_derSteps[cfg_derStep];
  document.getElementById('cfg_derCurrent').innerHTML = 'Current: ' + s.hl;
  document.getElementById('cfg_derRule').textContent = s.rule ? 'Rule applied: ' + s.rule : '';
  var logEl = document.getElementById('cfg_derLog');
  var html = '';
  for (var i = 0; i <= cfg_derStep; i++) {
    var st = cfg_derSteps[i];
    var cls = i < cfg_derStep ? 'cfg-der-log-item done' : 'cfg-der-log-item current';
    var prefix = i < cfg_derStep ? '\u2713 ' : '\u2192 ';
    var ruleText = st.rule ? '  (' + st.rule + ')' : '';
    html += '<div class="' + cls + '">' + prefix + st.form + ruleText + '</div>';
  }
  logEl.innerHTML = html;
  logEl.scrollTop = logEl.scrollHeight;
}

/* ============================================================
   Enhancement 2: Slide 9  Interactive Parse Tree Builder
   ============================================================ */
var cfg_ptStep = 0;
var cfg_ptTimer = null;
var cfg_ptTotalSteps = 8;

/*
  Tree structure for id + id * id using E->E+T|T, T->T*F|F, F->(E)|id
  We build it using a div-based layout. Each step reveals nodes.

  Step 1: E (root)
  Step 2: E -> E + T  (left-E, +, right-T)
  Step 3: left-E -> T
  Step 4: left-T -> F
  Step 5: left-F -> id
  Step 6: right-T -> T * F  (mid-T, *, right-F)
  Step 7: mid-T -> F -> id
  Step 8: right-F -> id
*/

var cfg_ptStepDescs = [
  '',
  'E (root node)',
  'E \u2192 E + T',
  'E \u2192 T (left E becomes T)',
  'T \u2192 F (left branch)',
  'F \u2192 id (left leaf)',
  'T \u2192 T * F (right branch splits)',
  'T \u2192 F \u2192 id (middle leaf)',
  'F \u2192 id (right leaf)'
];

function cfg_ptBuildTree() {
  var tree = document.getElementById('cfg_ptTree');
  // Build a layered div-based tree
  tree.innerHTML = `
    <div style="display:flex;flex-direction:column;align-items:center;gap:2px;width:100%;">
      <!-- Row 0: E root -->
      <div style="display:flex;justify-content:center;width:100%;">
        <span class="cfg-pt-node variable" data-step="1" id="cfg_pt_E0">E</span>
      </div>
      <!-- Row 1: connectors -->
      <div style="color:#475569;font-family:monospace;font-size:0.8em;text-align:center;" data-step="2" class="cfg-pt-node" style="border:none;background:none;min-width:auto;">/ | \\</div>
      <!-- Row 1: E + T -->
      <div style="display:flex;justify-content:center;gap:40px;width:100%;">
        <span class="cfg-pt-node variable" data-step="2" id="cfg_pt_E1">E</span>
        <span class="cfg-pt-node operator" data-step="2" id="cfg_pt_plus">+</span>
        <span class="cfg-pt-node variable" data-step="2" id="cfg_pt_T0">T</span>
      </div>
      <!-- Row 2: connectors -->
      <div style="display:flex;justify-content:space-between;width:70%;padding:0 10px;">
        <span style="color:#475569;font-family:monospace;font-size:0.8em;" class="cfg-pt-node" data-step="3" style="border:none;background:none;">|</span>
        <span style="color:#475569;font-family:monospace;font-size:0.8em;" class="cfg-pt-node" data-step="6" style="border:none;background:none;">/ | \\</span>
      </div>
      <!-- Row 2: T  and  T * F -->
      <div style="display:flex;justify-content:center;gap:20px;width:100%;">
        <span class="cfg-pt-node variable" data-step="3" id="cfg_pt_T1" style="margin-right:40px;">T</span>
        <span class="cfg-pt-node variable" data-step="6" id="cfg_pt_T2">T</span>
        <span class="cfg-pt-node operator" data-step="6" id="cfg_pt_star">*</span>
        <span class="cfg-pt-node variable" data-step="6" id="cfg_pt_F2">F</span>
      </div>
      <!-- Row 3: connectors -->
      <div style="display:flex;justify-content:center;gap:80px;width:100%;">
        <span style="color:#475569;font-family:monospace;font-size:0.8em;" class="cfg-pt-node" data-step="4" style="border:none;background:none;">|</span>
        <span style="color:#475569;font-family:monospace;font-size:0.8em;" class="cfg-pt-node" data-step="7" style="border:none;background:none;">|</span>
        <span style="color:#475569;font-family:monospace;font-size:0.8em;" class="cfg-pt-node" data-step="8" style="border:none;background:none;">|</span>
      </div>
      <!-- Row 3: F  and  F  and id -->
      <div style="display:flex;justify-content:center;gap:20px;width:100%;">
        <span class="cfg-pt-node variable" data-step="4" id="cfg_pt_F0" style="margin-right:40px;">F</span>
        <span class="cfg-pt-node variable" data-step="7" id="cfg_pt_F1">F</span>
        <span style="width:36px;display:inline-block;" data-step="0"></span>
        <span class="cfg-pt-node terminal" data-step="8" id="cfg_pt_id2">id</span>
      </div>
      <!-- Row 4: connectors -->
      <div style="display:flex;justify-content:center;gap:80px;width:100%;">
        <span style="color:#475569;font-family:monospace;font-size:0.8em;" class="cfg-pt-node" data-step="5" style="border:none;background:none;">|</span>
        <span style="color:#475569;font-family:monospace;font-size:0.8em;" class="cfg-pt-node" data-step="7" style="border:none;background:none;">|</span>
      </div>
      <!-- Row 4: id  and  id -->
      <div style="display:flex;justify-content:center;gap:40px;width:100%;">
        <span class="cfg-pt-node terminal" data-step="5" id="cfg_pt_id0" style="margin-right:20px;">id</span>
        <span class="cfg-pt-node terminal" data-step="7" id="cfg_pt_id1">id</span>
      </div>
    </div>
  `;
}

function cfg_ptRevealStep(step) {
  var nodes = document.getElementById('cfg_ptTree').querySelectorAll('[data-step]');
  nodes.forEach(function(n) {
    var s = parseInt(n.getAttribute('data-step'));
    if (s > 0 && s <= step) {
      n.classList.add('visible');
    }
    // Highlight most recent step
    n.classList.remove('highlight');
    if (s === step) n.classList.add('highlight');
  });
}

function cfg_ptUpdateLog() {
  var logEl = document.getElementById('cfg_ptLog');
  var html = '';
  for (var i = 1; i <= cfg_ptStep; i++) {
    var cls = i < cfg_ptStep ? 'cfg-der-log-item done' : 'cfg-der-log-item current';
    var prefix = i < cfg_ptStep ? '\u2713 ' : '\u2192 ';
    html += '<div class="' + cls + '">' + prefix + cfg_ptStepDescs[i] + '</div>';
  }
  logEl.innerHTML = html;
  logEl.scrollTop = logEl.scrollHeight;
}

function cfg_ptNext() {
  if (cfg_ptStep >= cfg_ptTotalSteps) return;
  cfg_ptStep++;
  cfg_ptRevealStep(cfg_ptStep);
  cfg_ptUpdateLog();
  document.getElementById('cfg_ptStepLabel').textContent = 'Step ' + cfg_ptStep + ' / ' + cfg_ptTotalSteps;
  if (cfg_ptStep >= cfg_ptTotalSteps) {
    document.getElementById('cfg_ptNextBtn').disabled = true;
  }
}

function cfg_ptAuto() {
  if (cfg_ptTimer) { clearInterval(cfg_ptTimer); cfg_ptTimer = null; document.getElementById('cfg_ptAutoBtn').textContent = 'Auto Play'; return; }
  document.getElementById('cfg_ptAutoBtn').textContent = 'Pause';
  cfg_ptTimer = setInterval(function() {
    if (cfg_ptStep >= cfg_ptTotalSteps) { clearInterval(cfg_ptTimer); cfg_ptTimer = null; document.getElementById('cfg_ptAutoBtn').textContent = 'Auto Play'; return; }
    cfg_ptNext();
  }, 900);
}

function cfg_ptReset() {
  if (cfg_ptTimer) { clearInterval(cfg_ptTimer); cfg_ptTimer = null; }
  cfg_ptStep = 0;
  document.getElementById('cfg_ptAutoBtn').textContent = 'Auto Play';
  document.getElementById('cfg_ptNextBtn').disabled = false;
  document.getElementById('cfg_ptStepLabel').textContent = 'Step 0 / ' + cfg_ptTotalSteps;
  document.getElementById('cfg_ptLog').innerHTML = '';
  cfg_ptBuildTree();
}

// Initialize tree on load
cfg_ptBuildTree();

/* ============================================================
   Enhancement 3: Slide 10  Ambiguity Explorer
   ============================================================ */
var cfg_ambState = 0; // 0=none, 1=tree1, 2=tree2, 3=compare

function cfg_ambSelect(tree) {
  cfg_ambState = tree;
  var p1 = document.getElementById('cfg_ambPanel1');
  var p2 = document.getElementById('cfg_ambPanel2');
  p1.className = 'cfg-amb-panel';
  p2.className = 'cfg-amb-panel';
  document.getElementById('cfg_ambBtn1').classList.remove('active');
  document.getElementById('cfg_ambBtn2').classList.remove('active');
  document.getElementById('cfg_ambBtnC').classList.remove('active');

  if (tree === 1) {
    p1.classList.add('active');
    p1.classList.add('wrong');
    document.getElementById('cfg_ambBtn1').classList.add('active');
    document.getElementById('cfg_ambEval1').innerHTML = '<span style="color:#fbbf24;">Eval: (2+3)*4 = 5*4 = <strong>20</strong></span><br><span style="color:#ef4444;">&#10007; Wrong precedence!</span>';
    document.getElementById('cfg_ambEval2').innerHTML = '<span style="color:#64748b;">Click "Show Tree 2" to evaluate</span>';
  } else if (tree === 2) {
    p2.classList.add('active');
    p2.classList.add('correct');
    document.getElementById('cfg_ambBtn2').classList.add('active');
    document.getElementById('cfg_ambEval1').innerHTML = '<span style="color:#64748b;">Click "Show Tree 1" to evaluate</span>';
    document.getElementById('cfg_ambEval2').innerHTML = '<span style="color:#fbbf24;">Eval: 2+(3*4) = 2+12 = <strong>14</strong></span><br><span style="color:#22c55e;">&#10003; Correct!</span>';
  }
}

function cfg_ambCompare() {
  cfg_ambState = 3;
  var p1 = document.getElementById('cfg_ambPanel1');
  var p2 = document.getElementById('cfg_ambPanel2');
  p1.className = 'cfg-amb-panel active wrong';
  p2.className = 'cfg-amb-panel active correct';
  document.getElementById('cfg_ambBtn1').classList.remove('active');
  document.getElementById('cfg_ambBtn2').classList.remove('active');
  document.getElementById('cfg_ambBtnC').classList.add('active');
  document.getElementById('cfg_ambEval1').innerHTML = '<span style="color:#fbbf24;">Eval: (2+3)*4 = <strong>20</strong></span><br><span style="color:#ef4444;">&#10007; Wrong! Root op is *</span>';
  document.getElementById('cfg_ambEval2').innerHTML = '<span style="color:#fbbf24;">Eval: 2+(3*4) = <strong>14</strong></span><br><span style="color:#22c55e;">&#10003; Correct! Root op is +</span>';
}

/* ============================================================
   Enhancement 4: Slide 15  CNF Conversion Step-Through
   ============================================================ */
var cfg_cnfStep = 0;
var cfg_cnfTimer = null;
var cfg_cnfTotalSteps = 9;

var cfg_cnfData = [
  {
    title: 'Original Grammar',
    before: 'S \u2192 ASB | \u03b5\nA \u2192 aAS | a\nB \u2192 SbS | A | bb',
    after: '(starting point)',
    desc: 'This is the grammar we want to convert to Chomsky Normal Form.'
  },
  {
    title: 'Step 1a: Find nullable variables',
    before: 'S \u2192 ASB | \u03b5\nA \u2192 aAS | a\nB \u2192 SbS | A | bb',
    after: 'Nullable: { S }\n\nS \u2192 \u03b5 directly,\nso S is nullable.',
    desc: 'A variable is nullable if it can derive \u03b5. Here S \u2192 \u03b5 directly.'
  },
  {
    title: 'Step 1b: Add nullable variants',
    before: 'S \u2192 ASB | \u03b5\nA \u2192 aAS | a\nB \u2192 SbS | A | bb',
    after: 'S \u2192 ASB | AB | AS | SB\n     | A | B | S\nA \u2192 aAS | aA | aS | a\nB \u2192 SbS | bS | Sb | b\n     | A | bb',
    desc: 'For each production with nullable S on the right, add versions with and without S.'
  },
  {
    title: 'Step 1c: Remove \u03b5-productions',
    before: 'S \u2192 ASB | AB | AS | SB\n     | A | B | S | \u03b5\nA \u2192 aAS | aA | aS | a\nB \u2192 SbS | bS | Sb | b\n     | A | bb',
    after: 'S\u2080 \u2192 S | \u03b5\nS \u2192 ASB | AB | AS | SB\n     | A | B | S\nA \u2192 aAS | aA | aS | a\nB \u2192 SbS | bS | Sb | b\n     | A | bb',
    desc: 'Remove S \u2192 \u03b5. Add new start S\u2080 \u2192 S | \u03b5 to preserve \u03b5 in the language.'
  },
  {
    title: 'Step 2a: Identify unit productions',
    before: 'Unit productions:\n\nS \u2192 A\nS \u2192 B\nS \u2192 S\nB \u2192 A',
    after: 'These must be\nremoved by\nsubstituting the\nright-hand side\nproductions.',
    desc: 'A unit production is A \u2192 B (single variable). We find four of them.'
  },
  {
    title: 'Step 2b: Substitute and remove',
    before: 'S \u2192 A  \u21d2  S gets A\'s prods\nS \u2192 B  \u21d2  S gets B\'s prods\nS \u2192 S  \u21d2  remove (trivial)\nB \u2192 A  \u21d2  B gets A\'s prods',
    after: 'S\u2080 \u2192 S | \u03b5\nS \u2192 ASB | AB | AS | SB\n     | aAS | aA | aS | a\n     | SbS | bS | Sb | b | bb\nA \u2192 aAS | aA | aS | a\nB \u2192 SbS | bS | Sb | b | bb\n     | aAS | aA | aS | a',
    desc: 'Replace each unit production by substituting the target\'s productions.'
  },
  {
    title: 'Step 3: Break long productions',
    before: 'S \u2192 ASB   (length 3)\nS \u2192 aAS   (length 3)\nS \u2192 SbS   (length 3)\n... and similar in A, B',
    after: 'S \u2192 AC\u2081,  C\u2081 \u2192 SB\nS \u2192 T\u2090C\u2082, C\u2082 \u2192 AS\nS \u2192 SC\u2083,  C\u2083 \u2192 T\u2087S\n(similar for A and B)',
    desc: 'Break any production with >2 symbols on the right into pairs using new variables.'
  },
  {
    title: 'Step 4: Fix terminal mixing',
    before: 'S \u2192 aA  (terminal + var)\nS \u2192 aS  (terminal + var)\nS \u2192 bS  (terminal + var)\nS \u2192 bb  (two terminals)',
    after: 'S \u2192 T\u2090A\nS \u2192 T\u2090S\nS \u2192 T\u2087S\nS \u2192 T\u2087T\u2087\n\nAdd: T\u2090 \u2192 a,  T\u2087 \u2192 b',
    desc: 'Replace bare terminals in multi-symbol productions with new variables T\u2090, T\u2087.'
  },
  {
    title: 'Done! Grammar is in CNF',
    before: 'Every production is now:\n\nA \u2192 BC  (two variables)\n  or\nA \u2192 a   (one terminal)\n  or\nS\u2080 \u2192 \u03b5  (start only)',
    after: 'Ready for CYK\nparsing algorithm!\n\nO(n\u00b3) parsing\nguaranteed.',
    desc: 'The grammar is now in Chomsky Normal Form. Every parse tree is a binary tree.'
  }
];

function cfg_cnfNext() {
  if (cfg_cnfStep >= cfg_cnfTotalSteps) return;
  cfg_cnfStep++;
  cfg_cnfRender();
  if (cfg_cnfStep >= cfg_cnfTotalSteps) {
    document.getElementById('cfg_cnfNextBtn').disabled = true;
  }
}

function cfg_cnfAuto() {
  if (cfg_cnfTimer) { clearInterval(cfg_cnfTimer); cfg_cnfTimer = null; document.getElementById('cfg_cnfAutoBtn').textContent = 'Auto Play'; return; }
  document.getElementById('cfg_cnfAutoBtn').textContent = 'Pause';
  cfg_cnfTimer = setInterval(function() {
    if (cfg_cnfStep >= cfg_cnfTotalSteps) { clearInterval(cfg_cnfTimer); cfg_cnfTimer = null; document.getElementById('cfg_cnfAutoBtn').textContent = 'Auto Play'; return; }
    cfg_cnfNext();
  }, 2000);
}

function cfg_cnfReset() {
  if (cfg_cnfTimer) { clearInterval(cfg_cnfTimer); cfg_cnfTimer = null; }
  cfg_cnfStep = 0;
  document.getElementById('cfg_cnfAutoBtn').textContent = 'Auto Play';
  document.getElementById('cfg_cnfNextBtn').disabled = false;
  document.getElementById('cfg_cnfStepLabel').textContent = 'Step 0 / ' + cfg_cnfTotalSteps;
  document.getElementById('cfg_cnfBefore').textContent = 'Press "Next Step" to begin the CNF conversion.';
  document.getElementById('cfg_cnfAfter').textContent = '';
  document.getElementById('cfg_cnfDesc').textContent = '';
  document.getElementById('cfg_cnfLog').innerHTML = '';
}

function cfg_cnfRender() {
  var d = cfg_cnfData[cfg_cnfStep - 1];
  document.getElementById('cfg_cnfBefore').textContent = d.before;
  document.getElementById('cfg_cnfAfter').textContent = d.after;
  document.getElementById('cfg_cnfDesc').textContent = d.desc;
  document.getElementById('cfg_cnfStepLabel').textContent = 'Step ' + cfg_cnfStep + ' / ' + cfg_cnfTotalSteps;

  var logEl = document.getElementById('cfg_cnfLog');
  var html = '';
  for (var i = 0; i < cfg_cnfStep; i++) {
    var cls = i < cfg_cnfStep - 1 ? 'cfg-der-log-item done' : 'cfg-der-log-item current';
    var prefix = i < cfg_cnfStep - 1 ? '\u2713 ' : '\u2192 ';
    html += '<div class="' + cls + '">' + prefix + cfg_cnfData[i].title + '</div>';
  }
  logEl.innerHTML = html;
  logEl.scrollTop = logEl.scrollHeight;
}

// Initialize CNF display
document.getElementById('cfg_cnfBefore').textContent = 'Press "Next Step" to begin the CNF conversion.';

/* ============================================================
   Enhancement 5: Slide 21  Challenge Quiz
   ============================================================ */
var cfg_quizPool = [
  {
    q: 'What language does S \u2192 aSb | \u03b5 generate?',
    options: ['{a\u207fb\u207f | n\u22650}', '{a\u207fb\u1d50 | n,m\u22650}'],
    correct: 0,
    explanation: 'The recursion wraps matching a\'s and b\'s. Each application of S \u2192 aSb adds one a on the left and one b on the right, so a\'s and b\'s are always equal.'
  },
  {
    q: 'Is the grammar E \u2192 E+E | E*E | id ambiguous?',
    options: ['Yes', 'No'],
    correct: 0,
    explanation: 'id+id*id has two different parse trees: one grouping (id+id)*id and another grouping id+(id*id). Two distinct parse trees means the grammar is ambiguous.'
  },
  {
    q: 'Is A \u2192 BC a valid CNF production?',
    options: ['Yes', 'No'],
    correct: 0,
    explanation: 'CNF allows A \u2192 BC (two variables) and A \u2192 a (one terminal). A \u2192 BC has exactly two variables on the right side, so it is valid CNF.'
  },
  {
    q: 'Are context-free languages closed under intersection?',
    options: ['No', 'Yes'],
    correct: 0,
    explanation: 'L\u2081 \u2229 L\u2082 can produce a\u207fb\u207fc\u207f which is not context-free. The classic counterexample uses two CFLs whose intersection requires matching three counts simultaneously.'
  },
  {
    q: 'Is A \u2192 aBC in Chomsky Normal Form?',
    options: ['No', 'Yes'],
    correct: 0,
    explanation: 'It mixes a terminal \'a\' with variables. In CNF, a production is either A \u2192 BC (two variables only) or A \u2192 a (one terminal only). Must replace \'a\' with T\u2090.'
  },
  {
    q: 'Can every ambiguous grammar be rewritten as unambiguous?',
    options: ['Not always', 'Yes, always'],
    correct: 0,
    explanation: 'Inherently ambiguous languages have no unambiguous grammar at all. For example, {a\u2071b\u02b2c\u1d4f | i=j or j=k} is context-free but every grammar for it is ambiguous.'
  }
];

var cfg_quizSelected = [];
var cfg_quizCurrent = 0;
var cfg_quizScore = 0;
var cfg_quizAnswered = false;

function cfg_q1Init() {
  // Pick 3 random questions
  var indices = [];
  for (var i = 0; i < cfg_quizPool.length; i++) indices.push(i);
  // Shuffle
  for (var i = indices.length - 1; i > 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    var tmp = indices[i]; indices[i] = indices[j]; indices[j] = tmp;
  }
  cfg_quizSelected = indices.slice(0, 3);
  cfg_quizCurrent = 0;
  cfg_quizScore = 0;
  cfg_quizAnswered = false;
  document.getElementById('cfg_quizScore').textContent = '';
  cfg_q1Render();
}

function cfg_q1Render() {
  if (cfg_quizCurrent >= 3) {
    // Show final score
    document.getElementById('cfg_quizProgress').textContent = '';
    document.getElementById('cfg_quizQuestion').textContent = 'Quiz Complete!';
    document.getElementById('cfg_quizOptions').innerHTML = '';
    document.getElementById('cfg_quizExplanation').className = 'cfg-quiz-explanation';
    document.getElementById('cfg_quizExplanation').textContent = '';
    document.getElementById('cfg_quizScore').textContent = 'Score: ' + cfg_quizScore + ' / 3';
    return;
  }
  var qIdx = cfg_quizSelected[cfg_quizCurrent];
  var q = cfg_quizPool[qIdx];
  document.getElementById('cfg_quizProgress').textContent = 'Question ' + (cfg_quizCurrent + 1) + ' of 3';
  document.getElementById('cfg_quizQuestion').textContent = q.q;
  document.getElementById('cfg_quizExplanation').className = 'cfg-quiz-explanation';
  document.getElementById('cfg_quizExplanation').textContent = '';
  document.getElementById('cfg_quizScore').textContent = '';
  cfg_quizAnswered = false;

  var optHtml = '';
  for (var i = 0; i < q.options.length; i++) {
    optHtml += '<button class="cfg-quiz-btn" onclick="cfg_q1Check(' + i + ')" id="cfg_qopt' + i + '">' + q.options[i] + '</button>';
  }
  document.getElementById('cfg_quizOptions').innerHTML = optHtml;
}

function cfg_q1Check(choice) {
  if (cfg_quizAnswered) return;
  cfg_quizAnswered = true;
  var qIdx = cfg_quizSelected[cfg_quizCurrent];
  var q = cfg_quizPool[qIdx];
  var correct = q.correct;

  // Disable all buttons
  var btns = document.getElementById('cfg_quizOptions').querySelectorAll('button');
  btns.forEach(function(b) { b.disabled = true; });

  if (choice === correct) {
    cfg_quizScore++;
    document.getElementById('cfg_qopt' + choice).classList.add('correct');
  } else {
    document.getElementById('cfg_qopt' + choice).classList.add('wrong');
    document.getElementById('cfg_qopt' + correct).classList.add('correct');
  }

  var expEl = document.getElementById('cfg_quizExplanation');
  expEl.textContent = q.explanation;
  expEl.classList.add('visible');

  // Auto-advance after 2.5 seconds
  setTimeout(function() {
    cfg_quizCurrent++;
    cfg_q1Render();
  }, 2500);
}

// Initialize quiz on load
cfg_q1Init();
</script>

</body>
</html>
