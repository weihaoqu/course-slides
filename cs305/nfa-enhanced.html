<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NFA Enhanced - Interactive Automata Theory</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; background: #0f172a; color: #e2e8f0; }

  /* Progress bar */
  #progress-bar { position: fixed; top: 0; left: 0; width: 100%; height: 3px; background: rgba(255,255,255,0.05); z-index: 200; }
  #progress { height: 100%; width: 0; background: linear-gradient(90deg, #3b82f6, #8b5cf6); transition: width 0.3s; }

  /* Slide system */
  .slide { display: none; min-height: 100vh; padding: 40px 60px; position: relative; }
  .slide.active { display: flex; flex-direction: column; justify-content: center; }
  .slide-number { }

  /* Typography */
  h1 { font-size: 2.5em; margin-bottom: 16px; background: linear-gradient(135deg, #3b82f6, #8b5cf6); -webkit-background-clip: text; -webkit-text-fill-color: transparent; line-height: 1.2; }
  h2 { font-size: 1.8em; margin-bottom: 14px; color: #93c5fd; }
  h3 { font-size: 1.3em; margin-bottom: 10px; color: #a5b4fc; }
  p, li { font-size: 1.1em; line-height: 1.7; color: #cbd5e1; margin-bottom: 8px; }
  .subtitle { font-size: 1.2em; color: #94a3b8; margin-bottom: 24px; }

  /* Layout */
  .two-col { display: grid; grid-template-columns: 1fr 1fr; gap: 32px; align-items: start; }
  ul { padding-left: 24px; }
  ul li { margin-bottom: 6px; }
  ol { padding-left: 24px; }
  ol li { margin-bottom: 6px; }

  /* Buttons */
  .btn { background: linear-gradient(135deg, #6366f1, #8b5cf6); color: #fff; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 0.95em; font-weight: 600; transition: all 0.2s; }
  .btn:hover { filter: brightness(1.15); transform: translateY(-1px); }
  .btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }
  .btn-sm { padding: 7px 14px; font-size: 0.85em; }
  .btn-secondary { background: #334155; color: #e2e8f0; border: 1px solid #475569; }
  .btn-secondary:hover { background: #475569; }

  /* Callout boxes */
  .key-idea { background: linear-gradient(135deg, rgba(59,130,246,0.12), rgba(139,92,246,0.12)); border-left: 4px solid #3b82f6; border-radius: 0 12px 12px 0; padding: 16px 20px; margin: 12px 0; }
  .key-idea h3 { color: #60a5fa; margin-bottom: 6px; }
  .warning { background: rgba(239,68,68,0.1); border-left: 4px solid #ef4444; border-radius: 0 12px 12px 0; padding: 16px 20px; margin: 12px 0; }
  .warning h3 { color: #f87171; margin-bottom: 6px; }
  .analogy { background: rgba(139,92,246,0.1); border-left: 4px solid #8b5cf6; border-radius: 0 12px 12px 0; padding: 16px 20px; margin: 12px 0; }
  .analogy h3 { color: #a78bfa; margin-bottom: 6px; }

  /* Code blocks */
  .code-block { background: #0f172a; border: 1px solid #334155; border-radius: 10px; padding: 16px; margin: 10px 0; overflow-x: auto; }
  .code-content { font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; font-size: 0.9em; line-height: 1.6; }
  .line { padding: 2px 8px; border-left: 3px solid transparent; transition: all 0.3s; }
  .line.active { background: rgba(99,102,241,0.15); border-left-color: #6366f1; }

  /* Tables */
  table { border-collapse: collapse; margin: 12px 0; }
  th, td { border: 1px solid #475569; padding: 8px 14px; text-align: center; }
  th { background: #334155; color: #93c5fd; font-weight: 600; font-size: 0.95em; }
  td { background: #1e293b; color: #e2e8f0; font-size: 0.95em; }
  tr.highlight td { background: rgba(99,102,241,0.15); }

  /* VS cards */
  .vs-box { display: flex; gap: 24px; align-items: stretch; margin: 16px 0; }
  .vs-card { flex: 1; background: #1e293b; border-radius: 12px; padding: 20px; border: 2px solid #334155; }
  .vs-card.dfa { border-color: #3b82f6; }
  .vs-card.nfa { border-color: #8b5cf6; }
  .vs-card h3 { text-align: center; margin-bottom: 12px; }

  /* Log panel */
  .log-panel { background: rgba(0,0,0,0.25); border-radius: 8px; padding: 10px 12px; font-family: monospace; font-size: 0.78rem; max-height: 140px; overflow-y: auto; color: #94a3b8; line-height: 1.5; }
  .log-panel .log-entry { margin-bottom: 2px; }
  .log-panel .log-new { color: #38bdf8; }
  .log-panel .log-highlight { color: #f59e0b; }

  /* Animations */
  .fade-in { animation: fadeIn 0.4s ease-in; }
  @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }

  /* Nav */
  .nav { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; z-index: 100; }
  .nav button { background: #334155; border: 1px solid #475569; color: #e2e8f0; padding: 8px 20px; border-radius: 8px; cursor: pointer; font-size: 14px; transition: all 0.2s; }
  .nav button:hover { background: #475569; }
  .nav button:disabled { opacity: 0.3; cursor: not-allowed; }

  /* Canvas container */
  .canvas-wrap { background: rgba(0,0,0,0.2); border-radius: 12px; display: inline-block; }

  /* Sim controls row */
  .ctrl-row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin: 8px 0; }
  .ctrl-row input[type="text"] {
    background: #1e293b; border: 2px solid #475569; color: #e2e8f0; padding: 8px 12px;
    border-radius: 8px; font-family: monospace; font-size: 1em; width: 160px; outline: none; transition: border-color 0.2s;
  }
  .ctrl-row input[type="text"]:focus { border-color: #6366f1; }

  /* Status display */
  .status-box { background: #1e293b; border-radius: 8px; padding: 10px 14px; margin: 8px 0; font-family: monospace; font-size: 0.95em; }
  .status-box .label { color: #94a3b8; font-size: 0.85em; }
  .status-box .value { color: #38bdf8; font-weight: 600; }

  /* Verdict */
  .verdict { margin-top: 10px; padding: 10px 16px; border-radius: 8px; font-weight: 600; text-align: center; font-size: 1em; }
  .verdict.accept { background: rgba(34,197,94,0.15); color: #4ade80; border: 2px solid #22c55e; }
  .verdict.reject { background: rgba(239,68,68,0.15); color: #f87171; border: 2px solid #ef4444; }
</style>
</head>
<body>

<div id="progress-bar"><div id="progress"></div></div>

<!-- ==================== s1: TITLE ==================== -->
<div class="slide active" id="s1">
  <div style="text-align:center;">
    <h1 style="font-size:3em;">Nondeterministic Finite Automata</h1>
    <p class="subtitle" style="font-size:1.4em;">Interactive Enhanced Edition</p>
    <div style="margin-top:30px; display:flex; gap:16px; justify-content:center; flex-wrap:wrap;">
      <div style="background:#1e293b; border:1px solid #334155; border-radius:12px; padding:16px 24px; min-width:140px;">
        <div style="color:#6366f1; font-size:1.6em; font-weight:700;">NFA</div>
        <div style="color:#94a3b8; font-size:0.85em;">Nondeterminism</div>
      </div>
      <div style="background:#1e293b; border:1px solid #334155; border-radius:12px; padding:16px 24px; min-width:140px;">
        <div style="color:#f59e0b; font-size:1.6em; font-weight:700;">2<sup>n</sup></div>
        <div style="color:#94a3b8; font-size:0.85em;">Subset Construction</div>
      </div>
      <div style="background:#1e293b; border:1px solid #334155; border-radius:12px; padding:16px 24px; min-width:140px;">
        <div style="color:#8b5cf6; font-size:1.6em; font-weight:700;">&epsilon;</div>
        <div style="color:#94a3b8; font-size:0.85em;">Epsilon Transitions</div>
      </div>
    </div>
    <p style="margin-top:40px; color:#64748b; font-size:0.9em;">Arrow keys to navigate &nbsp;|&nbsp; Based on CS305 lecture materials (Ullman)</p>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ==================== s2: BIG PICTURE ==================== -->
<div class="slide" id="s2">
  <h1>The Big Picture</h1>
  <p class="subtitle">Three formalisms, one class of languages</p>
  <div class="two-col">
    <div>
      <div style="text-align:center;">
        <canvas id="cS2" width="480" height="300" style="width:100%;" class="canvas-wrap"></canvas>
      </div>
      <div class="ctrl-row" style="justify-content:center; margin-top:12px;">
        <button class="btn btn-sm" onclick="s2Animate()">Animate Equivalences</button>
        <button class="btn btn-sm btn-secondary" onclick="s2Reset()">Reset</button>
      </div>
    </div>
    <div>
      <div class="key-idea">
        <h3>All Three Are Equal!</h3>
        <p>DFA, NFA, and &epsilon;-NFA all recognize <b>exactly the same languages</b> &mdash; the <b>regular languages</b>.</p>
      </div>
      <div class="analogy">
        <h3>Why learn all three?</h3>
        <p><b>NFAs</b> are easier to design (fewer states, more flexibility). <b>&epsilon;-NFAs</b> are easiest to compose (union = just add &epsilon;-arrows). But only <b>DFAs</b> can run on a computer (one state at a time).</p>
        <p style="margin-top:8px;">This lecture teaches the <b>conversions</b> between them.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas = document.getElementById('cS2');
  const ctx = canvas.getContext('2d');
  let animPhase = 0;
  let animTimer = null;

  const boxes = [
    { label: 'DFA', sub: 'Deterministic', x: 80, y: 140, color: '#3b82f6' },
    { label: 'NFA', sub: 'Nondeterministic', x: 240, y: 140, color: '#8b5cf6' },
    { label: '\u03B5-NFA', sub: 'Epsilon-NFA', x: 400, y: 140, color: '#f59e0b' }
  ];

  const arrows = [
    { from: 0, to: 1, labelTop: 'trivial', labelBot: 'subset\nconstruction', topY: -40, botY: 40 },
    { from: 1, to: 2, labelTop: 'trivial', labelBot: 'eliminate \u03B5', topY: -40, botY: 40 }
  ];

  function draw() {
    ctx.clearRect(0, 0, 480, 300);

    // Title
    ctx.font = 'bold 13px system-ui';
    ctx.fillStyle = '#94a3b8';
    ctx.textAlign = 'center';
    ctx.fillText('All recognize the Regular Languages', 240, 28);

    // Draw arrows
    arrows.forEach((a, ai) => {
      const b1 = boxes[a.from], b2 = boxes[a.to];
      const mx = (b1.x + b2.x) / 2;

      // Top arrow (right to left = trivial)
      const topAlpha = animPhase > ai * 2 ? 1 : 0.15;
      ctx.globalAlpha = topAlpha;
      ctx.strokeStyle = '#4ade80';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(b2.x - 50, b2.y + a.topY);
      ctx.lineTo(b1.x + 50, b1.y + a.topY);
      ctx.stroke();
      // Arrowhead
      ctx.beginPath();
      ctx.moveTo(b1.x + 50, b1.y + a.topY);
      ctx.lineTo(b1.x + 58, b1.y + a.topY - 5);
      ctx.lineTo(b1.x + 58, b1.y + a.topY + 5);
      ctx.closePath();
      ctx.fillStyle = '#4ade80';
      ctx.fill();
      // Label
      ctx.font = '11px system-ui';
      ctx.fillStyle = '#4ade80';
      ctx.textAlign = 'center';
      ctx.fillText(a.labelTop, mx, b1.y + a.topY - 8);

      // Bottom arrow (left to right = construction)
      const botAlpha = animPhase > ai * 2 + 1 ? 1 : 0.15;
      ctx.globalAlpha = botAlpha;
      ctx.strokeStyle = '#f59e0b';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(b1.x + 50, b1.y + a.botY);
      ctx.lineTo(b2.x - 50, b2.y + a.botY);
      ctx.stroke();
      // Arrowhead
      ctx.beginPath();
      ctx.moveTo(b2.x - 50, b2.y + a.botY);
      ctx.lineTo(b2.x - 58, b2.y + a.botY - 5);
      ctx.lineTo(b2.x - 58, b2.y + a.botY + 5);
      ctx.closePath();
      ctx.fillStyle = '#f59e0b';
      ctx.fill();
      // Label (may have newline)
      ctx.font = '11px system-ui';
      ctx.fillStyle = '#f59e0b';
      const parts = a.labelBot.split('\n');
      parts.forEach((p, pi) => {
        ctx.fillText(p, mx, b1.y + a.botY + 14 + pi * 14);
      });
    });

    ctx.globalAlpha = 1;

    // Draw boxes
    boxes.forEach((b, i) => {
      const glow = animPhase >= 0;
      // Box
      ctx.fillStyle = '#1e293b';
      ctx.strokeStyle = b.color;
      ctx.lineWidth = 2;
      roundRect(ctx, b.x - 48, b.y - 30, 96, 60, 10);
      ctx.fill();
      ctx.stroke();
      // Label
      ctx.font = 'bold 18px system-ui';
      ctx.fillStyle = b.color;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(b.label, b.x, b.y - 5);
      // Sub
      ctx.font = '10px system-ui';
      ctx.fillStyle = '#94a3b8';
      ctx.fillText(b.sub, b.x, b.y + 16);
    });

    // Bottom note
    ctx.font = 'italic 12px system-ui';
    ctx.fillStyle = '#64748b';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';
    ctx.fillText('Only DFA can be executed on a computer', 240, 280);
  }

  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  window.s2Animate = function() {
    animPhase = 0;
    if (animTimer) clearInterval(animTimer);
    animTimer = setInterval(() => {
      animPhase++;
      draw();
      if (animPhase >= 5) { clearInterval(animTimer); animTimer = null; }
    }, 700);
    draw();
  };

  window.s2Reset = function() {
    if (animTimer) { clearInterval(animTimer); animTimer = null; }
    animPhase = 5;
    draw();
  };

  const obs = new MutationObserver(() => {
    if (document.getElementById('s2').classList.contains('active')) { animPhase = 5; draw(); }
  });
  obs.observe(document.getElementById('s2'), { attributes: true, attributeFilter: ['class'] });
  animPhase = 5;
  draw();
})();
</script>

<!-- ==================== s3: WHAT IS AN NFA ==================== -->
<div class="slide" id="s3">
  <h1>What is an NFA?</h1>
  <p class="subtitle">The key difference from DFAs: <b>choice</b></p>
  <div class="two-col">
    <div>
      <canvas id="cS3" width="460" height="320" style="width:100%;" class="canvas-wrap"></canvas>
      <div class="ctrl-row" style="justify-content:center; margin-top:8px;">
        <button class="btn btn-sm" onclick="s3Step()">Step</button>
        <button class="btn btn-sm" onclick="s3Auto()">Auto Play</button>
        <button class="btn btn-sm btn-secondary" onclick="s3Reset()">Reset</button>
      </div>
      <p style="font-size:0.82em; color:#94a3b8; text-align:center; margin-top:4px;">DFA: one path &nbsp;|&nbsp; NFA: multiple paths explored simultaneously</p>
    </div>
    <div>
      <p>An <b>NFA</b> changes two rules from a DFA:</p>
      <ul>
        <li>From one state on one input, there can be <b>zero, one, or many</b> next states</li>
        <li>The NFA can be in <b>several states at once</b></li>
      </ul>
      <div class="key-idea">
        <h3>Acceptance Rule</h3>
        <p>An NFA accepts if <b>ANY</b> sequence of choices leads to a final state. It only needs <b>one</b> successful path out of all possibilities.</p>
      </div>
      <div class="analogy">
        <h3>Maze with Clones</h3>
        <p>Imagine a maze where every fork lets you <b>clone yourself</b> and explore all paths simultaneously. If <b>any</b> clone reaches the exit, you win. That's an NFA.</p>
      </div>
      <div class="warning">
        <h3>Common Misconception</h3>
        <p>"NFAs are more powerful than DFAs." <b>FALSE!</b> They recognize exactly the same languages. Nondeterminism gives convenience, not extra power.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas = document.getElementById('cS3');
  const ctx = canvas.getContext('2d');

  // Visualize: DFA (top) follows one path, NFA (bottom) branches
  // Input string: "010"
  // DFA: A->B->A->B (single path)
  // NFA: q0->{q0,q1}->... (branching tree)
  const inputStr = '010';

  // DFA states for "contains 1": A(no 1 seen), B(1 seen, accept)
  const dfaSteps = [
    { states: ['A'], label: 'Start' },
    { states: ['B'], label: "Read '0'" },
    { states: ['A'], label: "Read '1'" },
    { states: ['B'], label: "Read '0'" }
  ];

  // NFA for "ends with 01": q0 always, q1 after seeing candidate 0, q2 accept
  const nfaSteps = [
    { states: ['q0'], label: 'Start' },
    { states: ['q0','q1'], label: "Read '0': fork!" },
    { states: ['q0','q2'], label: "Read '1': q1->q2!" },
    { states: ['q0','q1'], label: "Read '0': fork!" }
  ];

  let stepIdx = 0;
  let timer = null;

  function drawState(x, y, label, color, r) {
    r = r || 18;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = '#e2e8f0';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.font = 'bold 12px monospace';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, x, y);
  }

  function drawArrow(x1, y1, x2, y2, color) {
    const dx = x2 - x1, dy = y2 - y1;
    const len = Math.sqrt(dx * dx + dy * dy);
    const ux = dx / len, uy = dy / len;
    const ex = x2 - ux * 20, ey = y2 - uy * 20;
    ctx.beginPath();
    ctx.moveTo(x1 + ux * 20, y1 + uy * 20);
    ctx.lineTo(ex, ey);
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.stroke();
    // Arrowhead
    ctx.beginPath();
    ctx.moveTo(ex + ux * 8, ey + uy * 8);
    ctx.lineTo(ex - uy * 5 - ux * 2, ey + ux * 5 - uy * 2);
    ctx.lineTo(ex + uy * 5 - ux * 2, ey - ux * 5 - uy * 2);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
  }

  function draw() {
    ctx.clearRect(0, 0, 460, 320);

    // Section labels
    ctx.font = 'bold 14px system-ui';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    ctx.fillStyle = '#3b82f6';
    ctx.fillText('DFA (one state at a time)', 10, 20);
    ctx.fillStyle = '#8b5cf6';
    ctx.fillText('NFA (multiple states at once)', 10, 178);

    // Separator
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(10, 158);
    ctx.lineTo(450, 158);
    ctx.stroke();
    ctx.setLineDash([]);

    // Input string display
    ctx.font = '12px monospace';
    ctx.fillStyle = '#94a3b8';
    ctx.textAlign = 'right';
    ctx.fillText('Input: "' + inputStr + '"', 450, 20);

    // Step indicator
    ctx.textAlign = 'right';
    ctx.fillStyle = '#64748b';
    ctx.fillText(stepIdx === 0 ? 'Start' : 'After reading: "' + inputStr.substring(0, stepIdx) + '"', 450, 178);

    // ---- DFA section (top) ----
    const dfaCurrent = dfaSteps[stepIdx];
    const dfaStatePositions = { A: { x: 80, y: 90 }, B: { x: 200, y: 90 } };

    // Draw DFA transitions
    drawArrow(80, 90, 200, 90, '#475569');
    ctx.font = '11px monospace';
    ctx.fillStyle = '#f59e0b';
    ctx.textAlign = 'center';
    ctx.fillText('0', 140, 82);

    // Self-loop hint on A
    ctx.beginPath();
    ctx.arc(80, 55, 15, 0.3, Math.PI - 0.3);
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.fillStyle = '#f59e0b';
    ctx.fillText('1', 80, 38);

    // Self-loop on B
    ctx.beginPath();
    ctx.arc(200, 55, 15, 0.3, Math.PI - 0.3);
    ctx.strokeStyle = '#475569';
    ctx.stroke();
    ctx.fillStyle = '#f59e0b';
    ctx.fillText('0,1', 200, 38);

    // Back arrow B->A for 1
    ctx.beginPath();
    ctx.moveTo(190, 108);
    ctx.quadraticCurveTo(140, 130, 92, 108);
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.fillStyle = '#f59e0b';
    ctx.fillText('1', 140, 128);

    // Draw DFA states
    Object.entries(dfaStatePositions).forEach(([name, pos]) => {
      const isActive = dfaCurrent.states.includes(name);
      drawState(pos.x, pos.y, name, isActive ? '#3b82f6' : '#334155');
    });

    // Start arrow
    ctx.beginPath();
    ctx.moveTo(35, 90);
    ctx.lineTo(58, 90);
    ctx.strokeStyle = '#e2e8f0';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(60, 90);
    ctx.lineTo(54, 85);
    ctx.lineTo(54, 95);
    ctx.closePath();
    ctx.fillStyle = '#e2e8f0';
    ctx.fill();

    // DFA label
    ctx.font = '12px system-ui';
    ctx.fillStyle = '#94a3b8';
    ctx.textAlign = 'left';
    ctx.fillText('Active: {' + dfaCurrent.states.join(', ') + '}', 260, 80);
    ctx.fillStyle = '#64748b';
    ctx.fillText(dfaCurrent.label, 260, 100);

    // ---- NFA section (bottom) ----
    const nfaCurrent = nfaSteps[stepIdx];
    const nfaPositions = { q0: { x: 80, y: 250 }, q1: { x: 200, y: 250 }, q2: { x: 320, y: 250 } };

    // Draw NFA transitions
    // q0 self-loop on 0,1
    ctx.beginPath();
    ctx.arc(80, 215, 15, 0.3, Math.PI - 0.3);
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.font = '11px monospace';
    ctx.fillStyle = '#f59e0b';
    ctx.textAlign = 'center';
    ctx.fillText('0,1', 80, 198);

    // q0 -> q1 on 0
    drawArrow(80, 250, 200, 250, '#475569');
    ctx.fillStyle = '#f59e0b';
    ctx.fillText('0', 140, 242);

    // q1 -> q2 on 1
    drawArrow(200, 250, 320, 250, '#475569');
    ctx.fillStyle = '#f59e0b';
    ctx.fillText('1', 260, 242);

    // Accept circle on q2
    ctx.beginPath();
    ctx.arc(320, 250, 14, 0, Math.PI * 2);
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Start arrow
    ctx.beginPath();
    ctx.moveTo(35, 250);
    ctx.lineTo(58, 250);
    ctx.strokeStyle = '#e2e8f0';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(60, 250);
    ctx.lineTo(54, 245);
    ctx.lineTo(54, 255);
    ctx.closePath();
    ctx.fillStyle = '#e2e8f0';
    ctx.fill();

    // Draw NFA states
    Object.entries(nfaPositions).forEach(([name, pos]) => {
      const isActive = nfaCurrent.states.includes(name);
      const isAccept = name === 'q2';
      drawState(pos.x, pos.y, name, isActive ? '#8b5cf6' : '#334155');
      if (isAccept && isActive) {
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 22, 0, Math.PI * 2);
        ctx.strokeStyle = '#22c55e';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    });

    // NFA label
    ctx.font = '12px system-ui';
    ctx.fillStyle = '#94a3b8';
    ctx.textAlign = 'left';
    const stateStr = '{' + nfaCurrent.states.join(', ') + '}';
    ctx.fillText('Active: ' + stateStr, 260, 300);
    ctx.fillStyle = nfaCurrent.states.includes('q2') ? '#4ade80' : '#64748b';
    ctx.fillText(nfaCurrent.label, 100, 300);
  }

  window.s3Step = function() {
    if (stepIdx >= inputStr.length) return;
    stepIdx++;
    draw();
  };
  window.s3Auto = function() {
    if (timer) return;
    timer = setInterval(() => {
      if (stepIdx >= inputStr.length) { clearInterval(timer); timer = null; return; }
      stepIdx++;
      draw();
    }, 900);
  };
  window.s3Reset = function() {
    if (timer) { clearInterval(timer); timer = null; }
    stepIdx = 0;
    draw();
  };

  const obs = new MutationObserver(() => {
    if (document.getElementById('s3').classList.contains('active')) draw();
  });
  obs.observe(document.getElementById('s3'), { attributes: true, attributeFilter: ['class'] });
  draw();
})();
</script>

<!-- ==================== s4: DFA vs NFA COMPARISON ==================== -->
<div class="slide" id="s4">
  <h1>DFA vs NFA: Side by Side</h1>
  <p class="subtitle">Same power, different style</p>
  <div class="vs-box">
    <div class="vs-card dfa">
      <h3 style="color:#60a5fa;">DFA (Deterministic)</h3>
      <div class="code-block">
        <div class="code-content">
          <div class="line">&delta;(q, a) = <b>one state</b></div>
          <div class="line" style="color:#94a3b8;">"From q reading a, go to exactly one state"</div>
        </div>
      </div>
      <ul>
        <li>Always in <b>exactly one</b> state</li>
        <li>Every state has <b>exactly one</b> transition per symbol</li>
        <li>No dead ends (total function)</li>
        <li><b>Easy to simulate</b> on a computer</li>
      </ul>
    </div>
    <div class="vs-card nfa">
      <h3 style="color:#a78bfa;">NFA (Nondeterministic)</h3>
      <div class="code-block">
        <div class="code-content">
          <div class="line">&delta;(q, a) = <b>set of states</b></div>
          <div class="line" style="color:#94a3b8;">"From q reading a, go to any of these states"</div>
        </div>
      </div>
      <ul>
        <li>Can be in <b>multiple states</b> simultaneously</li>
        <li>A state may have <b>0 or many</b> transitions per symbol</li>
        <li>Dead ends allowed (kills that branch)</li>
        <li><b>Easier to design</b> (more compact)</li>
      </ul>
    </div>
  </div>
  <div class="key-idea">
    <h3>Design Advantage: Exponential Compression</h3>
    <p>An NFA for "n-th symbol from end is 1" needs <b>~n states</b>. The equivalent DFA needs <b>~2<sup>n</sup> states</b>! NFAs give you design convenience, even though they don't add computational power.</p>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ==================== s5: FORMAL DEFINITION ==================== -->
<div class="slide" id="s5">
  <h1>Formal Definition of an NFA</h1>
  <p class="subtitle">Five components &mdash; the only difference is &delta;</p>
  <div class="two-col">
    <div>
      <p>An NFA is a 5-tuple <b>(Q, &Sigma;, &delta;, q<sub>0</sub>, F)</b>:</p>
      <table>
        <tr><th>Symbol</th><th>Meaning</th><th>Same as DFA?</th></tr>
        <tr><td><b>Q</b></td><td style="text-align:left;">Finite set of states</td><td>Yes</td></tr>
        <tr><td><b>&Sigma;</b></td><td style="text-align:left;">Input alphabet</td><td>Yes</td></tr>
        <tr><td><b>&delta;</b></td><td style="text-align:left;">Transition function</td><td style="color:#f59e0b; font-weight:700;">DIFFERENT</td></tr>
        <tr><td><b>q<sub>0</sub></b></td><td style="text-align:left;">Start state</td><td>Yes</td></tr>
        <tr><td><b>F</b></td><td style="text-align:left;">Set of accept states</td><td>Yes</td></tr>
      </table>
    </div>
    <div>
      <div class="key-idea">
        <h3>The Key Difference: &delta;</h3>
        <p><b>DFA:</b> &delta;(q, a) = <b>one state p</b></p>
        <p><b>NFA:</b> &delta;(q, a) = <b>a SET of states</b> {p, r, s} or even {}</p>
        <p style="margin-top:8px; color:#94a3b8;">That's it! The transition function returns a <b>set</b> instead of a single state.</p>
      </div>
      <div class="code-block">
        <div class="code-content">
          <div class="line" style="color:#3b82f6;">DFA:  &delta;(q0, '0') = q1      <span style="color:#64748b;">// one answer</span></div>
          <div class="line" style="color:#8b5cf6;">NFA:  &delta;(q0, '0') = {q1,q3} <span style="color:#64748b;">// multiple</span></div>
          <div class="line" style="color:#ef4444;">NFA:  &delta;(q2, '1') = {}      <span style="color:#64748b;">// dead end</span></div>
        </div>
      </div>
      <div class="warning">
        <h3>The empty set {} is valid</h3>
        <p>If &delta;(q, a) = {}, that branch of computation simply <b>dies</b>. This is fine &mdash; other branches may still succeed.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ==================== s6: CHESSBOARD PLAYGROUND ==================== -->
<div class="slide" id="s6">
  <h1>Chessboard NFA &mdash; Interactive</h1>
  <p class="subtitle">Type a string of r's and b's to move the king across a 3&times;3 board</p>
  <div class="two-col">
    <div>
      <canvas id="cS6" width="440" height="380" style="width:100%;" class="canvas-wrap"></canvas>
      <div class="ctrl-row" style="margin-top:8px;">
        <input type="text" id="s6Input" placeholder="e.g. rbb" maxlength="12" />
        <button class="btn btn-sm" onclick="s6Step()">Step</button>
        <button class="btn btn-sm" onclick="s6Auto()">Auto</button>
        <button class="btn btn-sm btn-secondary" onclick="s6Reset()">Reset</button>
      </div>
      <div class="status-box" id="s6Status">
        <span class="label">Active squares:</span> <span class="value" id="s6Active">{1}</span>
      </div>
      <div id="s6Verdict"></div>
    </div>
    <div>
      <h3>How it works</h3>
      <ul>
        <li><b>States</b> = 9 squares (1&ndash;9)</li>
        <li><b>r</b> = move to adjacent <span style="color:#f87171;">red</span> square</li>
        <li><b>b</b> = move to adjacent <span style="color:#64748b;">black</span> square</li>
        <li><b>Start:</b> square 1 &nbsp;|&nbsp; <b>Accept:</b> square 9</li>
        <li>Adjacent = shares edge or corner (king moves)</li>
      </ul>
      <div class="key-idea" style="margin-top:12px;">
        <h3>Why is this an NFA?</h3>
        <p>From square 5 (center), reading 'r', you could move to <b>four</b> different red squares: {1, 3, 7, 9}. Multiple choices = nondeterminism!</p>
      </div>
      <table style="font-size:0.82em;">
        <tr><th></th><th>r</th><th>b</th></tr>
        <tr><td><b>&rarr;1</b></td><td>{5}</td><td>{2,4}</td></tr>
        <tr><td>2</td><td>{1,3,5}</td><td>{4,6}</td></tr>
        <tr><td>3</td><td>{5}</td><td>{2,6}</td></tr>
        <tr><td>4</td><td>{1,5,7}</td><td>{2,8}</td></tr>
        <tr><td>5</td><td>{1,3,7,9}</td><td>{2,4,6,8}</td></tr>
        <tr><td>6</td><td>{3,5,9}</td><td>{2,8}</td></tr>
        <tr><td>7</td><td>{5}</td><td>{4,8}</td></tr>
        <tr><td>8</td><td>{5,7,9}</td><td>{4,6}</td></tr>
        <tr><td><b>*9</b></td><td>{5}</td><td>{6,8}</td></tr>
      </table>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas = document.getElementById('cS6');
  const ctx = canvas.getContext('2d');

  // Board colors: red squares at positions where (row+col) is even (0-indexed)
  // 1=red, 2=black, 3=red, 4=black, 5=red, 6=black, 7=red, 8=black, 9=red
  const isRed = [true, false, true, false, true, false, true, false, true]; // 0-indexed for squares 1-9
  const sqSize = 90;
  const boardX = 40, boardY = 30;

  // NFA transitions
  const delta = {
    1: { r: [5], b: [2,4] },
    2: { r: [1,3,5], b: [4,6] },
    3: { r: [5], b: [2,6] },
    4: { r: [1,5,7], b: [2,8] },
    5: { r: [1,3,7,9], b: [2,4,6,8] },
    6: { r: [3,5,9], b: [2,8] },
    7: { r: [5], b: [4,8] },
    8: { r: [5,7,9], b: [4,6] },
    9: { r: [5], b: [6,8] }
  };

  let activeSet = new Set([1]);
  let inputStr = '';
  let pos = -1;
  let done = false;
  let timer = null;

  function sqToCoord(sq) {
    const idx = sq - 1;
    const row = Math.floor(idx / 3);
    const col = idx % 3;
    return { cx: boardX + col * sqSize + sqSize / 2, cy: boardY + row * sqSize + sqSize / 2 };
  }

  function draw() {
    ctx.clearRect(0, 0, 440, 380);

    // Draw board
    for (let i = 0; i < 9; i++) {
      const row = Math.floor(i / 3);
      const col = i % 3;
      const x = boardX + col * sqSize;
      const y = boardY + row * sqSize;
      const sq = i + 1;
      const red = isRed[i];
      const active = activeSet.has(sq);
      const isAccept = sq === 9;

      // Fill square
      if (active) {
        ctx.fillStyle = red ? 'rgba(239,68,68,0.5)' : 'rgba(100,116,139,0.5)';
        ctx.shadowColor = '#f59e0b';
        ctx.shadowBlur = 15;
      } else {
        ctx.fillStyle = red ? 'rgba(239,68,68,0.2)' : 'rgba(100,116,139,0.2)';
        ctx.shadowBlur = 0;
      }
      ctx.fillRect(x, y, sqSize, sqSize);
      ctx.shadowBlur = 0;

      // Border
      ctx.strokeStyle = active ? '#f59e0b' : '#475569';
      ctx.lineWidth = active ? 3 : 1;
      ctx.strokeRect(x, y, sqSize, sqSize);

      // Accept indicator
      if (isAccept) {
        ctx.strokeStyle = active && done && activeSet.has(9) ? '#22c55e' : '#22c55e';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 3]);
        ctx.strokeRect(x + 4, y + 4, sqSize - 8, sqSize - 8);
        ctx.setLineDash([]);
      }

      // Square number
      ctx.font = active ? 'bold 28px system-ui' : '24px system-ui';
      ctx.fillStyle = active ? '#fff' : '#94a3b8';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(sq, x + sqSize / 2, y + sqSize / 2);
    }

    // Labels
    ctx.font = '12px system-ui';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    ctx.fillStyle = '#f87171';
    ctx.fillText('Red squares: 1,3,5,7,9', boardX, boardY + sqSize * 3 + 24);
    ctx.fillStyle = '#94a3b8';
    ctx.fillText('Black squares: 2,4,6,8', boardX + 180, boardY + sqSize * 3 + 24);
    ctx.fillStyle = '#22c55e';
    ctx.fillText('Accept: square 9 (dashed)', boardX, boardY + sqSize * 3 + 44);

    // Input display
    if (inputStr) {
      ctx.font = '14px monospace';
      ctx.textAlign = 'left';
      ctx.fillStyle = '#94a3b8';
      ctx.fillText('Input:', boardX, boardY + sqSize * 3 + 68);
      let tx = boardX + 50;
      for (let i = 0; i < inputStr.length; i++) {
        if (i < pos) {
          ctx.fillStyle = '#475569';
        } else if (i === pos) {
          ctx.fillStyle = '#f59e0b';
          ctx.font = 'bold 16px monospace';
        } else {
          ctx.fillStyle = '#e2e8f0';
          ctx.font = '14px monospace';
        }
        ctx.fillText(inputStr[i], tx, boardY + sqSize * 3 + 68);
        tx += 16;
      }
    }

    // Update DOM status
    const arr = [...activeSet].sort((a, b) => a - b);
    document.getElementById('s6Active').textContent = '{' + arr.join(', ') + '}';
  }

  function initSim() {
    const raw = document.getElementById('s6Input').value.trim().toLowerCase();
    if (!/^[rb]*$/.test(raw)) {
      document.getElementById('s6Verdict').innerHTML = '<div class="verdict reject">Only r and b allowed!</div>';
      return false;
    }
    inputStr = raw;
    pos = -1;
    activeSet = new Set([1]);
    done = false;
    document.getElementById('s6Verdict').innerHTML = '';
    draw();
    return true;
  }

  window.s6Step = function() {
    if (done) return;
    if (pos === -1 && inputStr === '') {
      if (!initSim()) return;
      if (inputStr.length === 0) { finish(); return; }
      return;
    }
    if (inputStr === '') {
      if (!initSim()) return;
      if (inputStr.length === 0) { finish(); return; }
      return;
    }
    pos++;
    if (pos >= inputStr.length) { finish(); return; }
    const sym = inputStr[pos];
    const nextSet = new Set();
    for (const sq of activeSet) {
      const targets = delta[sq][sym] || [];
      targets.forEach(t => nextSet.add(t));
    }
    activeSet = nextSet;
    draw();
    if (pos === inputStr.length - 1) finish();
  };

  window.s6Auto = function() {
    if (timer) return;
    if (inputStr === '' || pos === -1) {
      if (!initSim()) return;
    }
    timer = setInterval(() => {
      if (done) { clearInterval(timer); timer = null; return; }
      s6Step();
    }, 600);
  };

  window.s6Reset = function() {
    if (timer) { clearInterval(timer); timer = null; }
    inputStr = '';
    pos = -1;
    activeSet = new Set([1]);
    done = false;
    document.getElementById('s6Verdict').innerHTML = '';
    document.getElementById('s6Input').value = '';
    draw();
  };

  function finish() {
    done = true;
    const accepted = activeSet.has(9);
    const v = document.getElementById('s6Verdict');
    if (accepted) {
      v.innerHTML = '<div class="verdict accept">ACCEPTED! Active set contains square 9.</div>';
    } else {
      v.innerHTML = '<div class="verdict reject">REJECTED. Active set {' + [...activeSet].sort((a,b)=>a-b).join(', ') + '} does not contain 9.</div>';
    }
    draw();
  }

  const obs = new MutationObserver(() => {
    if (document.getElementById('s6').classList.contains('active')) draw();
  });
  obs.observe(document.getElementById('s6'), { attributes: true, attributeFilter: ['class'] });
  draw();
})();
</script>

<!-- ==================== s7: NFA SIMULATOR ==================== -->
<div class="slide" id="s7">
  <h1>NFA Simulator: "ends with 01"</h1>
  <p class="subtitle">Watch parallel branches live &mdash; type any binary string</p>
  <div class="two-col">
    <div>
      <canvas id="cS7" width="480" height="260" style="width:100%;" class="canvas-wrap"></canvas>
      <div class="ctrl-row" style="margin-top:8px;">
        <input type="text" id="s7Input" placeholder="e.g. 1001" maxlength="20" />
        <button class="btn btn-sm" onclick="s7Step()">Step</button>
        <button class="btn btn-sm" onclick="s7Auto()">Auto</button>
        <button class="btn btn-sm btn-secondary" onclick="s7Reset()">Reset</button>
      </div>
      <div class="status-box">
        <div><span class="label">Active states:</span> <span class="value" id="s7Active">{q0}</span></div>
        <div id="s7InputDisplay" style="margin-top:4px; font-family:monospace; font-size:0.9em;"></div>
      </div>
      <div id="s7Verdict"></div>
    </div>
    <div>
      <h3>NFA: L = {w &isin; {0,1}* | w ends with "01"}</h3>
      <table>
        <tr><th></th><th>0</th><th>1</th></tr>
        <tr><td><b>&rarr; q0</b></td><td>{q0, q1}</td><td>{q0}</td></tr>
        <tr><td>q1</td><td>{}</td><td>{q2}</td></tr>
        <tr><td><b>* q2</b></td><td>{}</td><td>{}</td></tr>
      </table>
      <div class="key-idea" style="margin-top:12px;">
        <h3>The "guessing" strategy</h3>
        <p>On seeing <b>0</b>, q0 has a <b>choice</b>: stay in q0 (this 0 isn't the end) OR go to q1 (bet that this 0 starts "01"). Both branches run in parallel.</p>
      </div>
      <div class="log-panel" id="s7Log" style="margin-top:8px;">
        Type a binary string and click Step...
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas = document.getElementById('cS7');
  const ctx = canvas.getContext('2d');

  const nfa = {
    states: ['q0', 'q1', 'q2'],
    accept: new Set(['q2']),
    delta: {
      q0: { '0': ['q0', 'q1'], '1': ['q0'] },
      q1: { '0': [], '1': ['q2'] },
      q2: { '0': [], '1': [] }
    }
  };

  const positions = {
    q0: { x: 100, y: 130 },
    q1: { x: 260, y: 130 },
    q2: { x: 420, y: 130 }
  };

  let activeStates = new Set(['q0']);
  let inputStr = '';
  let pos = -1;
  let done = false;
  let timer = null;
  let highlightEdges = []; // [{from, to, symbol}]

  function drawNFA() {
    ctx.clearRect(0, 0, 480, 260);

    // Title
    ctx.font = '12px system-ui';
    ctx.fillStyle = '#64748b';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';
    ctx.fillText('NFA for "ends with 01"', 240, 20);

    // Draw edges first
    // q0 self-loop (0,1)
    const q0 = positions.q0;
    ctx.beginPath();
    ctx.arc(q0.x, q0.y - 40, 18, 0.4, Math.PI - 0.4);
    ctx.strokeStyle = edgeHighlighted('q0', 'q0') ? '#f59e0b' : '#475569';
    ctx.lineWidth = edgeHighlighted('q0', 'q0') ? 3 : 1.5;
    ctx.stroke();
    ctx.font = '12px monospace';
    ctx.fillStyle = edgeHighlighted('q0', 'q0') ? '#f59e0b' : '#94a3b8';
    ctx.textAlign = 'center';
    ctx.fillText('0, 1', q0.x, q0.y - 62);

    // q0 -> q1 on 0
    drawEdge(positions.q0, positions.q1, '0', edgeHighlighted('q0', 'q1'));

    // q1 -> q2 on 1
    drawEdge(positions.q1, positions.q2, '1', edgeHighlighted('q1', 'q2'));

    // Start arrow
    ctx.beginPath();
    ctx.moveTo(30, q0.y);
    ctx.lineTo(q0.x - 28, q0.y);
    ctx.strokeStyle = '#e2e8f0';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(q0.x - 26, q0.y);
    ctx.lineTo(q0.x - 34, q0.y - 5);
    ctx.lineTo(q0.x - 34, q0.y + 5);
    ctx.closePath();
    ctx.fillStyle = '#e2e8f0';
    ctx.fill();

    // Draw states
    nfa.states.forEach(s => {
      const p = positions[s];
      const isActive = activeStates.has(s);
      const isAcceptState = nfa.accept.has(s);
      const isAccepted = done && isActive && isAcceptState;

      // Glow
      if (isActive) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 30, 0, Math.PI * 2);
        ctx.fillStyle = isAccepted ? 'rgba(34,197,94,0.15)' : 'rgba(99,102,241,0.15)';
        ctx.fill();
      }

      // Circle
      ctx.beginPath();
      ctx.arc(p.x, p.y, 24, 0, Math.PI * 2);
      ctx.fillStyle = isAccepted ? '#065f46' : isActive ? '#312e81' : '#1e293b';
      ctx.fill();
      ctx.strokeStyle = isAccepted ? '#22c55e' : isActive ? '#6366f1' : '#475569';
      ctx.lineWidth = isActive ? 3 : 2;
      ctx.stroke();

      // Double circle for accept
      if (isAcceptState) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 19, 0, Math.PI * 2);
        ctx.strokeStyle = isAccepted ? '#22c55e' : isActive ? '#6366f1' : '#475569';
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }

      // Label
      ctx.font = 'bold 14px monospace';
      ctx.fillStyle = isActive ? '#fff' : '#94a3b8';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(s, p.x, p.y);

      // Dead indicator
      if (!isActive && done) {
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 24, 0, Math.PI * 2);
        ctx.strokeStyle = '#ef4444';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    });

    // Legend at bottom
    ctx.font = '11px system-ui';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    ctx.fillStyle = '#6366f1';
    ctx.fillText('\u25CF Active', 20, 240);
    ctx.fillStyle = '#22c55e';
    ctx.fillText('\u25CF Accepted', 100, 240);
    ctx.fillStyle = '#475569';
    ctx.fillText('\u25CB Inactive', 200, 240);
  }

  function drawEdge(from, to, label, highlighted) {
    const dx = to.x - from.x, dy = to.y - from.y;
    const len = Math.sqrt(dx * dx + dy * dy);
    const ux = dx / len, uy = dy / len;
    const sx = from.x + ux * 26, sy = from.y + uy * 26;
    const ex = to.x - ux * 26, ey = to.y - uy * 26;

    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(ex, ey);
    ctx.strokeStyle = highlighted ? '#f59e0b' : '#475569';
    ctx.lineWidth = highlighted ? 3 : 1.5;
    ctx.stroke();

    // Arrowhead
    ctx.beginPath();
    ctx.moveTo(ex, ey);
    ctx.lineTo(ex - ux * 8 - uy * 5, ey - uy * 8 + ux * 5);
    ctx.lineTo(ex - ux * 8 + uy * 5, ey - uy * 8 - ux * 5);
    ctx.closePath();
    ctx.fillStyle = highlighted ? '#f59e0b' : '#475569';
    ctx.fill();

    // Label
    const mx = (sx + ex) / 2, my = (sy + ey) / 2;
    ctx.font = 'bold 13px monospace';
    ctx.fillStyle = highlighted ? '#f59e0b' : '#94a3b8';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';
    ctx.fillText(label, mx, my - 10);
  }

  function edgeHighlighted(from, to) {
    return highlightEdges.some(e => e.from === from && e.to === to);
  }

  function updateInputDisplay() {
    const el = document.getElementById('s7InputDisplay');
    if (!inputStr) { el.innerHTML = ''; return; }
    let html = 'Input: ';
    for (let i = 0; i < inputStr.length; i++) {
      if (i < pos) html += '<span style="color:#475569;">' + inputStr[i] + '</span>';
      else if (i === pos) html += '<span style="color:#f59e0b; font-weight:bold; font-size:1.2em; text-decoration:underline;">' + inputStr[i] + '</span>';
      else html += '<span style="color:#e2e8f0;">' + inputStr[i] + '</span>';
    }
    el.innerHTML = html;
  }

  function logMsg(msg) {
    const log = document.getElementById('s7Log');
    log.innerHTML += '<div class="log-entry">' + msg + '</div>';
    log.scrollTop = log.scrollHeight;
  }

  function initSim() {
    const raw = document.getElementById('s7Input').value.trim();
    if (!/^[01]*$/.test(raw)) {
      document.getElementById('s7Verdict').innerHTML = '<div class="verdict reject">Only 0s and 1s allowed!</div>';
      return false;
    }
    inputStr = raw;
    pos = -1;
    activeStates = new Set(['q0']);
    done = false;
    highlightEdges = [];
    document.getElementById('s7Verdict').innerHTML = '';
    document.getElementById('s7Log').innerHTML = '<div class="log-entry log-new">Start: active = {q0}</div>';
    updateInputDisplay();
    drawNFA();
    updateStatus();
    return true;
  }

  function updateStatus() {
    const arr = [...activeStates].sort();
    document.getElementById('s7Active').textContent = '{' + arr.join(', ') + '}';
  }

  window.s7Step = function() {
    if (done) return;
    if (pos === -1 && inputStr === '') {
      if (!initSim()) return;
      if (inputStr.length === 0) { s7Finish(); return; }
      return;
    }
    if (inputStr === '') {
      if (!initSim()) return;
      if (inputStr.length === 0) { s7Finish(); return; }
      return;
    }

    pos++;
    if (pos >= inputStr.length) { s7Finish(); return; }

    const sym = inputStr[pos];
    const nextStates = new Set();
    highlightEdges = [];

    for (const s of activeStates) {
      const targets = nfa.delta[s][sym] || [];
      targets.forEach(t => {
        nextStates.add(t);
        highlightEdges.push({ from: s, to: t });
      });
      if (targets.includes(s)) {
        highlightEdges.push({ from: s, to: s });
      }
    }

    const prevStr = '{' + [...activeStates].sort().join(', ') + '}';
    activeStates = nextStates;
    const nextStr = '{' + [...activeStates].sort().join(', ') + '}';

    logMsg('<span class="log-highlight">Read \'' + sym + '\'</span>: ' + prevStr + ' &rarr; ' + nextStr);
    updateInputDisplay();
    updateStatus();
    drawNFA();

    if (pos === inputStr.length - 1) {
      setTimeout(() => s7Finish(), 100);
    }
  };

  window.s7Auto = function() {
    if (timer) return;
    if (inputStr === '' || pos === -1) {
      if (!initSim()) return;
    }
    timer = setInterval(() => {
      if (done) { clearInterval(timer); timer = null; return; }
      s7Step();
    }, 700);
  };

  window.s7Reset = function() {
    if (timer) { clearInterval(timer); timer = null; }
    inputStr = '';
    pos = -1;
    activeStates = new Set(['q0']);
    done = false;
    highlightEdges = [];
    document.getElementById('s7Verdict').innerHTML = '';
    document.getElementById('s7Input').value = '';
    document.getElementById('s7Log').innerHTML = 'Type a binary string and click Step...';
    document.getElementById('s7InputDisplay').innerHTML = '';
    updateStatus();
    drawNFA();
  };

  function s7Finish() {
    done = true;
    highlightEdges = [];
    const accepted = [...activeStates].some(s => nfa.accept.has(s));
    const stateStr = '{' + [...activeStates].sort().join(', ') + '}';
    const v = document.getElementById('s7Verdict');
    if (accepted) {
      v.innerHTML = '<div class="verdict accept">ACCEPTED! ' + stateStr + ' contains q2.</div>';
      logMsg('<span style="color:#4ade80; font-weight:bold;">ACCEPTED</span> &mdash; ' + stateStr + ' &cap; {q2} &ne; &empty;');
    } else {
      v.innerHTML = '<div class="verdict reject">REJECTED. ' + stateStr + ' has no accept state.</div>';
      logMsg('<span style="color:#f87171; font-weight:bold;">REJECTED</span> &mdash; ' + stateStr + ' &cap; {q2} = &empty;');
    }
    drawNFA();
  }

  const obs = new MutationObserver(() => {
    if (document.getElementById('s7').classList.contains('active')) drawNFA();
  });
  obs.observe(document.getElementById('s7'), { attributes: true, attributeFilter: ['class'] });
  drawNFA();
})();
</script>

<!-- ==================== s8: EXTENDED TRANSITION FUNCTION ==================== -->
<div class="slide" id="s8">
  <h1>Extended Transition Function</h1>
  <p class="subtitle">Extending &delta; from single symbols to entire strings</p>
  <div class="two-col">
    <div>
      <p>We need &delta;(q, a) for one symbol to become &delta;&#770;(q, w) for a whole string w.</p>
      <div class="key-idea">
        <h3>Inductive Definition</h3>
        <p><b>Base:</b> &delta;&#770;(q, &epsilon;) = {q}</p>
        <p style="color:#94a3b8; font-size:0.95em;">"Reading nothing from q, you're still at q."</p>
        <p style="margin-top:10px;"><b>Induction:</b> &delta;&#770;(q, wa) = &bigcup;<sub>p &isin; &delta;&#770;(q,w)</sub> &delta;(p, a)</p>
        <p style="color:#94a3b8; font-size:0.95em;">"Process w to get a set S. Then from each state in S, follow transition on symbol a. Union all results."</p>
      </div>
      <div class="code-block">
        <div class="code-content">
          <div class="line"><span style="color:#94a3b8;">// Worked example: &delta;&#770;(q0, "101")</span></div>
          <div class="line">Start:  &delta;&#770;(q0, &epsilon;)   = <span style="color:#38bdf8;">{q0}</span></div>
          <div class="line">Read 1: &delta;(q0, 1)       = <span style="color:#38bdf8;">{q0}</span></div>
          <div class="line">Read 0: &delta;(q0, 0)       = <span style="color:#38bdf8;">{q0, q1}</span></div>
          <div class="line">Read 1: &delta;(q0,1)&cup;&delta;(q1,1) = <span style="color:#4ade80;">{q0, q2}</span></div>
          <div class="line"><span style="color:#4ade80;">q2 &isin; F &rArr; ACCEPT!</span></div>
        </div>
      </div>
    </div>
    <div>
      <div class="analogy">
        <h3>Water in a Pipe Network</h3>
        <p>Pour water into the start state. At each input symbol, water flows through all matching transitions. It <b>spreads</b> to every reachable state simultaneously. After the last symbol, if water reached any accept state &mdash; accept!</p>
      </div>
      <h3>Language of an NFA</h3>
      <div class="key-idea">
        <p>A string w is <b>accepted</b> if:</p>
        <p style="font-family:monospace; font-size:1.1em; margin:8px 0; color:#38bdf8;">&delta;&#770;(q<sub>0</sub>, w) &cap; F &ne; &empty;</p>
        <p>"After reading w, the set of active states contains at least one accept state."</p>
        <p style="margin-top:10px;">The <b>language</b> L(N) = { w | &delta;&#770;(q<sub>0</sub>, w) &cap; F &ne; &empty; }</p>
      </div>
      <div class="warning">
        <h3>Remember</h3>
        <p>The NFA accepts if <b>any</b> path succeeds. It rejects only if <b>ALL</b> paths fail. One accepting branch out of millions is enough!</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ==================== s9: NFA = DFA IN POWER ==================== -->
<div class="slide" id="s9">
  <h1>NFAs and DFAs are Equivalent!</h1>
  <p class="subtitle">The most important theorem of this lecture</p>
  <div class="two-col">
    <div>
      <div class="key-idea">
        <h3>Theorem</h3>
        <p>For every NFA, there exists a DFA that accepts <b>exactly the same language</b>. And vice versa.</p>
      </div>
      <h3>Direction 1: DFA &rarr; NFA (trivial)</h3>
      <p>Every DFA is already an NFA! Just wrap each single next-state in a set:</p>
      <div class="code-block">
        <div class="code-content">
          <div class="line"><span style="color:#3b82f6;">DFA:</span>  &delta;<sub>D</sub>(q, a) = p      <span style="color:#64748b;">// single state</span></div>
          <div class="line"><span style="color:#8b5cf6;">NFA:</span>  &delta;<sub>N</sub>(q, a) = {p}    <span style="color:#64748b;">// set with one element</span></div>
          <div class="line" style="color:#94a3b8;">// Behaves identically &mdash; sets always have size 1</div>
        </div>
      </div>
    </div>
    <div>
      <h3>Direction 2: NFA &rarr; DFA (the hard part!)</h3>
      <p>This requires the <b>Subset Construction</b> &mdash; the central algorithm of this lecture.</p>
      <div class="warning">
        <h3>Exponential Blowup</h3>
        <p>If the NFA has <b>n</b> states, the equivalent DFA can have up to <b>2<sup>n</sup></b> states (one for each subset of NFA states).</p>
        <p style="margin-top:6px;">In practice, lazy construction usually finds far fewer reachable states. But the worst case is real!</p>
      </div>
      <div class="analogy">
        <h3>Why this matters</h3>
        <p>NFAs are a <b>design tool</b> &mdash; easier to create. DFAs are an <b>execution tool</b> &mdash; can actually run on a computer. The subset construction is the bridge between design and implementation.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ==================== s10: SUBSET CONSTRUCTION IDEA ==================== -->
<div class="slide" id="s10">
  <h1>Subset Construction: The Idea</h1>
  <p class="subtitle">Each DFA state represents a set of NFA states</p>
  <div class="two-col">
    <div>
      <div class="key-idea">
        <h3>Core Insight</h3>
        <p>An NFA can be in a <b>set</b> of states. A DFA must be in <b>one</b> state. Solution: make each DFA state <b>represent a set of NFA states</b>!</p>
      </div>
      <canvas id="cS10" width="440" height="200" style="width:100%;" class="canvas-wrap"></canvas>
      <p style="font-size:0.85em; color:#94a3b8; text-align:center;">NFA state set {q1, q3, q5} becomes ONE DFA state named "{q1,q3,q5}"</p>
    </div>
    <div>
      <h3>The Construction Recipe</h3>
      <p>Given NFA (Q, &Sigma;, &delta;<sub>N</sub>, q<sub>0</sub>, F), build DFA:</p>
      <table style="font-size:0.9em;">
        <tr><th>DFA Component</th><th>How to Build</th></tr>
        <tr><td style="text-align:left;">States</td><td style="text-align:left;">2<sup>Q</sup> = all subsets of Q</td></tr>
        <tr><td style="text-align:left;">Alphabet</td><td style="text-align:left;">Same &Sigma;</td></tr>
        <tr><td style="text-align:left;">Start state</td><td style="text-align:left;">{q<sub>0</sub>}</td></tr>
        <tr><td style="text-align:left;">Accept states</td><td style="text-align:left;">Any subset containing a member of F</td></tr>
        <tr><td style="text-align:left;">&delta;<sub>D</sub>(S, a)</td><td style="text-align:left;">&bigcup;<sub>q&isin;S</sub> &delta;<sub>N</sub>(q, a)</td></tr>
      </table>
      <div class="warning" style="margin-top:12px;">
        <h3>Critical Point</h3>
        <p>{p, q} is a <b>single DFA state</b> whose <b>name</b> happens to be a set. Don't confuse it with "being in two places" &mdash; the DFA is always in exactly one state.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas = document.getElementById('cS10');
  const ctx = canvas.getContext('2d');

  function draw() {
    ctx.clearRect(0, 0, 440, 200);

    // NFA side: three scattered circles
    ctx.font = '11px system-ui';
    ctx.fillStyle = '#94a3b8';
    ctx.textAlign = 'center';
    ctx.fillText('NFA states (multiple active)', 110, 18);

    const nfaStates = [{x:60,y:80,l:'q1'},{x:130,y:60,l:'q3'},{x:100,y:130,l:'q5'}];
    nfaStates.forEach(s => {
      ctx.beginPath();
      ctx.arc(s.x, s.y, 22, 0, Math.PI*2);
      ctx.fillStyle = '#312e81';
      ctx.fill();
      ctx.strokeStyle = '#6366f1';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.font = 'bold 12px monospace';
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(s.l, s.x, s.y);
    });

    // Dashed enclosure
    ctx.setLineDash([4,3]);
    ctx.strokeStyle = '#8b5cf6';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(97, 90, 75, 65, 0, 0, Math.PI*2);
    ctx.stroke();
    ctx.setLineDash([]);

    // Arrow
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(185, 90);
    ctx.lineTo(250, 90);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(250, 90);
    ctx.lineTo(242, 84);
    ctx.lineTo(242, 96);
    ctx.closePath();
    ctx.fillStyle = '#f59e0b';
    ctx.fill();

    ctx.font = 'bold 12px system-ui';
    ctx.fillStyle = '#f59e0b';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';
    ctx.fillText('becomes', 218, 82);

    // DFA side: one big circle
    ctx.font = '11px system-ui';
    ctx.fillStyle = '#94a3b8';
    ctx.fillText('ONE DFA state', 340, 18);

    ctx.beginPath();
    ctx.arc(340, 90, 45, 0, Math.PI*2);
    ctx.fillStyle = '#1e293b';
    ctx.fill();
    ctx.strokeStyle = '#22c55e';
    ctx.lineWidth = 3;
    ctx.stroke();

    ctx.font = 'bold 14px monospace';
    ctx.fillStyle = '#22c55e';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('{q1,q3,q5}', 340, 90);

    // Bottom note
    ctx.font = '12px system-ui';
    ctx.fillStyle = '#64748b';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';
    ctx.fillText('The set IS the name of one DFA state', 220, 185);
  }

  const obs = new MutationObserver(() => {
    if (document.getElementById('s10').classList.contains('active')) draw();
  });
  obs.observe(document.getElementById('s10'), {attributes:true, attributeFilter:['class']});
  draw();
})();
</script>

<!-- ==================== s11: CHESSBOARD SUBSET CONSTRUCTION STEP-THROUGH ==================== -->
<div class="slide" id="s11">
  <h1>Chessboard: Subset Construction</h1>
  <p class="subtitle">Watch the DFA being built step by step from the 9-state chessboard NFA</p>
  <div style="display:grid; grid-template-columns:1fr 1.2fr; gap:24px;">
    <div>
      <h3>NFA Reference</h3>
      <table style="font-size:0.78em;">
        <tr><th></th><th>r</th><th>b</th></tr>
        <tr><td>&rarr;1</td><td>5</td><td>2,4</td></tr>
        <tr><td>2</td><td>1,3,5</td><td>4,6</td></tr>
        <tr><td>3</td><td>5</td><td>2,6</td></tr>
        <tr><td>4</td><td>1,5,7</td><td>2,8</td></tr>
        <tr><td>5</td><td>1,3,7,9</td><td>2,4,6,8</td></tr>
        <tr><td>6</td><td>3,5,9</td><td>2,8</td></tr>
        <tr><td>7</td><td>5</td><td>4,8</td></tr>
        <tr><td>8</td><td>5,7,9</td><td>4,6</td></tr>
        <tr><td>*9</td><td>5</td><td>6,8</td></tr>
      </table>
      <div class="ctrl-row" style="margin-top:8px;">
        <button class="btn btn-sm" onclick="s11Step()">Step</button>
        <button class="btn btn-sm" onclick="s11Auto()">Auto</button>
        <button class="btn btn-sm btn-secondary" onclick="s11Reset()">Reset</button>
        <span style="color:#64748b; font-size:0.82em;" id="s11StepCount"></span>
      </div>
      <div class="log-panel" id="s11Log" style="margin-top:8px; max-height:110px;">
        Click Step to begin subset construction...
      </div>
    </div>
    <div>
      <h3>DFA Being Built</h3>
      <div style="overflow-x:auto;">
        <table style="font-size:0.78em;" id="s11Table">
          <thead><tr><th>DFA State</th><th>r</th><th>b</th></tr></thead>
          <tbody id="s11Body"></tbody>
        </table>
      </div>
      <div id="s11Done" style="display:none; margin-top:8px;"></div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  // Chessboard NFA
  const delta = {
    1:{r:[5],b:[2,4]}, 2:{r:[1,3,5],b:[4,6]}, 3:{r:[5],b:[2,6]},
    4:{r:[1,5,7],b:[2,8]}, 5:{r:[1,3,7,9],b:[2,4,6,8]}, 6:{r:[3,5,9],b:[2,8]},
    7:{r:[5],b:[4,8]}, 8:{r:[5,7,9],b:[4,6]}, 9:{r:[5],b:[6,8]}
  };
  const acceptNFA = new Set([9]);

  function setLabel(arr) {
    if (!arr || arr.length === 0) return '{}';
    return '{' + [...arr].sort((a,b)=>a-b).join(',') + '}';
  }

  // Precompute steps
  let steps = [];
  let dfaRows = {}; // label -> {r:'', b:''}

  function buildSteps() {
    steps = [];
    dfaRows = {};
    const seen = new Set();
    const queue = [];
    const start = [1];
    const startLabel = setLabel(start);
    seen.add(startLabel);
    queue.push(start);
    steps.push({type:'start', label:startLabel, isAccept: start.some(s=>acceptNFA.has(s))});

    while (queue.length > 0) {
      const subset = queue.shift();
      const fromLabel = setLabel(subset);
      dfaRows[fromLabel] = {r:'', b:''};

      for (const sym of ['r','b']) {
        const resultSet = new Set();
        const parts = [];
        for (const s of subset) {
          const targets = delta[s][sym] || [];
          parts.push('('+s+','+sym+')='+setLabel(targets));
          targets.forEach(t => resultSet.add(t));
        }
        const resultArr = [...resultSet].sort((a,b)=>a-b);
        const resultLabel = setLabel(resultArr);
        const isNew = !seen.has(resultLabel);
        const isAccept = resultArr.some(s => acceptNFA.has(s));

        dfaRows[fromLabel][sym] = resultLabel;
        steps.push({
          type:'transition', from:fromLabel, sym:sym,
          detail: parts.join('  '), result:resultLabel,
          isNew:isNew, isAccept:isAccept
        });

        if (isNew) {
          seen.add(resultLabel);
          queue.push(resultArr);
        }
      }
    }
    steps.push({type:'done'});
  }

  buildSteps();

  let stepIdx = 0;
  let timer = null;
  let tableRows = {}; // label -> row element

  function addRow(label, isAccept) {
    const tbody = document.getElementById('s11Body');
    const tr = document.createElement('tr');
    const isStart = label === '{1}';
    const prefix = (isStart?' ':'') + (isAccept?'* ':'');
    tr.innerHTML = '<td style="text-align:left;font-weight:600;">' + prefix + label + '</td><td id="s11c-'+label.replace(/[{},]/g,'_')+'-r"></td><td id="s11c-'+label.replace(/[{},]/g,'_')+'-b"></td>';
    tr.style.transition = 'background 0.3s';
    if (isAccept) tr.classList.add('highlight');
    tbody.appendChild(tr);
    tableRows[label] = tr;
  }

  function fillCell(fromLabel, sym, value) {
    const id = 's11c-' + fromLabel.replace(/[{},]/g,'_') + '-' + sym;
    const el = document.getElementById(id);
    if (el) el.textContent = value;
  }

  function logMsg(msg, cls) {
    const log = document.getElementById('s11Log');
    log.innerHTML += '<div class="log-entry ' + (cls||'') + '">' + msg + '</div>';
    log.scrollTop = log.scrollHeight;
  }

  window.s11Step = function() {
    if (stepIdx >= steps.length) return;
    const step = steps[stepIdx];
    stepIdx++;

    if (step.type === 'start') {
      addRow(step.label, step.isAccept);
      logMsg('Start: DFA start state = ' + step.label, 'log-new');
    } else if (step.type === 'transition') {
      fillCell(step.from, step.sym, step.result);
      if (step.isNew) addRow(step.result, step.isAccept);
      const tag = step.isNew ? (step.isAccept ? '<span style="color:#4ade80;">NEW </span>' : '<span style="color:#38bdf8;">NEW</span>') : '<span style="color:#64748b;">seen</span>';
      logMsg(step.from + ' on ' + step.sym + ': ' + step.result + ' ' + tag);
      // Highlight row being processed
      Object.values(tableRows).forEach(r => r.style.background = '');
      if (tableRows[step.from]) tableRows[step.from].style.background = 'rgba(99,102,241,0.1)';
    } else if (step.type === 'done') {
      Object.values(tableRows).forEach(r => r.style.background = '');
      const d = document.getElementById('s11Done');
      d.style.display = 'block';
      d.innerHTML = '<div class="key-idea"><h3>Done!</h3><p>Only <b>7 reachable DFA states</b> out of 2<sup>9</sup> = 512 possible. Accept states (containing 9): {1,3,7,9} and {1,3,5,7,9}.</p></div>';
      logMsg('<b>Algorithm complete!</b> No new states to explore.', 'log-new');
    }
    const total = steps.filter(s=>s.type==='transition').length;
    const done = steps.slice(0,stepIdx).filter(s=>s.type==='transition').length;
    document.getElementById('s11StepCount').textContent = 'Step ' + done + '/' + total;
  };

  window.s11Auto = function() {
    if (timer) return;
    timer = setInterval(() => {
      if (stepIdx >= steps.length) { clearInterval(timer); timer = null; return; }
      s11Step();
    }, 400);
  };

  window.s11Reset = function() {
    if (timer) { clearInterval(timer); timer = null; }
    stepIdx = 0;
    tableRows = {};
    document.getElementById('s11Body').innerHTML = '';
    document.getElementById('s11Done').style.display = 'none';
    document.getElementById('s11Log').innerHTML = 'Click Step to begin subset construction...';
    document.getElementById('s11StepCount').textContent = '';
  };

  const obs = new MutationObserver(() => {
    if (document.getElementById('s11').classList.contains('active')) {
      // Re-render if needed
    }
  });
  obs.observe(document.getElementById('s11'), {attributes:true, attributeFilter:['class']});
})();
</script>

<!-- ==================== sCA: CHALLENGE - DOES THIS NFA ACCEPT? ==================== -->
<div class="slide" id="sCA">
  <h1>Challenge: Does This NFA Accept?</h1>
  <p class="subtitle">Trace the computation and predict the result</p>
  <div class="two-col">
    <div>
      <div style="background:#1e293b; border:1px solid #334155; border-radius:12px; padding:20px;">
        <div style="font-size:0.95em; color:#94a3b8; margin-bottom:8px;" id="caScore">Question 1 of 3</div>
        <div id="caQuestion" style="font-size:1.1em; margin-bottom:14px;"></div>
        <div id="caButtons" style="text-align:center;"></div>
        <div id="caFeedback" style="display:none; margin-top:12px; padding:12px; border-radius:8px;"></div>
      </div>
    </div>
    <div>
      <div class="key-idea">
        <h3>How to Trace an NFA</h3>
        <ol>
          <li>Start with {start state}</li>
          <li>For each symbol, compute <b>union</b> of all transitions from all active states</li>
          <li>After the last symbol: does the set contain an <b>accept state</b>?</li>
        </ol>
      </div>
      <div id="caWalkthrough" style="margin-top:12px;"></div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  // NFA "ends with 01": q0 --0--> {q0,q1}, q0 --1--> {q0}, q1 --1--> {q2}
  const problems = [
    { str:'101', answer:true, trace:'Start: {q0}\nRead 1: (q0,1)={q0}  {q0}\nRead 0: (q0,0)={q0,q1}  {q0,q1}\nRead 1: (q0,1)(q1,1)={q0}{q2}  {q0,q2}\nq2  F  ACCEPT' },
    { str:'110', answer:false, trace:'Start: {q0}\nRead 1: {q0}\nRead 1: {q0}\nRead 0: {q0,q1}\nNo accept state  REJECT' },
    { str:'0001', answer:true, trace:'Start: {q0}\nRead 0: {q0,q1}\nRead 0: {q0,q1} (q1 dies on 0)\nRead 0: {q0,q1}\nRead 1: {q0}{q2} = {q0,q2}\nq2  F  ACCEPT' },
    { str:'10', answer:false, trace:'Start: {q0}\nRead 1: {q0}\nRead 0: {q0,q1}\n{q0,q1}  {q2} =   REJECT' },
    { str:'01', answer:true, trace:'Start: {q0}\nRead 0: {q0,q1}\nRead 1: {q0}{q2} = {q0,q2}\nq2  F  ACCEPT' },
    { str:'11', answer:false, trace:'Start: {q0}\nRead 1: {q0}\nRead 1: {q0}\n{q0}  {q2} =   REJECT' }
  ];

  let selected = [];
  let idx = 0;
  let score = 0;
  let answered = false;

  function shuffle(arr) { return arr.slice().sort(() => Math.random() - 0.5); }

  function init() {
    selected = shuffle(problems).slice(0, 3);
    idx = 0; score = 0; answered = false;
    render();
  }

  function render() {
    const p = selected[idx];
    document.getElementById('caScore').textContent = 'Question ' + (idx+1) + ' of 3  |  Score: ' + score + '/' + idx;
    document.getElementById('caQuestion').innerHTML = 'NFA for <b>"ends with 01"</b>: Does it accept <b>"' + p.str + '"</b>?';
    document.getElementById('caButtons').innerHTML =
      '<button class="btn btn-sm" id="caYes" onclick="caAnswer(true)" style="margin:4px;">YES &mdash; Accept</button>' +
      '<button class="btn btn-sm" id="caNo" onclick="caAnswer(false)" style="margin:4px;">NO &mdash; Reject</button>';
    document.getElementById('caFeedback').style.display = 'none';
    document.getElementById('caWalkthrough').innerHTML = '';
    answered = false;
  }

  window.caAnswer = function(guess) {
    if (answered) return;
    answered = true;
    const p = selected[idx];
    const correct = guess === p.answer;
    if (correct) score++;

    document.getElementById('caYes').disabled = true;
    document.getElementById('caNo').disabled = true;

    if (p.answer) {
      document.getElementById('caYes').style.borderColor = '#22c55e';
      if (!correct) document.getElementById('caNo').style.borderColor = '#ef4444';
    } else {
      document.getElementById('caNo').style.borderColor = '#22c55e';
      if (!correct) document.getElementById('caYes').style.borderColor = '#ef4444';
    }

    const fb = document.getElementById('caFeedback');
    fb.style.display = 'block';
    fb.style.background = correct ? 'rgba(34,197,94,0.12)' : 'rgba(239,68,68,0.12)';
    fb.style.borderLeft = '4px solid ' + (correct ? '#22c55e' : '#ef4444');
    fb.style.color = correct ? '#a7f3d0' : '#fecaca';
    fb.innerHTML = correct ? '<b>Correct!</b>' : '<b>Not quite.</b> Answer: ' + (p.answer ? 'ACCEPT' : 'REJECT');

    document.getElementById('caWalkthrough').innerHTML = '<div class="code-block"><div class="code-content" style="font-size:0.82em; white-space:pre-wrap;">' + p.trace + '</div></div>';
    document.getElementById('caScore').textContent = 'Question ' + (idx+1) + ' of 3  |  Score: ' + score + '/' + (idx+1);

    if (idx < 2) {
      setTimeout(() => { idx++; render(); }, 2800);
    } else {
      setTimeout(() => {
        document.getElementById('caScore').innerHTML = '<b>Final: ' + score + '/3</b>' +
          (score===3?'  Perfect!':score>=2?'  Well done!':'  Keep practicing!') +
          ' <button class="btn btn-sm btn-secondary" onclick="caInit()" style="margin-left:8px;">Retry</button>';
      }, 2800);
    }
  };

  window.caInit = init;

  const obs = new MutationObserver(() => {
    if (document.getElementById('sCA').classList.contains('active')) init();
  });
  obs.observe(document.getElementById('sCA'), {attributes:true, attributeFilter:['class']});
  init();
})();
</script>

<!-- ==================== s12: "ENDS WITH 01" SUBSET CONSTRUCTION ==================== -->
<div class="slide" id="s12">
  <h1>Subset Construction: "ends with 01"</h1>
  <p class="subtitle">Step through converting the 3-state NFA to a DFA</p>
  <div class="two-col">
    <div>
      <h3>NFA Reference</h3>
      <canvas id="cS12nfa" width="440" height="120" style="width:100%;" class="canvas-wrap"></canvas>
      <table style="font-size:0.85em; margin-top:8px;">
        <tr><th></th><th>0</th><th>1</th></tr>
        <tr><td>&rarr; q0</td><td>{q0, q1}</td><td>{q0}</td></tr>
        <tr><td>q1</td><td>{}</td><td>{q2}</td></tr>
        <tr><td>* q2</td><td>{}</td><td>{}</td></tr>
      </table>
      <div class="ctrl-row" style="margin-top:8px;">
        <button class="btn btn-sm" onclick="s12Step()">Step</button>
        <button class="btn btn-sm" onclick="s12Auto()">Auto</button>
        <button class="btn btn-sm btn-secondary" onclick="s12Reset()">Reset</button>
      </div>
    </div>
    <div>
      <h3>DFA Being Built</h3>
      <table style="font-size:0.88em;" id="s12Table">
        <thead><tr><th>DFA State</th><th>0</th><th>1</th></tr></thead>
        <tbody id="s12Body"></tbody>
      </table>
      <div class="log-panel" id="s12Log" style="margin-top:8px; max-height:120px;">
        Click Step to begin...
      </div>
      <div id="s12Done" style="display:none; margin-top:8px;"></div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  // Draw NFA reference on canvas
  const nfaCanvas = document.getElementById('cS12nfa');
  const nctx = nfaCanvas.getContext('2d');

  function drawNFARef() {
    nctx.clearRect(0, 0, 440, 120);
    const states = [{l:'q0',x:80,y:60},{l:'q1',x:220,y:60},{l:'q2',x:360,y:60}];

    // Edges
    // q0 self-loop
    nctx.beginPath();
    nctx.arc(80, 25, 16, 0.4, Math.PI-0.4);
    nctx.strokeStyle = '#475569'; nctx.lineWidth = 1.5; nctx.stroke();
    nctx.font = '11px monospace'; nctx.fillStyle = '#f59e0b'; nctx.textAlign = 'center';
    nctx.fillText('0, 1', 80, 8);

    // q0 -> q1
    nctx.beginPath(); nctx.moveTo(104,60); nctx.lineTo(194,60);
    nctx.strokeStyle = '#475569'; nctx.lineWidth = 1.5; nctx.stroke();
    nctx.beginPath(); nctx.moveTo(196,60); nctx.lineTo(190,55); nctx.lineTo(190,65); nctx.closePath();
    nctx.fillStyle = '#475569'; nctx.fill();
    nctx.fillStyle = '#f59e0b'; nctx.fillText('0', 150, 52);

    // q1 -> q2
    nctx.beginPath(); nctx.moveTo(244,60); nctx.lineTo(334,60);
    nctx.strokeStyle = '#475569'; nctx.stroke();
    nctx.beginPath(); nctx.moveTo(336,60); nctx.lineTo(330,55); nctx.lineTo(330,65); nctx.closePath();
    nctx.fillStyle = '#475569'; nctx.fill();
    nctx.fillStyle = '#f59e0b'; nctx.fillText('1', 290, 52);

    // Start arrow
    nctx.beginPath(); nctx.moveTo(25,60); nctx.lineTo(56,60);
    nctx.strokeStyle = '#e2e8f0'; nctx.lineWidth = 2; nctx.stroke();
    nctx.beginPath(); nctx.moveTo(58,60); nctx.lineTo(52,55); nctx.lineTo(52,65); nctx.closePath();
    nctx.fillStyle = '#e2e8f0'; nctx.fill();

    // States
    states.forEach(s => {
      nctx.beginPath(); nctx.arc(s.x, s.y, 22, 0, Math.PI*2);
      nctx.fillStyle = '#1e293b'; nctx.fill();
      nctx.strokeStyle = '#6366f1'; nctx.lineWidth = 2; nctx.stroke();
      if (s.l === 'q2') {
        nctx.beginPath(); nctx.arc(s.x, s.y, 17, 0, Math.PI*2);
        nctx.strokeStyle = '#6366f1'; nctx.lineWidth = 1.5; nctx.stroke();
      }
      nctx.font = 'bold 13px monospace'; nctx.fillStyle = '#e2e8f0';
      nctx.textAlign = 'center'; nctx.textBaseline = 'middle';
      nctx.fillText(s.l, s.x, s.y);
    });
  }

  // Subset construction for "ends with 01"
  const nfaDelta = {
    q0: {'0':['q0','q1'], '1':['q0']},
    q1: {'0':[], '1':['q2']},
    q2: {'0':[], '1':[]}
  };
  const acceptNFA = new Set(['q2']);

  function sLabel(arr) {
    if (!arr || arr.length===0) return '{}';
    return '{'+[...arr].sort().join(',')+'}';
  }

  let scSteps = [];
  function buildSC() {
    scSteps = [];
    const seen = new Set();
    const queue = [];
    const start = ['q0'];
    seen.add(sLabel(start));
    queue.push(start);
    scSteps.push({type:'start', label:sLabel(start), isAccept:false});

    while (queue.length) {
      const subset = queue.shift();
      const fromLabel = sLabel(subset);
      for (const sym of ['0','1']) {
        const result = new Set();
        const parts = [];
        subset.forEach(s => {
          const t = nfaDelta[s][sym]||[];
          parts.push('('+s+','+sym+')='+sLabel(t));
          t.forEach(x => result.add(x));
        });
        const rArr = [...result].sort();
        const rLabel = sLabel(rArr);
        const isNew = !seen.has(rLabel);
        const isAccept = rArr.some(s => acceptNFA.has(s));
        scSteps.push({type:'trans', from:fromLabel, sym:sym, detail:parts.join('  '), result:rLabel, isNew:isNew, isAccept:isAccept});
        if (isNew) { seen.add(rLabel); queue.push(rArr); }
      }
    }
    scSteps.push({type:'done'});
  }
  buildSC();

  let si = 0, tmr = null;
  let rows = {};

  function addRow(label, isAccept) {
    const tbody = document.getElementById('s12Body');
    const tr = document.createElement('tr');
    const isStart = label === '{q0}';
    const prefix = (isStart?' ':'')+(isAccept?'* ':'');
    tr.innerHTML = '<td style="text-align:left;font-weight:600;">'+prefix+label+'</td><td id="s12c-'+label.replace(/[{},]/g,'_')+'-0"></td><td id="s12c-'+label.replace(/[{},]/g,'_')+'-1"></td>';
    if (isAccept) tr.classList.add('highlight');
    tbody.appendChild(tr);
    rows[label] = tr;
  }

  function fillC(from, sym, val) {
    const id = 's12c-'+from.replace(/[{},]/g,'_')+'-'+sym;
    const el = document.getElementById(id);
    if (el) el.textContent = val;
  }

  function log(msg, cls) {
    const el = document.getElementById('s12Log');
    el.innerHTML += '<div class="log-entry '+(cls||'')+'">'+msg+'</div>';
    el.scrollTop = el.scrollHeight;
  }

  window.s12Step = function() {
    if (si >= scSteps.length) return;
    const step = scSteps[si]; si++;
    if (step.type==='start') {
      addRow(step.label, step.isAccept);
      log('Start: {q0}', 'log-new');
    } else if (step.type==='trans') {
      fillC(step.from, step.sym, step.result);
      if (step.isNew) addRow(step.result, step.isAccept);
      const tag = step.isNew ? '<span style="color:#38bdf8;">NEW</span>' : '<span style="color:#64748b;">seen</span>';
      log(step.from+' on '+step.sym+': '+step.detail+' = '+step.result+' '+tag);
      Object.values(rows).forEach(r=>r.style.background='');
      if (rows[step.from]) rows[step.from].style.background='rgba(99,102,241,0.1)';
    } else {
      Object.values(rows).forEach(r=>r.style.background='');
      document.getElementById('s12Done').style.display='block';
      document.getElementById('s12Done').innerHTML='<div class="key-idea"><h3>Result</h3><p>Only <b>3 DFA states</b> (out of 2=8 possible). {q0,q2} is the accept state. The empty set and unreachable subsets were never created!</p></div>';
      log('<b>Done!</b> Lazy construction found only reachable states.','log-new');
    }
  };

  window.s12Auto = function() {
    if (tmr) return;
    tmr = setInterval(() => {
      if (si >= scSteps.length) { clearInterval(tmr); tmr=null; return; }
      s12Step();
    }, 600);
  };

  window.s12Reset = function() {
    if (tmr) { clearInterval(tmr); tmr=null; }
    si=0; rows={};
    document.getElementById('s12Body').innerHTML='';
    document.getElementById('s12Done').style.display='none';
    document.getElementById('s12Log').innerHTML='Click Step to begin...';
  };

  const obs = new MutationObserver(() => {
    if (document.getElementById('s12').classList.contains('active')) drawNFARef();
  });
  obs.observe(document.getElementById('s12'), {attributes:true, attributeFilter:['class']});
  drawNFARef();
})();
</script>

<!-- ==================== s13: INTERACTIVE SUBSET CONSTRUCTION VISUALIZER ==================== -->
<div class="slide" id="s13">
  <h1>Visualizer: Subset Construction</h1>
  <p class="subtitle">Watch the DFA graph form as states are discovered</p>
  <div class="two-col">
    <div>
      <canvas id="cS13" width="460" height="340" style="width:100%;" class="canvas-wrap"></canvas>
    </div>
    <div>
      <h3>"ends with 01" &mdash; NFA &rarr; DFA</h3>
      <div class="ctrl-row">
        <button class="btn btn-sm" onclick="s13Step()">Step</button>
        <button class="btn btn-sm" onclick="s13Auto()">Auto</button>
        <button class="btn btn-sm btn-secondary" onclick="s13Reset()">Reset</button>
        <span style="color:#64748b; font-size:0.82em;" id="s13Info"></span>
      </div>
      <div class="log-panel" id="s13Log" style="max-height:160px; margin-top:8px;">
        Click Step to watch the DFA graph being built...
      </div>
      <div id="s13Result" style="display:none; margin-top:8px;"></div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas = document.getElementById('cS13');
  const ctx = canvas.getContext('2d');

  const nfaDelta = {
    q0:{'0':['q0','q1'],'1':['q0']},
    q1:{'0':[],'1':['q2']},
    q2:{'0':[],'1':[]}
  };
  const acceptNFA = new Set(['q2']);

  function sLabel(arr) {
    if (!arr||arr.length===0) return '{}';
    return '{'+[...arr].sort().join(',')+'}';
  }

  // DFA node positions
  const nodePos = {
    '{q0}':     {x:100, y:100},
    '{q0,q1}':  {x:300, y:60},
    '{q0,q2}':  {x:300, y:220}
  };

  // Precompute all steps
  let steps = [];
  let discoveredNodes = new Set();
  let edges = []; // {from, to, sym}

  function buildSteps() {
    steps = []; discoveredNodes = new Set(); edges = [];
    const seen = new Set();
    const queue = [];
    const start = ['q0'];
    const startLabel = sLabel(start);
    seen.add(startLabel);
    queue.push(start);
    steps.push({type:'node', label:startLabel, isAccept:false});

    while (queue.length) {
      const subset = queue.shift();
      const fromLabel = sLabel(subset);
      for (const sym of ['0','1']) {
        const result = new Set();
        subset.forEach(s => (nfaDelta[s][sym]||[]).forEach(t=>result.add(t)));
        const rArr = [...result].sort();
        const rLabel = sLabel(rArr);
        const isNew = !seen.has(rLabel);
        const isAccept = rArr.some(s=>acceptNFA.has(s));
        if (isNew) {
          steps.push({type:'node', label:rLabel, isAccept:isAccept});
          seen.add(rLabel);
          queue.push(rArr);
        }
        steps.push({type:'edge', from:fromLabel, to:rLabel, sym:sym});
      }
    }
    steps.push({type:'done'});
  }
  buildSteps();

  let si = 0, tmr = null;
  let visNodes = new Set();
  let visEdges = [];
  let latestEdge = null;

  function drawGraph() {
    ctx.clearRect(0, 0, 460, 340);

    // Title
    ctx.font = '12px system-ui';
    ctx.fillStyle = '#64748b';
    ctx.textAlign = 'center';
    ctx.fillText('DFA Graph (subset construction)', 230, 18);

    // Draw edges
    visEdges.forEach((e, ei) => {
      const from = nodePos[e.from], to = nodePos[e.to];
      if (!from || !to) return;
      const isLatest = latestEdge && latestEdge.from===e.from && latestEdge.to===e.to && latestEdge.sym===e.sym;

      if (e.from === e.to) {
        // Self-loop
        const cx = from.x, cy = from.y - 40;
        ctx.beginPath();
        ctx.arc(cx, cy, 18, 0.3, Math.PI-0.3);
        ctx.strokeStyle = isLatest ? '#f59e0b' : '#475569';
        ctx.lineWidth = isLatest ? 3 : 1.5;
        ctx.stroke();
        ctx.font = '11px monospace';
        ctx.fillStyle = isLatest ? '#f59e0b' : '#94a3b8';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'alphabetic';
        // Collect all self-loop symbols
        const selfSyms = visEdges.filter(x=>x.from===e.from&&x.to===e.to).map(x=>x.sym);
        ctx.fillText(selfSyms.join(','), cx, cy-20);
        return;
      }

      const dx = to.x-from.x, dy = to.y-from.y;
      const len = Math.sqrt(dx*dx+dy*dy);
      const ux = dx/len, uy = dy/len;

      // Check if there's a reverse edge
      const hasReverse = visEdges.some(x=>x.from===e.to && x.to===e.from);
      const offset = hasReverse ? 8 : 0;
      const px = -uy * offset, py = ux * offset;

      const sx = from.x + ux*28 + px, sy = from.y + uy*28 + py;
      const ex = to.x - ux*28 + px, ey = to.y - uy*28 + py;

      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(ex, ey);
      ctx.strokeStyle = isLatest ? '#f59e0b' : '#475569';
      ctx.lineWidth = isLatest ? 3 : 1.5;
      ctx.stroke();

      // Arrowhead
      ctx.beginPath();
      ctx.moveTo(ex, ey);
      ctx.lineTo(ex-ux*8-uy*5, ey-uy*8+ux*5);
      ctx.lineTo(ex-ux*8+uy*5, ey-uy*8-ux*5);
      ctx.closePath();
      ctx.fillStyle = isLatest ? '#f59e0b' : '#475569';
      ctx.fill();

      // Label
      const mx = (sx+ex)/2 + px*0.5, my = (sy+ey)/2 + py*0.5;
      ctx.font = 'bold 12px monospace';
      ctx.fillStyle = isLatest ? '#f59e0b' : '#94a3b8';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(e.sym, mx - uy*12, my + ux*12);
    });

    // Draw nodes
    visNodes.forEach(label => {
      const p = nodePos[label];
      if (!p) return;
      const isAccept = label === '{q0,q2}';

      // Glow for latest
      ctx.beginPath();
      ctx.arc(p.x, p.y, 26, 0, Math.PI*2);
      ctx.fillStyle = '#1e293b';
      ctx.fill();
      ctx.strokeStyle = isAccept ? '#22c55e' : '#6366f1';
      ctx.lineWidth = 3;
      ctx.stroke();

      if (isAccept) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 21, 0, Math.PI*2);
        ctx.strokeStyle = '#22c55e';
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }

      ctx.font = 'bold 11px monospace';
      ctx.fillStyle = isAccept ? '#4ade80' : '#e2e8f0';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(label, p.x, p.y);
    });

    // Start arrow
    if (visNodes.has('{q0}')) {
      const p = nodePos['{q0}'];
      ctx.beginPath();
      ctx.moveTo(p.x-60, p.y);
      ctx.lineTo(p.x-30, p.y);
      ctx.strokeStyle = '#e2e8f0';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(p.x-28, p.y);
      ctx.lineTo(p.x-36, p.y-5);
      ctx.lineTo(p.x-36, p.y+5);
      ctx.closePath();
      ctx.fillStyle = '#e2e8f0';
      ctx.fill();
      ctx.font = '11px system-ui';
      ctx.fillStyle = '#94a3b8';
      ctx.textAlign = 'center';
      ctx.fillText('start', p.x-45, p.y-12);
    }

    // Accept label
    if (visNodes.has('{q0,q2}')) {
      const p = nodePos['{q0,q2}'];
      ctx.font = '10px system-ui';
      ctx.fillStyle = '#4ade80';
      ctx.textAlign = 'center';
      ctx.fillText('accept', p.x, p.y+38);
    }
  }

  function logMsg(msg, cls) {
    const el = document.getElementById('s13Log');
    el.innerHTML += '<div class="log-entry '+(cls||'')+'">'+msg+'</div>';
    el.scrollTop = el.scrollHeight;
  }

  window.s13Step = function() {
    if (si >= steps.length) return;
    const step = steps[si]; si++;
    latestEdge = null;

    if (step.type==='node') {
      visNodes.add(step.label);
      logMsg('Discovered state: <span style="color:#38bdf8;">'+step.label+'</span>' + (step.isAccept?' <span style="color:#4ade80;"> ACCEPT</span>':''), 'log-new');
    } else if (step.type==='edge') {
      // Avoid duplicate self-loop labels
      const dup = visEdges.find(e=>e.from===step.from&&e.to===step.to&&e.sym===step.sym);
      if (!dup) visEdges.push({from:step.from, to:step.to, sym:step.sym});
      latestEdge = step;
      logMsg(step.from+' --<span style="color:#f59e0b;">'+step.sym+'</span>--> '+step.to);
    } else {
      document.getElementById('s13Result').style.display='block';
      document.getElementById('s13Result').innerHTML='<div class="key-idea"><h3>Complete!</h3><p>3 DFA states, 6 transitions. Accept state {q0,q2} handles strings ending in "01".</p></div>';
      logMsg('<b>Construction complete!</b>','log-new');
    }
    document.getElementById('s13Info').textContent = 'Nodes: '+visNodes.size+' | Edges: '+visEdges.length;
    drawGraph();
  };

  window.s13Auto = function() {
    if (tmr) return;
    tmr = setInterval(() => {
      if (si>=steps.length) { clearInterval(tmr); tmr=null; return; }
      s13Step();
    }, 600);
  };

  window.s13Reset = function() {
    if (tmr) { clearInterval(tmr); tmr=null; }
    si=0; visNodes=new Set(); visEdges=[]; latestEdge=null;
    document.getElementById('s13Log').innerHTML='Click Step to watch the DFA graph being built...';
    document.getElementById('s13Info').textContent='';
    document.getElementById('s13Result').style.display='none';
    drawGraph();
  };

  const obs = new MutationObserver(() => {
    if (document.getElementById('s13').classList.contains('active')) drawGraph();
  });
  obs.observe(document.getElementById('s13'), {attributes:true, attributeFilter:['class']});
  drawGraph();
})();
</script>

<!-- ==================== sCB: CHALLENGE - BUILD SUBSET CONSTRUCTION ==================== -->
<div class="slide" id="sCB">
  <h1>Challenge: Build the Subset Construction</h1>
  <p class="subtitle">Fill in the DFA transition table from this NFA</p>
  <div class="two-col">
    <div>
      <h3>NFA (accepts strings ending with "ab")</h3>
      <div class="code-block">
        <div class="code-content" style="font-size:0.9em;">
          <div class="line">States: {q0, q1, q2} | Start: q0 | Accept: {q2}</div>
          <div class="line">q0 --a--> {q0, q1}   q0 --b--> {q0}</div>
          <div class="line">q1 --a--> {}          q1 --b--> {q2}</div>
          <div class="line">q2 --a--> {}          q2 --b--> {}</div>
        </div>
      </div>
      <table style="font-size:0.88em;">
        <tr><th></th><th>a</th><th>b</th></tr>
        <tr><td>&rarr; q0</td><td>{q0, q1}</td><td>{q0}</td></tr>
        <tr><td>q1</td><td>{}</td><td>{q2}</td></tr>
        <tr><td>* q2</td><td>{}</td><td>{}</td></tr>
      </table>
    </div>
    <div>
      <h3>Fill in the DFA table</h3>
      <p style="font-size:0.88em; color:#94a3b8; margin-bottom:10px;">Click each <span style="color:#64748b;">?</span> cell and select the correct state set.</p>
      <div id="cbGrid"></div>
      <div class="ctrl-row" style="margin-top:10px;">
        <button class="btn btn-sm" onclick="cbCheck()">Check Answers</button>
        <button class="btn btn-sm btn-secondary" onclick="cbReset()">Reset</button>
      </div>
      <div id="cbFeedback" style="display:none; margin-top:10px; padding:12px; border-radius:8px;"></div>
    </div>
  </div>
  <!-- State Picker Modal -->
  <div id="cbOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:199;" onclick="cbPickerCancel()"></div>
  <div id="cbPicker" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#1e293b; border:2px solid #6366f1; border-radius:16px; padding:24px; z-index:200; min-width:280px;">
    <h3 style="text-align:center; margin-bottom:12px;">Select states in this set</h3>
    <div id="cbPickerOpts" style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-bottom:16px;"></div>
    <div style="display:flex; gap:12px; justify-content:center;">
      <button class="btn btn-sm" onclick="cbPickerConfirm()">Confirm</button>
      <button class="btn btn-sm btn-secondary" onclick="cbPickerCancel()">Cancel</button>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  // Correct DFA for "ends with ab"
  // {q0}: a->{q0,q1}, b->{q0}
  // {q0,q1}: a->{q0,q1}, b->{q0,q2}
  // *{q0,q2}: a->{q0,q1}, b->{q0}
  const answer = [
    {state:'{q0}', a:'{q0,q1}', b:'{q0}', accept:false, start:true},
    {state:'{q0,q1}', a:'{q0,q1}', b:'{q0,q2}', accept:false, start:false},
    {state:'{q0,q2}', a:'{q0,q1}', b:'{q0}', accept:true, start:false}
  ];

  let cells = {};
  let pickerCb = null;

  function init() {
    cells = {};
    const grid = document.getElementById('cbGrid');
    let html = '<table style="font-size:0.88em;"><tr><th>DFA State</th><th>a</th><th>b</th></tr>';
    answer.forEach((row, ri) => {
      const prefix = (row.start?' ':'')+(row.accept?'* ':'');
      html += '<tr><td style="text-align:left; font-weight:600;">'+prefix+row.state+'</td>';
      ['a','b'].forEach((col, ci) => {
        const id = ri+'-'+ci;
        html += '<td id="cb-'+id+'" style="cursor:pointer; color:#64748b; min-width:80px;" onclick="cbCellClick(\''+id+'\')">?</td>';
        cells[id] = {value:null, correct:row[col]};
      });
      html += '</tr>';
    });
    html += '</table>';
    grid.innerHTML = html;
    document.getElementById('cbFeedback').style.display = 'none';
  }

  window.cbCellClick = function(id) {
    const allStates = ['q0','q1','q2'];
    pickerCb = function(selected) {
      const label = selected.length===0 ? '{}' : '{'+selected.sort().join(',')+'}';
      const el = document.getElementById('cb-'+id);
      el.textContent = label;
      el.style.color = '#e2e8f0';
      cells[id].value = label;
    };
    // Show picker
    const opts = document.getElementById('cbPickerOpts');
    opts.innerHTML = '';
    allStates.forEach(s => {
      const btn = document.createElement('button');
      btn.textContent = s;
      btn.style.cssText = 'padding:8px 16px; border-radius:20px; border:2px solid #475569; background:#0f172a; color:#e2e8f0; cursor:pointer; font-family:monospace; font-size:1em;';
      btn.onclick = () => {
        btn.style.borderColor = btn.style.borderColor==='rgb(99, 102, 241)' ? '#475569' : '#6366f1';
        btn.style.background = btn.style.borderColor==='rgb(99, 102, 241)' ? '#1e3a5f' : '#0f172a';
        btn.dataset.sel = btn.dataset.sel==='1' ? '0' : '1';
      };
      btn.dataset.sel = '0';
      opts.appendChild(btn);
    });
    document.getElementById('cbPicker').style.display = 'block';
    document.getElementById('cbOverlay').style.display = 'block';
  };

  window.cbPickerConfirm = function() {
    const selected = [];
    document.querySelectorAll('#cbPickerOpts button').forEach(b => {
      if (b.dataset.sel==='1') selected.push(b.textContent);
    });
    document.getElementById('cbPicker').style.display = 'none';
    document.getElementById('cbOverlay').style.display = 'none';
    if (pickerCb) pickerCb(selected);
  };

  window.cbPickerCancel = function() {
    document.getElementById('cbPicker').style.display = 'none';
    document.getElementById('cbOverlay').style.display = 'none';
  };

  window.cbCheck = function() {
    let allCorrect = true, filled = 0;
    for (const id in cells) {
      const c = cells[id];
      const el = document.getElementById('cb-'+id);
      if (!c.value) {
        el.style.background = 'rgba(239,68,68,0.15)';
        allCorrect = false;
        continue;
      }
      filled++;
      if (c.value === c.correct) {
        el.style.background = 'rgba(34,197,94,0.15)';
        el.style.color = '#4ade80';
      } else {
        el.style.background = 'rgba(239,68,68,0.15)';
        el.style.color = '#f87171';
        allCorrect = false;
      }
    }
    const fb = document.getElementById('cbFeedback');
    fb.style.display = 'block';
    if (filled < 6) {
      fb.style.background = 'rgba(239,68,68,0.1)';
      fb.style.borderLeft = '4px solid #ef4444';
      fb.innerHTML = '<span style="color:#fecaca;">Fill in all cells first!</span>';
    } else if (allCorrect) {
      fb.style.background = 'rgba(34,197,94,0.1)';
      fb.style.borderLeft = '4px solid #22c55e';
      fb.innerHTML = '<span style="color:#a7f3d0;"><b>Perfect!</b> The DFA has 3 reachable states out of 2=8 possible. {q0,q2} is the accept state.</span>';
    } else {
      fb.style.background = 'rgba(239,68,68,0.1)';
      fb.style.borderLeft = '4px solid #ef4444';
      fb.innerHTML = '<span style="color:#fecaca;"><b>Some cells are incorrect.</b> Remember: <sub>D</sub>(S, a) = <sub>qS</sub> <sub>N</sub>(q, a). Click cells to fix.</span>';
    }
  };

  window.cbReset = function() { init(); };

  const obs = new MutationObserver(() => {
    if (document.getElementById('sCB').classList.contains('active')) init();
  });
  obs.observe(document.getElementById('sCB'), {attributes:true, attributeFilter:['class']});
  init();
})();
</script>

<!-- ==================== s14: PROOF SKETCH ==================== -->
<div class="slide" id="s14">
  <h1>Why Does Subset Construction Work?</h1>
  <p class="subtitle">Proof by induction on string length</p>
  <div class="two-col">
    <div>
      <div class="key-idea">
        <h3>What We Need to Show</h3>
        <p>For any string w:</p>
        <p style="font-family:monospace; font-size:1.05em; margin:8px 0; color:#38bdf8;">&delta;&#770;<sub>N</sub>(q<sub>0</sub>, w) = &delta;&#770;<sub>D</sub>({q<sub>0</sub>}, w)</p>
        <p style="color:#94a3b8;">"The set of NFA states after reading w equals the DFA state (named by that set) after reading w."</p>
      </div>
      <h3>Base Case: w = &epsilon;</h3>
      <div class="code-block">
        <div class="code-content" style="font-size:0.95em;">
          <div class="line">&delta;&#770;<sub>N</sub>(q<sub>0</sub>, &epsilon;) = {q<sub>0</sub>}</div>
          <div class="line">&delta;&#770;<sub>D</sub>({q<sub>0</sub>}, &epsilon;) = {q<sub>0</sub>}</div>
          <div class="line" style="color:#4ade80;">Both just stay at the start. &#10003;</div>
        </div>
      </div>
    </div>
    <div>
      <h3>Inductive Step: w = xa</h3>
      <p>Assume it works for x. Let S = &delta;&#770;<sub>N</sub>(q<sub>0</sub>, x) = &delta;&#770;<sub>D</sub>({q<sub>0</sub>}, x).</p>
      <div class="code-block">
        <div class="code-content" style="font-size:0.92em;">
          <div class="line"><span style="color:#8b5cf6;">NFA side:</span></div>
          <div class="line">  &delta;&#770;<sub>N</sub>(q<sub>0</sub>, xa) = &bigcup;<sub>p&isin;S</sub> &delta;<sub>N</sub>(p, a)</div>
          <div class="line"></div>
          <div class="line"><span style="color:#3b82f6;">DFA side:</span></div>
          <div class="line">  &delta;&#770;<sub>D</sub>({q<sub>0</sub>}, xa) = &delta;<sub>D</sub>(S, a)</div>
          <div class="line">                    = &bigcup;<sub>p&isin;S</sub> &delta;<sub>N</sub>(p, a)</div>
          <div class="line"></div>
          <div class="line" style="color:#4ade80;">Same computation! &#10003;</div>
        </div>
      </div>
      <div class="analogy">
        <h3>In Plain English</h3>
        <p>The DFA state after reading w literally <b>IS</b> the set of all NFA states after reading w. The DFA's transition function was <b>defined</b> to make this true. So of course it works &mdash; it's almost a tautology!</p>
        <p style="margin-top:6px; color:#94a3b8; font-size:0.9em;">Ullman calls this proof "almost a pun."</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ==================== s15: EPSILON-NFA INTRO ==================== -->
<div class="slide" id="s15">
  <h1>&epsilon;-NFA: Adding Free Transitions</h1>
  <p class="subtitle">Transitions that consume no input &mdash; "teleportation"</p>
  <div class="two-col">
    <div>
      <canvas id="cS15" width="460" height="300" style="width:100%;" class="canvas-wrap"></canvas>
      <p style="font-size:0.82em; color:#94a3b8; text-align:center; margin-top:4px;">
        Solid = real transitions &nbsp;|&nbsp; <span style="color:#a78bfa;">Dashed purple = &epsilon; (free moves)</span>
      </p>
    </div>
    <div>
      <div class="key-idea">
        <h3>&epsilon;-transitions</h3>
        <p>An &epsilon;-transition lets the automaton move between states <b>without reading any input</b>. It's a free, spontaneous move.</p>
      </div>
      <div class="analogy">
        <h3>Secret Passages</h3>
        <p>Think of &epsilon;-transitions as <b>secret passages</b> in a maze. You can walk through them anytime without using a key (input symbol). They're hidden shortcuts between rooms.</p>
      </div>
      <table style="font-size:0.82em;">
        <tr><th></th><th>0</th><th>1</th><th>&epsilon;</th></tr>
        <tr><td>&rarr; A</td><td>{E}</td><td>{B}</td><td>&empty;</td></tr>
        <tr><td>B</td><td>&empty;</td><td>{C}</td><td>{D}</td></tr>
        <tr><td>C</td><td>&empty;</td><td>{D}</td><td>&empty;</td></tr>
        <tr><td>* D</td><td>&empty;</td><td>&empty;</td><td>&empty;</td></tr>
        <tr><td>E</td><td>{F}</td><td>&empty;</td><td>{B, C}</td></tr>
        <tr><td>F</td><td>{D}</td><td>&empty;</td><td>&empty;</td></tr>
      </table>
      <div class="warning" style="margin-top:8px;">
        <h3>Still only regular languages!</h3>
        <p>&epsilon;-NFAs are a convenience, not extra power. They recognize exactly the same languages as DFAs and NFAs.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas = document.getElementById('cS15');
  const ctx = canvas.getContext('2d');

  const states = {
    A:{x:60,y:80}, B:{x:200,y:80}, C:{x:340,y:80},
    E:{x:60,y:220}, F:{x:200,y:220}, D:{x:340,y:220}
  };
  const accept = new Set(['D']);

  // Edges: {from,to,label,eps}
  const edges = [
    {from:'A',to:'B',label:'1',eps:false},
    {from:'A',to:'E',label:'0',eps:false},
    {from:'B',to:'C',label:'1',eps:false},
    {from:'B',to:'D',label:'',eps:true},
    {from:'C',to:'D',label:'1',eps:false},
    {from:'E',to:'F',label:'0',eps:false},
    {from:'E',to:'B',label:'',eps:true},
    {from:'E',to:'C',label:'',eps:true},
    {from:'F',to:'D',label:'0',eps:false}
  ];

  function draw() {
    ctx.clearRect(0, 0, 460, 300);

    // Draw edges
    edges.forEach(e => {
      const p1 = states[e.from], p2 = states[e.to];
      const dx = p2.x-p1.x, dy = p2.y-p1.y;
      const len = Math.sqrt(dx*dx+dy*dy);
      const ux = dx/len, uy = dy/len;
      const sx = p1.x+ux*24, sy = p1.y+uy*24;
      const ex = p2.x-ux*24, ey = p2.y-uy*24;

      // Offset for parallel edges
      let ox = 0, oy = 0;
      const parallel = edges.filter(x => (x.from===e.from&&x.to===e.to)||(x.from===e.to&&x.to===e.from));
      if (parallel.length > 1) { ox = -uy*6; oy = ux*6; }

      ctx.beginPath();
      if (e.eps) {
        ctx.setLineDash([5,4]);
        ctx.strokeStyle = '#a78bfa';
      } else {
        ctx.setLineDash([]);
        ctx.strokeStyle = '#475569';
      }
      ctx.lineWidth = 2;

      // Use quadratic curve for longer diagonal edges
      if (Math.abs(dx)>100 && Math.abs(dy)>100) {
        const mx = (p1.x+p2.x)/2, my = (p1.y+p2.y)/2;
        ctx.moveTo(sx+ox, sy+oy);
        ctx.quadraticCurveTo(mx+ox*3, my+oy*3-20, ex+ox, ey+oy);
      } else {
        ctx.moveTo(sx+ox, sy+oy);
        ctx.lineTo(ex+ox, ey+oy);
      }
      ctx.stroke();
      ctx.setLineDash([]);

      // Arrowhead
      const adx = ex+ox-(sx+ox), ady = ey+oy-(sy+oy);
      const alen = Math.sqrt(adx*adx+ady*ady);
      const aux = adx/alen, auy = ady/alen;
      ctx.beginPath();
      ctx.moveTo(ex+ox, ey+oy);
      ctx.lineTo(ex+ox-aux*8-auy*4, ey+oy-auy*8+aux*4);
      ctx.lineTo(ex+ox-aux*8+auy*4, ey+oy-auy*8-aux*4);
      ctx.closePath();
      ctx.fillStyle = e.eps ? '#a78bfa' : '#475569';
      ctx.fill();

      // Label
      const lx = (sx+ex)/2+ox + (-uy)*14;
      const ly = (sy+ey)/2+oy + (ux)*14;
      ctx.font = 'bold 12px monospace';
      ctx.fillStyle = e.eps ? '#c084fc' : '#f59e0b';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(e.label, lx, ly);
    });

    // Start arrow
    ctx.beginPath();
    ctx.moveTo(10, 80);
    ctx.lineTo(34, 80);
    ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 2; ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(36, 80); ctx.lineTo(30, 75); ctx.lineTo(30, 85); ctx.closePath();
    ctx.fillStyle = '#e2e8f0'; ctx.fill();

    // Draw states
    Object.entries(states).forEach(([name, p]) => {
      const isAccept = accept.has(name);
      ctx.beginPath();
      ctx.arc(p.x, p.y, 22, 0, Math.PI*2);
      ctx.fillStyle = '#1e293b';
      ctx.fill();
      ctx.strokeStyle = isAccept ? '#22c55e' : '#6366f1';
      ctx.lineWidth = 2.5;
      ctx.stroke();

      if (isAccept) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 17, 0, Math.PI*2);
        ctx.strokeStyle = '#22c55e'; ctx.lineWidth = 1.5; ctx.stroke();
      }

      ctx.font = 'bold 14px monospace';
      ctx.fillStyle = '#e2e8f0';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(name, p.x, p.y);
    });
  }

  const obs = new MutationObserver(() => {
    if (document.getElementById('s15').classList.contains('active')) draw();
  });
  obs.observe(document.getElementById('s15'), {attributes:true, attributeFilter:['class']});
  draw();
})();
</script>

<!-- ==================== s16: EPSILON-CLOSURE INTERACTIVE ==================== -->
<div class="slide" id="s16">
  <h1>&epsilon;-Closure: CL(q)</h1>
  <p class="subtitle">Click a state to watch its &epsilon;-closure expand step by step</p>
  <div class="two-col">
    <div>
      <div class="key-idea">
        <h3>Definition</h3>
        <p><b>CL(q)</b> = all states reachable from q by following <b>zero or more &epsilon;-transitions</b>.</p>
        <p style="margin-top:6px; color:#94a3b8;">q itself is always in CL(q) (zero &epsilon;-moves = stay put).</p>
      </div>
      <canvas id="cS16" width="460" height="280" style="width:100%;" class="canvas-wrap"></canvas>
      <p style="font-size:0.82em; color:#94a3b8; text-align:center;">Real transitions dimmed. <span style="color:#a78bfa;">&epsilon;-transitions highlighted.</span></p>
    </div>
    <div>
      <h3>Explore &epsilon;-closure</h3>
      <p style="font-size:0.9em; color:#94a3b8; margin-bottom:8px;">Click a state to compute CL(q):</p>
      <div class="ctrl-row">
        <button class="btn btn-sm" onclick="s16Explore('A')">A</button>
        <button class="btn btn-sm" onclick="s16Explore('B')">B</button>
        <button class="btn btn-sm" onclick="s16Explore('C')">C</button>
        <button class="btn btn-sm" onclick="s16Explore('D')">D</button>
        <button class="btn btn-sm" onclick="s16Explore('E')">E</button>
        <button class="btn btn-sm" onclick="s16Explore('F')">F</button>
        <button class="btn btn-sm btn-secondary" onclick="s16Reset()">Reset</button>
      </div>
      <div id="s16Result" style="margin-top:12px; min-height:100px;">
        <p style="color:#64748b;">Click any state above to visualize its &epsilon;-closure...</p>
      </div>
      <div class="warning" style="margin-top:12px;">
        <h3>Follow the chain!</h3>
        <p>CL(E) isn't just {E, B, C}. Since B has &epsilon; &rarr; D, you must follow that too!</p>
        <p style="margin-top:4px;">CL(E) = {E} &cup; {B,C} &cup; CL(B) &cup; CL(C) = <b>{E, B, C, D}</b></p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas = document.getElementById('cS16');
  const ctx = canvas.getContext('2d');

  const positions = {
    A:{x:60,y:70}, B:{x:200,y:70}, C:{x:340,y:70},
    E:{x:60,y:210}, F:{x:200,y:210}, D:{x:340,y:210}
  };

  // Epsilon transitions only
  const epsEdges = {
    A:[], B:['D'], C:[], D:[], E:['B','C'], F:[]
  };

  // Full closure
  const closures = {
    A: ['A'],
    B: ['B','D'],
    C: ['C'],
    D: ['D'],
    E: ['B','C','D','E'],
    F: ['F']
  };

  let highlighted = new Set();
  let exploringState = null;
  let animStep = 0;
  let animTimer = null;

  function draw() {
    ctx.clearRect(0, 0, 460, 280);

    // Draw real edges (dimmed)
    const realEdges = [
      {f:'A',t:'B',l:'1'},{f:'A',t:'E',l:'0'},{f:'B',t:'C',l:'1'},
      {f:'C',t:'D',l:'1'},{f:'E',t:'F',l:'0'},{f:'F',t:'D',l:'0'}
    ];
    realEdges.forEach(e => {
      const p1=positions[e.f], p2=positions[e.t];
      const dx=p2.x-p1.x, dy=p2.y-p1.y, len=Math.sqrt(dx*dx+dy*dy);
      const ux=dx/len, uy=dy/len;
      ctx.beginPath();
      ctx.moveTo(p1.x+ux*24, p1.y+uy*24);
      ctx.lineTo(p2.x-ux*24, p2.y-uy*24);
      ctx.strokeStyle = '#334155'; ctx.lineWidth = 1; ctx.globalAlpha = 0.3;
      ctx.stroke(); ctx.globalAlpha = 1;
    });

    // Draw epsilon edges (prominent)
    const epsEdgeList = [
      {f:'B',t:'D'},{f:'E',t:'B'},{f:'E',t:'C'}
    ];
    epsEdgeList.forEach(e => {
      const p1=positions[e.f], p2=positions[e.t];
      const dx=p2.x-p1.x, dy=p2.y-p1.y, len=Math.sqrt(dx*dx+dy*dy);
      const ux=dx/len, uy=dy/len;
      const isActive = highlighted.has(e.f) && highlighted.has(e.t);

      ctx.beginPath();
      ctx.setLineDash([5,4]);
      // Curve for diagonal edges
      if (Math.abs(dx)>100 && Math.abs(dy)>80) {
        const mx=(p1.x+p2.x)/2, my=(p1.y+p2.y)/2;
        ctx.moveTo(p1.x+ux*24, p1.y+uy*24);
        ctx.quadraticCurveTo(mx, my-30, p2.x-ux*24, p2.y-uy*24);
      } else {
        ctx.moveTo(p1.x+ux*24, p1.y+uy*24);
        ctx.lineTo(p2.x-ux*24, p2.y-uy*24);
      }
      ctx.strokeStyle = isActive ? '#c084fc' : '#8b5cf6';
      ctx.lineWidth = isActive ? 3 : 2;
      ctx.stroke();
      ctx.setLineDash([]);

      // Arrowhead
      const sx=p1.x+ux*24, sy=p1.y+uy*24;
      const ex=p2.x-ux*24, ey=p2.y-uy*24;
      const adx=ex-sx, ady=ey-sy, alen=Math.sqrt(adx*adx+ady*ady);
      const aux=adx/alen, auy=ady/alen;
      ctx.beginPath();
      ctx.moveTo(ex,ey);
      ctx.lineTo(ex-aux*8-auy*4, ey-auy*8+aux*4);
      ctx.lineTo(ex-aux*8+auy*4, ey-auy*8-aux*4);
      ctx.closePath();
      ctx.fillStyle = isActive ? '#c084fc' : '#8b5cf6';
      ctx.fill();

      // Label
      const lx=(sx+ex)/2+(-uy)*12, ly=(sy+ey)/2+(ux)*12;
      ctx.font = 'bold 12px monospace';
      ctx.fillStyle = isActive ? '#e9d5ff' : '#a78bfa';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText('', lx, ly);
    });

    // Start arrow
    ctx.beginPath();
    ctx.moveTo(10,70); ctx.lineTo(34,70);
    ctx.strokeStyle='#e2e8f0'; ctx.lineWidth=2; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(36,70); ctx.lineTo(30,65); ctx.lineTo(30,75); ctx.closePath();
    ctx.fillStyle='#e2e8f0'; ctx.fill();

    // Draw states
    Object.entries(positions).forEach(([name,p]) => {
      const isHL = highlighted.has(name);
      const isAccept = name==='D';
      const isSource = name===exploringState;

      if (isHL) {
        ctx.beginPath(); ctx.arc(p.x,p.y,30,0,Math.PI*2);
        ctx.fillStyle = isSource ? 'rgba(245,158,11,0.12)' : 'rgba(168,85,247,0.12)';
        ctx.fill();
      }

      ctx.beginPath(); ctx.arc(p.x,p.y,22,0,Math.PI*2);
      ctx.fillStyle = isHL ? '#312e81' : '#1e293b';
      ctx.fill();
      ctx.strokeStyle = isSource ? '#f59e0b' : isHL ? '#a78bfa' : isAccept ? '#22c55e' : '#475569';
      ctx.lineWidth = isHL ? 3 : 2;
      ctx.stroke();

      if (isAccept) {
        ctx.beginPath(); ctx.arc(p.x,p.y,17,0,Math.PI*2);
        ctx.strokeStyle = isHL ? '#a78bfa' : '#22c55e';
        ctx.lineWidth = 1.5; ctx.stroke();
      }

      ctx.font = 'bold 14px monospace';
      ctx.fillStyle = isHL ? '#fff' : '#94a3b8';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(name, p.x, p.y);
    });
  }

  window.s16Explore = function(state) {
    if (animTimer) { clearInterval(animTimer); animTimer = null; }
    exploringState = state;
    highlighted = new Set();
    animStep = 0;

    const cl = closures[state];
    const result = document.getElementById('s16Result');

    // Animate: add one state at a time
    animTimer = setInterval(() => {
      if (animStep >= cl.length) {
        clearInterval(animTimer); animTimer = null;
        result.innerHTML = '<div style="background:#1e293b; border:1px solid #8b5cf6; border-radius:10px; padding:14px;">' +
          '<span style="color:#f59e0b; font-weight:700;">CL('+state+')</span> = <span style="color:#a78bfa; font-weight:700; font-size:1.1em;">{'+cl.sort().join(', ')+'}</span>' +
          (cl.length===1 ? '<p style="color:#94a3b8; margin-top:6px; font-size:0.9em;">No &epsilon;-transitions from '+state+', so closure is just {'+state+'}.</p>' :
           '<p style="color:#94a3b8; margin-top:6px; font-size:0.9em;">Followed &epsilon;-chains from '+state+' to reach '+(cl.length-1)+' additional state'+(cl.length>2?'s':'')+'.</p>') +
          '</div>';
        return;
      }
      highlighted.add(cl[animStep]);
      animStep++;
      result.innerHTML = '<div style="font-family:monospace; color:#a78bfa;">Building CL('+state+'): {'+[...highlighted].sort().join(', ')+'} ...</div>';
      draw();
    }, 500);
  };

  window.s16Reset = function() {
    if (animTimer) { clearInterval(animTimer); animTimer = null; }
    exploringState = null;
    highlighted = new Set();
    document.getElementById('s16Result').innerHTML = '<p style="color:#64748b;">Click any state above to visualize its &epsilon;-closure...</p>';
    draw();
  };

  const obs = new MutationObserver(() => {
    if (document.getElementById('s16').classList.contains('active')) draw();
  });
  obs.observe(document.getElementById('s16'), {attributes:true, attributeFilter:['class']});
  draw();
})();
</script>

<!-- ==================== s17: EXTENDED DELTA + CONVERSION ==================== -->
<div class="slide" id="s17">
  <h1>Converting &epsilon;-NFA to NFA</h1>
  <p class="subtitle">"Bake in" the &epsilon;-transitions &mdash; step through the conversion</p>
  <div class="two-col">
    <div>
      <h3>The Recipe</h3>
      <div class="key-idea">
        <p><b>Same states, alphabet, start state.</b></p>
        <p style="margin-top:6px;"><b>New transitions:</b> &delta;<sub>N</sub>(q, a) =</p>
        <ol style="font-size:0.92em;">
          <li>Compute CL(q) &mdash; everywhere you can be via &epsilon; before reading 'a'</li>
          <li>From each state in CL(q), follow real transition on 'a'</li>
          <li>Union all results</li>
        </ol>
        <p style="margin-top:6px;"><b>New accept states F':</b> any q where CL(q) &cap; F &ne; &empty;</p>
      </div>
      <h3 style="margin-top:12px;">Worked Example: &delta;&#770;(A, "01")</h3>
      <div class="code-block">
        <div class="code-content" style="font-size:0.85em;">
          <div class="line">Step 0: &delta;&#770;(A, &epsilon;) = CL(A) = <span style="color:#38bdf8;">{A}</span></div>
          <div class="line">Step 1: Read '0'</div>
          <div class="line">  From A: &delta;(A,0) = {E}</div>
          <div class="line">  CL({E}) = <span style="color:#38bdf8;">{B, C, D, E}</span></div>
          <div class="line">Step 2: Read '1'</div>
          <div class="line">  From B: &delta;(B,1) = {C}</div>
          <div class="line">  From C: &delta;(C,1) = {D}</div>
          <div class="line">  From D: &delta;(D,1) = {}</div>
          <div class="line">  From E: &delta;(E,1) = {}</div>
          <div class="line">  CL({C,D}) = <span style="color:#4ade80;">{C, D}</span></div>
          <div class="line"><span style="color:#4ade80;">D &isin; F &rArr; "01" ACCEPTED!</span></div>
        </div>
      </div>
    </div>
    <div>
      <h3>Side-by-Side Conversion</h3>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
        <div>
          <p style="font-size:0.82em; color:#94a3b8; font-weight:600;">&epsilon;-NFA</p>
          <table style="font-size:0.76em;">
            <tr><th></th><th>0</th><th>1</th><th>&epsilon;</th></tr>
            <tr><td>&rarr;A</td><td>{E}</td><td>{B}</td><td>&empty;</td></tr>
            <tr><td>B</td><td>&empty;</td><td>{C}</td><td>{D}</td></tr>
            <tr><td>C</td><td>&empty;</td><td>{D}</td><td>&empty;</td></tr>
            <tr><td>*D</td><td>&empty;</td><td>&empty;</td><td>&empty;</td></tr>
            <tr><td>E</td><td>{F}</td><td>&empty;</td><td>{B,C}</td></tr>
            <tr><td>F</td><td>{D}</td><td>&empty;</td><td>&empty;</td></tr>
          </table>
        </div>
        <div>
          <p style="font-size:0.82em; color:#94a3b8; font-weight:600;">Ordinary NFA (result)</p>
          <table style="font-size:0.76em;">
            <tr><th></th><th>0</th><th>1</th></tr>
            <tr><td>&rarr;A</td><td>{E}</td><td>{B}</td></tr>
            <tr><td><span style="color:#4ade80;">*</span>B</td><td>&empty;</td><td>{C}</td></tr>
            <tr><td>C</td><td>&empty;</td><td>{D}</td></tr>
            <tr><td>*D</td><td>&empty;</td><td>&empty;</td></tr>
            <tr><td><span style="color:#4ade80;">*</span>E</td><td>{F}</td><td><span style="color:#f59e0b;">{C,D}</span></td></tr>
            <tr><td>F</td><td>{D}</td><td>&empty;</td></tr>
          </table>
        </div>
      </div>
      <h3 style="margin-top:12px;">What Changed?</h3>
      <ul style="font-size:0.9em;">
        <li>&epsilon; column <b>removed</b> entirely</li>
        <li>E on '1': CL(E)={B,C,D,E}, B&rarr;{C}, C&rarr;{D} &rArr; <span style="color:#f59e0b;">{C,D}</span></li>
        <li><span style="color:#4ade80;">B and E become accept states</span> &mdash; CL(B)={B,D} and CL(E)={B,C,D,E} both contain D</li>
      </ul>
      <div class="analogy" style="margin-top:8px;">
        <h3>Intuition</h3>
        <p>&delta;<sub>N</sub> incorporates &epsilon;-transitions <b>before</b> each real move. The closure "bakes in" the free moves so they're no longer needed as separate transitions.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ==================== sCC: CHALLENGE - SPOT THE BUG ==================== -->
<div class="slide" id="sCC">
  <h1>Challenge: Spot the Bug!</h1>
  <p class="subtitle">A student did subset construction but made a mistake. Find it!</p>
  <div class="two-col">
    <div>
      <h3>NFA (accepts strings ending with "10")</h3>
      <table style="font-size:0.88em;">
        <tr><th></th><th>0</th><th>1</th></tr>
        <tr><td>&rarr; p0</td><td>{p0}</td><td>{p0, p1}</td></tr>
        <tr><td>p1</td><td>{p2}</td><td>{}</td></tr>
        <tr><td>* p2</td><td>{}</td><td>{}</td></tr>
      </table>
      <h3 style="margin-top:16px;">Student's Subset Construction</h3>
      <p style="font-size:0.88em; color:#94a3b8;">One cell is <b>WRONG</b>. Click it!</p>
      <table style="font-size:0.88em;" id="ccTable">
        <tr><th>DFA State</th><th>0</th><th>1</th></tr>
      </table>
      <div id="ccFeedback" style="display:none; margin-top:10px; padding:12px; border-radius:8px;"></div>
    </div>
    <div>
      <div class="key-idea">
        <h3>Common Mistakes</h3>
        <ul>
          <li><b>Forgetting to union:</b> When multiple NFA states are active, union ALL their transitions</li>
          <li><b>Missing states:</b> &delta;(p1, 0) = {p2} is easy to forget when computing &delta;({p0,p1}, 0)</li>
          <li><b>Wrong accept states:</b> A DFA state is accepting if it contains ANY NFA accept state</li>
        </ul>
      </div>
      <div id="ccHintArea" style="margin-top:12px;">
        <button class="btn btn-sm btn-secondary" onclick="ccShowHint()">Need a hint?</button>
        <div id="ccHint" style="display:none; margin-top:8px;">
          <div class="analogy">
            <h3>Hint</h3>
            <p>Look at {p0, p1} on input 0. What should &delta;(p0, 0) &cup; &delta;(p1, 0) be?</p>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  // Correct: {p0}->0->{p0}, ->1->{p0,p1}
  //          {p0,p1}->0->{p0,p2}, ->1->{p0,p1}
  //          *{p0,p2}->0->{p0}, ->1->{p0,p1}
  // Bug: student wrote {p0,p1}->0->{p0} instead of {p0,p2}
  const buggyData = [
    ['{p0}', '{p0}', '{p0,p1}', false],
    ['{p0,p1}', '{p0}', '{p0,p1}', false],  // BUG: should be {p0,p2}
    ['*{p0,p2}', '{p0}', '{p0,p1}', true]
  ];
  const bugRow = 1, bugCol = 1; // 0-indexed (row 1, col 1 = "0" column)
  let answered = false;

  function init() {
    answered = false;
    const table = document.getElementById('ccTable');
    // Keep header, rebuild body
    let html = '<tr><th>DFA State</th><th>0</th><th>1</th></tr>';
    buggyData.forEach((row, ri) => {
      html += '<tr>';
      html += '<td style="text-align:left; font-weight:600;">'+(ri===0?' ':'')+row[0]+'</td>';
      for (let ci = 1; ci <= 2; ci++) {
        html += '<td id="cc-'+ri+'-'+ci+'" style="cursor:pointer; transition:all 0.2s;" onclick="ccClick('+ri+','+ci+')">'+row[ci]+'</td>';
      }
      html += '</tr>';
    });
    table.innerHTML = html;
    document.getElementById('ccFeedback').style.display = 'none';
    document.getElementById('ccHint').style.display = 'none';
  }

  window.ccClick = function(row, col) {
    if (answered) return;
    answered = true;
    const clicked = document.getElementById('cc-'+row+'-'+col);
    const bugCell = document.getElementById('cc-'+bugRow+'-'+bugCol);
    const fb = document.getElementById('ccFeedback');
    fb.style.display = 'block';

    if (row===bugRow && col===bugCol) {
      clicked.style.background = 'rgba(34,197,94,0.2)';
      clicked.style.color = '#4ade80';
      clicked.style.border = '2px solid #22c55e';
      fb.style.background = 'rgba(34,197,94,0.1)';
      fb.style.borderLeft = '4px solid #22c55e';
      fb.innerHTML = '<span style="color:#a7f3d0;"><b>Found it!</b> {p0,p1} on input 0 should be <b>{p0,p2}</b>, not {p0}.<br>&delta;(p0,0) &cup; &delta;(p1,0) = {p0} &cup; {p2} = <b>{p0,p2}</b>.<br>The student forgot &delta;(p1,0) = {p2}.</span>' +
        '<br><button class="btn btn-sm btn-secondary" onclick="ccInit()" style="margin-top:8px;">Try Again</button>';
    } else {
      clicked.style.background = 'rgba(239,68,68,0.15)';
      clicked.style.color = '#f87171';
      bugCell.style.background = 'rgba(245,158,11,0.2)';
      bugCell.style.color = '#fbbf24';
      bugCell.style.border = '2px solid #f59e0b';
      fb.style.background = 'rgba(239,68,68,0.1)';
      fb.style.borderLeft = '4px solid #ef4444';
      fb.innerHTML = '<span style="color:#fecaca;"><b>Not that one.</b> The bug is in the highlighted cell: {p0,p1} on 0.<br>&delta;(p0,0) &cup; &delta;(p1,0) = {p0} &cup; {p2} = <b>{p0,p2}</b>.</span>' +
        '<br><button class="btn btn-sm btn-secondary" onclick="ccInit()" style="margin-top:8px;">Try Again</button>';
    }
  };

  window.ccShowHint = function() {
    document.getElementById('ccHint').style.display = 'block';
  };

  window.ccInit = init;

  const obs = new MutationObserver(() => {
    if (document.getElementById('sCC').classList.contains('active')) init();
  });
  obs.observe(document.getElementById('sCC'), {attributes:true, attributeFilter:['class']});
  init();
})();
</script>

<!-- ==================== s18: SUMMARY + CHEAT SHEET ==================== -->
<div class="slide" id="s18">
  <h1>Summary: The Complete Picture</h1>
  <p class="subtitle">Everything connects</p>
  <div class="two-col">
    <div>
      <canvas id="cS18" width="440" height="220" style="width:100%;" class="canvas-wrap"></canvas>
      <div class="key-idea" style="margin-top:12px;">
        <h3>Key Takeaways</h3>
        <ul style="font-size:0.92em;">
          <li><b>DFA, NFA, &epsilon;-NFA</b> all recognize the <b>regular languages</b></li>
          <li>NFAs/&epsilon;-NFAs are easier to <b>design</b> (exponentially fewer states)</li>
          <li>Only DFAs can be directly <b>executed</b> on a computer</li>
          <li><b>Subset Construction</b>: NFA &rarr; DFA (may blow up to 2<sup>n</sup>)</li>
          <li><b>&epsilon;-Closure</b>: eliminates &epsilon;-transitions systematically</li>
        </ul>
      </div>
    </div>
    <div>
      <h3>Cheat Sheet</h3>
      <div class="code-block">
        <div class="code-content" style="font-size:0.82em;">
          <div class="line" style="color:#3b82f6;"> Subset Construction (NFA  DFA) </div>
          <div class="line">1. Start state = {q0}</div>
          <div class="line">2. For each DFA state S, each symbol a:</div>
          <div class="line">   _D(S, a) =  _N(q, a) for q  S</div>
          <div class="line">3. Accept = any S containing member of F</div>
          <div class="line">4. Repeat until no new states (lazy!)</div>
          <div class="line"></div>
          <div class="line" style="color:#8b5cf6;"> -NFA  NFA </div>
          <div class="line">1. _N(q, a) =  _E(p, a) for p  CL(q)</div>
          <div class="line">2. F' = { q | CL(q)  F   }</div>
          <div class="line"></div>
          <div class="line" style="color:#f59e0b;"> -Closure </div>
          <div class="line">CL(q) = {q}  all states reachable</div>
          <div class="line">         via -transitions (BFS/DFS)</div>
        </div>
      </div>
      <div class="warning" style="margin-top:8px;">
        <h3>Common Mistakes</h3>
        <ul style="font-size:0.88em;">
          <li>{p,q} is ONE DFA state, not two</li>
          <li>CL() is transitive &mdash; follow the full chain</li>
          <li>NFA accepts if ANY path succeeds</li>
          <li>Don't forget the dead state {} in the DFA</li>
          <li>In &epsilon;-NFA&rarr;NFA, update accept states F' too!</li>
        </ul>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas = document.getElementById('cS18');
  const ctx = canvas.getContext('2d');

  function draw() {
    ctx.clearRect(0, 0, 440, 220);

    const boxes = [
      {label:'DFA', x:70, y:110, color:'#3b82f6', sub:'Execute'},
      {label:'NFA', x:220, y:110, color:'#8b5cf6', sub:'Design'},
      {label:'-NFA', x:370, y:110, color:'#f59e0b', sub:'Compose'}
    ];

    function roundRect(x,y,w,h,r) {
      ctx.beginPath();
      ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
      ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
      ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
      ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath();
    }

    // Arrows between boxes
    // DFA <-> NFA
    // Top: NFA -> DFA (subset construction)
    ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(190,90); ctx.lineTo(110,90); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(110,90); ctx.lineTo(116,85); ctx.lineTo(116,95); ctx.closePath();
    ctx.fillStyle='#f59e0b'; ctx.fill();
    ctx.font='10px system-ui'; ctx.fillStyle='#f59e0b'; ctx.textAlign='center';
    ctx.fillText('subset construction', 150, 82);

    // Bottom: DFA -> NFA (trivial)
    ctx.strokeStyle='#4ade80'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(110,130); ctx.lineTo(190,130); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(190,130); ctx.lineTo(184,125); ctx.lineTo(184,135); ctx.closePath();
    ctx.fillStyle='#4ade80'; ctx.fill();
    ctx.fillStyle='#4ade80';
    ctx.fillText('trivial (wrap in {})', 150, 148);

    // NFA <-> -NFA
    ctx.strokeStyle='#f59e0b'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(340,90); ctx.lineTo(260,90); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(260,90); ctx.lineTo(266,85); ctx.lineTo(266,95); ctx.closePath();
    ctx.fillStyle='#f59e0b'; ctx.fill();
    ctx.fillStyle='#f59e0b';
    ctx.fillText('eliminate ', 300, 82);

    ctx.strokeStyle='#4ade80'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(260,130); ctx.lineTo(340,130); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(340,130); ctx.lineTo(334,125); ctx.lineTo(334,135); ctx.closePath();
    ctx.fillStyle='#4ade80'; ctx.fill();
    ctx.fillStyle='#4ade80';
    ctx.fillText('trivial (special case)', 300, 148);

    // Draw boxes on top
    boxes.forEach(b => {
      roundRect(b.x-42, b.y-28, 84, 56, 10);
      ctx.fillStyle='#1e293b'; ctx.fill();
      ctx.strokeStyle=b.color; ctx.lineWidth=2.5; ctx.stroke();
      ctx.font='bold 16px system-ui'; ctx.fillStyle=b.color;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(b.label, b.x, b.y-4);
      ctx.font='10px system-ui'; ctx.fillStyle='#94a3b8';
      ctx.fillText(b.sub, b.x, b.y+14);
    });

    // Title
    ctx.font='bold 12px system-ui'; ctx.fillStyle='#94a3b8';
    ctx.textAlign='center'; ctx.textBaseline='alphabetic';
    ctx.fillText('All recognize exactly the Regular Languages', 220, 20);

    // Bottom
    ctx.font='11px system-ui'; ctx.fillStyle='#64748b';
    ctx.fillText('Green = trivial direction  |  Orange = requires algorithm', 220, 200);
  }

  const obs = new MutationObserver(() => {
    if (document.getElementById('s18').classList.contains('active')) draw();
  });
  obs.observe(document.getElementById('s18'), {attributes:true, attributeFilter:['class']});
  draw();
})();
</script>

<!-- ==================== sQ1: QUIZ - MULTIPLE CHOICE ==================== -->
<div class="slide" id="sQ1">
  <h1>Quiz: Test Your Knowledge</h1>
  <p class="subtitle">Three questions covering NFA fundamentals</p>
  <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:16px; margin-top:12px;">
    <!-- Q1 -->
    <div style="background:#1e293b; border:1px solid #334155; border-radius:12px; padding:16px;">
      <p style="color:#38bdf8; font-weight:600; font-size:0.9em;">Q1: Complexity</p>
      <p style="font-size:0.92em;">If an NFA has <b>5 states</b>, the equivalent DFA can have at most how many states?</p>
      <div id="q1opts" style="margin-top:8px;">
        <label style="display:block; margin:4px 0; cursor:pointer;"><input type="radio" name="q1" value="5"> 5</label>
        <label style="display:block; margin:4px 0; cursor:pointer;"><input type="radio" name="q1" value="10"> 10</label>
        <label style="display:block; margin:4px 0; cursor:pointer;"><input type="radio" name="q1" value="25"> 25</label>
        <label style="display:block; margin:4px 0; cursor:pointer;"><input type="radio" name="q1" value="32"> 32</label>
      </div>
      <div id="q1fb" style="display:none; margin-top:8px; padding:8px; border-radius:6px; font-size:0.88em;"></div>
    </div>
    <!-- Q2 -->
    <div style="background:#1e293b; border:1px solid #334155; border-radius:12px; padding:16px;">
      <p style="color:#38bdf8; font-weight:600; font-size:0.9em;">Q2: Acceptance</p>
      <p style="font-size:0.92em;">An NFA accepts a string w if:</p>
      <div id="q2opts" style="margin-top:8px;">
        <label style="display:block; margin:4px 0; cursor:pointer;"><input type="radio" name="q2" value="all"> All paths reach an accept state</label>
        <label style="display:block; margin:4px 0; cursor:pointer;"><input type="radio" name="q2" value="any"> At least one path reaches an accept state</label>
        <label style="display:block; margin:4px 0; cursor:pointer;"><input type="radio" name="q2" value="majority"> A majority of paths reach an accept state</label>
      </div>
      <div id="q2fb" style="display:none; margin-top:8px; padding:8px; border-radius:6px; font-size:0.88em;"></div>
    </div>
    <!-- Q3 -->
    <div style="background:#1e293b; border:1px solid #334155; border-radius:12px; padding:16px;">
      <p style="color:#38bdf8; font-weight:600; font-size:0.9em;">Q3: &epsilon;-Closure</p>
      <p style="font-size:0.92em;">If CL(q) contains an accept state, what happens in &epsilon;-NFA &rarr; NFA conversion?</p>
      <div id="q3opts" style="margin-top:8px;">
        <label style="display:block; margin:4px 0; cursor:pointer;"><input type="radio" name="q3" value="remove"> q is removed</label>
        <label style="display:block; margin:4px 0; cursor:pointer;"><input type="radio" name="q3" value="accept"> q becomes an accept state</label>
        <label style="display:block; margin:4px 0; cursor:pointer;"><input type="radio" name="q3" value="start"> q becomes the start state</label>
      </div>
      <div id="q3fb" style="display:none; margin-top:8px; padding:8px; border-radius:6px; font-size:0.88em;"></div>
    </div>
  </div>
  <div style="text-align:center; margin-top:16px;">
    <button class="btn" onclick="q1Check()">Check Answers</button>
    <span id="q1Score" style="margin-left:16px; font-size:1.1em; font-weight:600;"></span>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const answers = { q1:'32', q2:'any', q3:'accept' };
  const explanations = {
    q1: '2^5 = 32. Each subset of the NFA\'s 5 states is a potential DFA state.',
    q2: 'NFAs use existential acceptance: if ANY path succeeds, the string is accepted.',
    q3: 'If CL(q)  F  , then q can reach an accept state via  alone, so q must become accepting in the ordinary NFA.'
  };

  window.q1Check = function() {
    let score = 0;
    ['q1','q2','q3'].forEach(qid => {
      const sel = document.querySelector('input[name="'+qid+'"]:checked');
      const fb = document.getElementById(qid+'fb');
      fb.style.display = 'block';
      if (!sel) {
        fb.style.background = 'rgba(239,68,68,0.1)';
        fb.innerHTML = '<span style="color:#fecaca;">No answer selected.</span>';
        return;
      }
      const correct = sel.value === answers[qid];
      if (correct) score++;
      fb.style.background = correct ? 'rgba(34,197,94,0.1)' : 'rgba(239,68,68,0.1)';
      fb.innerHTML = '<span style="color:'+(correct?'#a7f3d0':'#fecaca')+';">' +
        (correct ? '&#10003; Correct! ' : '&#10007; Incorrect. ') + explanations[qid] + '</span>';
    });
    document.getElementById('q1Score').textContent = score + '/3' +
      (score===3 ? '  Perfect!' : score>=2 ? '  Good!' : '  Review the material');
    document.getElementById('q1Score').style.color = score===3 ? '#4ade80' : score>=2 ? '#38bdf8' : '#f87171';
  };
})();
</script>

<!-- ==================== sQ2: QUIZ - TRACE EXERCISE ==================== -->
<div class="slide" id="sQ2">
  <h1>Quiz: Trace Exercise</h1>
  <p class="subtitle">Given the NFA, predict the final state set</p>
  <div class="two-col">
    <div>
      <h3>NFA for "ends with 01"</h3>
      <table style="font-size:0.88em;">
        <tr><th></th><th>0</th><th>1</th></tr>
        <tr><td>&rarr; q0</td><td>{q0, q1}</td><td>{q0}</td></tr>
        <tr><td>q1</td><td>{}</td><td>{q2}</td></tr>
        <tr><td>* q2</td><td>{}</td><td>{}</td></tr>
      </table>
      <div style="margin-top:16px; background:#1e293b; border:1px solid #334155; border-radius:12px; padding:16px;">
        <p style="font-size:1.05em;">What is <b>&delta;&#770;(q0, "0110")</b>?</p>
        <p style="font-size:0.88em; color:#94a3b8;">Enter the final set of active states after reading "0110".</p>
        <div class="ctrl-row" style="margin-top:10px;">
          <input type="text" id="q2answer" placeholder="e.g. {q0,q1}" style="width:180px;" />
          <button class="btn btn-sm" onclick="q2Check()">Check</button>
          <button class="btn btn-sm btn-secondary" onclick="q2Reveal()">Show Trace</button>
        </div>
        <div id="q2fb" style="display:none; margin-top:10px; padding:10px; border-radius:8px;"></div>
      </div>
    </div>
    <div>
      <div id="q2trace" style="display:none;">
        <h3>Step-by-Step Trace</h3>
        <div class="code-block">
          <div class="code-content" style="font-size:0.88em;">
            <div class="line">Start: <span style="color:#38bdf8;">{q0}</span></div>
            <div class="line"></div>
            <div class="line">Read '0': &delta;(q0, 0) = {q0, q1}</div>
            <div class="line">  Active: <span style="color:#38bdf8;">{q0, q1}</span></div>
            <div class="line"></div>
            <div class="line">Read '1': &delta;(q0,1) &cup; &delta;(q1,1)</div>
            <div class="line">        = {q0} &cup; {q2} = {q0, q2}</div>
            <div class="line">  Active: <span style="color:#38bdf8;">{q0, q2}</span></div>
            <div class="line"></div>
            <div class="line">Read '1': &delta;(q0,1) &cup; &delta;(q2,1)</div>
            <div class="line">        = {q0} &cup; {} = {q0}</div>
            <div class="line">  Active: <span style="color:#38bdf8;">{q0}</span></div>
            <div class="line"></div>
            <div class="line">Read '0': &delta;(q0, 0) = {q0, q1}</div>
            <div class="line">  Active: <span style="color:#4ade80;">{q0, q1}</span></div>
            <div class="line"></div>
            <div class="line">Final: {q0, q1}</div>
            <div class="line">{q0,q1} &cap; {q2} = &empty;</div>
            <div class="line" style="color:#f87171;">REJECTED (no accept state)</div>
          </div>
        </div>
      </div>
      <div id="q2hint" style="margin-top:12px;">
        <div class="analogy">
          <h3>Strategy</h3>
          <p>Process one symbol at a time. At each step, take the <b>union</b> of transitions from all active states. The string "0110" has 4 symbols &mdash; you'll compute 4 transitions.</p>
        </div>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  // Correct answer: {q0,q1}
  // 0: {q0} -> {q0,q1}
  // 1: {q0,q1} -> {q0}  {q2} = {q0,q2}
  // 1: {q0,q2} -> {q0}  {} = {q0}
  // 0: {q0} -> {q0,q1}

  window.q2Check = function() {
    const raw = document.getElementById('q2answer').value.trim().replace(/\s/g,'');
    const fb = document.getElementById('q2fb');
    fb.style.display = 'block';

    // Normalize: accept various formats
    const normalized = raw.replace(/[{}]/g,'').split(',').map(s=>s.trim()).filter(Boolean).sort().join(',');
    const correct = 'q0,q1';

    if (normalized === correct) {
      fb.style.background = 'rgba(34,197,94,0.1)';
      fb.style.borderLeft = '4px solid #22c55e';
      fb.innerHTML = '<span style="color:#a7f3d0;"><b>Correct!</b> &delta;&#770;(q0, "0110") = {q0, q1}. Since {q0,q1} &cap; {q2} = &empty;, the string is REJECTED.</span>';
    } else {
      fb.style.background = 'rgba(239,68,68,0.1)';
      fb.style.borderLeft = '4px solid #ef4444';
      fb.innerHTML = '<span style="color:#fecaca;"><b>Not quite.</b> The correct answer is {q0, q1}. Click "Show Trace" to see the full computation.</span>';
    }
  };

  window.q2Reveal = function() {
    document.getElementById('q2trace').style.display = 'block';
  };
})();
</script>

<!-- ==================== sQ3: QUIZ - EPSILON CLOSURE + CONVERSION ==================== -->
<div class="slide" id="sQ3">
  <h1>Quiz: &epsilon;-Closure Challenge</h1>
  <p class="subtitle">Test your understanding of &epsilon;-NFA conversion</p>
  <div class="two-col">
    <div>
      <h3>Given this &epsilon;-NFA:</h3>
      <table style="font-size:0.85em;">
        <tr><th></th><th>a</th><th>b</th><th>&epsilon;</th></tr>
        <tr><td>&rarr; X</td><td>{Y}</td><td>&empty;</td><td>&empty;</td></tr>
        <tr><td>Y</td><td>&empty;</td><td>{Z}</td><td>{Z}</td></tr>
        <tr><td>* Z</td><td>&empty;</td><td>&empty;</td><td>&empty;</td></tr>
      </table>
      <div style="background:#1e293b; border:1px solid #334155; border-radius:12px; padding:16px; margin-top:12px;">
        <p style="font-weight:600; margin-bottom:8px;">Questions:</p>
        <div style="margin-bottom:12px;">
          <p style="font-size:0.92em;">1. What is CL(Y)?</p>
          <div class="ctrl-row">
            <input type="text" id="q3a1" placeholder="e.g. {Y,Z}" style="width:140px;" />
          </div>
        </div>
        <div style="margin-bottom:12px;">
          <p style="font-size:0.92em;">2. In the converted NFA, is Y an accept state?</p>
          <div class="ctrl-row">
            <label style="cursor:pointer;"><input type="radio" name="q3a2" value="yes"> Yes</label>
            <label style="cursor:pointer; margin-left:12px;"><input type="radio" name="q3a2" value="no"> No</label>
          </div>
        </div>
        <div style="margin-bottom:12px;">
          <p style="font-size:0.92em;">3. In the converted NFA, what is &delta;<sub>N</sub>(Y, b)?</p>
          <div class="ctrl-row">
            <input type="text" id="q3a3" placeholder="e.g. {Z}" style="width:140px;" />
          </div>
        </div>
        <button class="btn btn-sm" onclick="q3Check()">Check All</button>
      </div>
    </div>
    <div>
      <div id="q3results" style="display:none;"></div>
      <div id="q3hint">
        <div class="key-idea">
          <h3>Conversion Steps</h3>
          <ol style="font-size:0.92em;">
            <li>Compute CL(q) for each state</li>
            <li>&delta;<sub>N</sub>(q, a) = &bigcup;<sub>p &isin; CL(q)</sub> &delta;<sub>E</sub>(p, a)</li>
            <li>F' = {q | CL(q) &cap; F &ne; &empty;}</li>
          </ol>
        </div>
        <div class="analogy" style="margin-top:12px;">
          <h3>Think About It</h3>
          <p>Y has an &epsilon;-transition to Z. Z is an accept state. What does that mean for CL(Y)? And if CL(Y) contains an accept state, what happens to Y in the converted NFA?</p>
        </div>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  // CL(X) = {X}, CL(Y) = {Y, Z}, CL(Z) = {Z}
  // Y is accept in converted NFA because CL(Y) contains Z
  // _N(Y, b): CL(Y) = {Y,Z}. _E(Y,b)={Z}, _E(Z,b)={}. Union = {Z}

  window.q3Check = function() {
    const results = document.getElementById('q3results');
    results.style.display = 'block';
    let html = '';
    let score = 0;

    // Q1: CL(Y)
    const a1 = document.getElementById('q3a1').value.trim().replace(/\s/g,'');
    const a1norm = a1.replace(/[{}]/g,'').split(',').map(s=>s.trim()).filter(Boolean).sort().join(',');
    const a1correct = a1norm === 'Y,Z';
    if (a1correct) score++;
    html += '<div style="padding:8px; margin-bottom:6px; border-radius:6px; background:'+(a1correct?'rgba(34,197,94,0.1)':'rgba(239,68,68,0.1)')+';">' +
      '<span style="color:'+(a1correct?'#a7f3d0':'#fecaca')+';">' +
      (a1correct ? '&#10003;' : '&#10007;') + ' <b>CL(Y)</b> = {Y, Z}. Y can reach Z via one &epsilon;-transition.</span></div>';

    // Q2: Y accept?
    const a2 = document.querySelector('input[name="q3a2"]:checked');
    const a2correct = a2 && a2.value === 'yes';
    if (a2correct) score++;
    html += '<div style="padding:8px; margin-bottom:6px; border-radius:6px; background:'+(a2correct?'rgba(34,197,94,0.1)':'rgba(239,68,68,0.1)')+';">' +
      '<span style="color:'+(a2correct?'#a7f3d0':'#fecaca')+';">' +
      (a2correct ? '&#10003;' : '&#10007;') + ' <b>Yes</b>, Y is an accept state. CL(Y) = {Y,Z} contains Z &isin; F.</span></div>';

    // Q3: _N(Y, b)
    const a3 = document.getElementById('q3a3').value.trim().replace(/\s/g,'');
    const a3norm = a3.replace(/[{}]/g,'').split(',').map(s=>s.trim()).filter(Boolean).sort().join(',');
    const a3correct = a3norm === 'Z';
    if (a3correct) score++;
    html += '<div style="padding:8px; margin-bottom:6px; border-radius:6px; background:'+(a3correct?'rgba(34,197,94,0.1)':'rgba(239,68,68,0.1)')+';">' +
      '<span style="color:'+(a3correct?'#a7f3d0':'#fecaca')+';">' +
      (a3correct ? '&#10003;' : '&#10007;') + ' <b>&delta;<sub>N</sub>(Y, b) = {Z}</b>. CL(Y)={Y,Z}. &delta;(Y,b)={Z}, &delta;(Z,b)={}. Union = {Z}.</span></div>';

    html += '<div style="margin-top:10px; font-size:1.1em; font-weight:600; color:'+(score===3?'#4ade80':score>=2?'#38bdf8':'#f87171')+';">Score: '+score+'/3' +
      (score===3?'  Perfect!':score>=2?'  Almost!':'  Review &epsilon;-closure!') + '</div>';

    results.innerHTML = html;
  };
})();
</script>

<!-- ==================== NAVIGATION ==================== -->
<div class="nav">
  <button id="prevBtn" onclick="navigate(-1)">&larr; Prev</button>
  <button id="nextBtn" onclick="navigate(1)">Next &rarr;</button>
</div>

<!-- ==================== NAVIGATION JS ==================== -->
<script>
const slideOrder = ['s1','s2','s3','s4','s5','s6','s7','s8','s9','s10','s11','sCA','s12','s13','sCB','s14','s15','s16','s17','sCC','s18','sQ1','sQ2','sQ3'];
let currentIdx = 0;

function showSlide(idx) {
  slideOrder.forEach(id => document.getElementById(id).classList.remove('active'));
  const slideEl = document.getElementById(slideOrder[idx]);
  slideEl.classList.add('active');
  slideEl.classList.remove('fade-in');
  void slideEl.offsetWidth;
  slideEl.classList.add('fade-in');
  document.getElementById('prevBtn').disabled = (idx === 0);
  document.getElementById('nextBtn').disabled = (idx === slideOrder.length - 1);
  const pct = slideOrder.length > 1 ? (idx / (slideOrder.length - 1)) * 100 : 0;
  document.getElementById('progress').style.width = pct + '%';
}

function navigate(dir) {
  const next = currentIdx + dir;
  if (next >= 0 && next < slideOrder.length) {
    currentIdx = next;
    showSlide(currentIdx);
  }
}

document.addEventListener('keydown', (e) => {
  const tag = document.activeElement.tagName;
  if (tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA') return;
  if (e.key === 'ArrowRight') { e.preventDefault(); navigate(1); }
  if (e.key === 'ArrowLeft') { e.preventDefault(); navigate(-1); }
});

showSlide(0);
</script>

</body>
</html>
