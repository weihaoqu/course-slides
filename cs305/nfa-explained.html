<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NFA Explained - A Student-Friendly Guide</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; background: #0f172a; color: #e2e8f0; }

  /* Slide system */
  .slide { display: none; min-height: 100vh; padding: 40px 60px; position: relative; }
  .slide.active { display: flex; flex-direction: column; justify-content: center; }
  .slide-number { position: absolute; bottom: 20px; right: 40px; color: #64748b; font-size: 14px; }

  /* Navigation */
  .nav { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; z-index: 100; }
  .nav button { background: #334155; border: 1px solid #475569; color: #e2e8f0; padding: 8px 20px; border-radius: 8px; cursor: pointer; font-size: 14px; transition: all 0.2s; }
  .nav button:hover { background: #475569; }
  .nav button:disabled { opacity: 0.3; cursor: not-allowed; }
  .progress { position: fixed; top: 0; left: 0; height: 3px; background: linear-gradient(90deg, #3b82f6, #8b5cf6); transition: width 0.3s; z-index: 100; }

  /* Typography */
  h1 { font-size: 2.8em; margin-bottom: 20px; background: linear-gradient(135deg, #3b82f6, #8b5cf6); -webkit-background-clip: text; -webkit-text-fill-color: transparent; line-height: 1.2; }
  h2 { font-size: 2em; margin-bottom: 16px; color: #93c5fd; }
  h3 { font-size: 1.4em; margin-bottom: 12px; color: #a5b4fc; }
  p, li { font-size: 1.15em; line-height: 1.7; color: #cbd5e1; margin-bottom: 10px; }
  .subtitle { font-size: 1.3em; color: #94a3b8; margin-bottom: 30px; }

  /* Layout helpers */
  .two-col { display: grid; grid-template-columns: 1fr 1fr; gap: 40px; align-items: start; }
  .center { text-align: center; }
  .mt { margin-top: 20px; }
  .mb { margin-bottom: 20px; }

  /* Code / diagram blocks */
  .diagram { background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 24px; font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; font-size: 1em; line-height: 1.6; white-space: pre; overflow-x: auto; margin: 16px 0; color: #a5f3fc; }
  .diagram.small { font-size: 0.85em; }

  /* Highlight boxes */
  .key-idea { background: linear-gradient(135deg, rgba(59,130,246,0.15), rgba(139,92,246,0.15)); border-left: 4px solid #3b82f6; border-radius: 0 12px 12px 0; padding: 20px 24px; margin: 16px 0; }
  .key-idea h3 { margin-bottom: 8px; }
  .warning { background: rgba(245,158,11,0.12); border-left: 4px solid #f59e0b; border-radius: 0 12px 12px 0; padding: 20px 24px; margin: 16px 0; }
  .warning h3 { color: #fbbf24; }
  .analogy { background: rgba(16,185,129,0.12); border-left: 4px solid #10b981; border-radius: 0 12px 12px 0; padding: 20px 24px; margin: 16px 0; }
  .analogy h3 { color: #34d399; }

  /* Table */
  table { border-collapse: collapse; margin: 16px 0; width: auto; }
  th, td { border: 1px solid #475569; padding: 10px 16px; text-align: center; }
  th { background: #334155; color: #93c5fd; font-weight: 600; }
  td { background: #1e293b; color: #e2e8f0; }
  tr.highlight td { background: rgba(59,130,246,0.2); }

  /* Animations */
  .fade-in { animation: fadeIn 0.5s ease-in; }
  @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

  /* Step-by-step reveal */
  .step { opacity: 0.25; transition: opacity 0.4s; margin: 8px 0; padding: 8px 12px; border-radius: 8px; }
  .step.revealed { opacity: 1; background: rgba(59,130,246,0.08); }

  .emoji { font-size: 1.5em; margin-right: 8px; }

  ul { padding-left: 24px; }
  ul li { margin-bottom: 8px; }

  .vs-box { display: flex; gap: 30px; align-items: stretch; margin: 20px 0; }
  .vs-card { flex: 1; background: #1e293b; border-radius: 12px; padding: 20px; border: 1px solid #334155; }
  .vs-card h3 { text-align: center; }
  .vs-card.dfa { border-color: #3b82f6; }
  .vs-card.nfa { border-color: #8b5cf6; }

  .arrow-chain { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin: 16px 0; font-family: monospace; font-size: 1.1em; }
  .arrow-chain .state { background: #334155; padding: 6px 14px; border-radius: 20px; color: #93c5fd; }
  .arrow-chain .state.accept { border: 2px solid #10b981; color: #34d399; }
  .arrow-chain .state.start { border: 2px solid #f59e0b; color: #fbbf24; }
  .arrow-chain .label { color: #f59e0b; font-weight: bold; }

  /* ===== INTERACTIVE COMPONENTS ===== */

  /* NFA Simulator */
  .sim-container { background: #1e293b; border: 1px solid #334155; border-radius: 16px; padding: 24px; margin: 16px 0; }
  .sim-controls { display: flex; gap: 12px; align-items: center; margin-bottom: 16px; flex-wrap: wrap; }
  .sim-controls input[type="text"] {
    background: #0f172a; border: 2px solid #475569; color: #e2e8f0; padding: 10px 16px;
    border-radius: 8px; font-family: 'SF Mono', monospace; font-size: 1.1em; width: 200px;
    outline: none; transition: border-color 0.2s;
  }
  .sim-controls input[type="text"]:focus { border-color: #3b82f6; }
  .sim-btn {
    padding: 10px 20px; border-radius: 8px; border: none; cursor: pointer;
    font-size: 0.95em; font-weight: 600; transition: all 0.2s;
  }
  .sim-btn.primary { background: #3b82f6; color: white; }
  .sim-btn.primary:hover { background: #2563eb; }
  .sim-btn.secondary { background: #475569; color: #e2e8f0; }
  .sim-btn.secondary:hover { background: #64748b; }
  .sim-btn.reset { background: #ef4444; color: white; }
  .sim-btn.reset:hover { background: #dc2626; }
  .sim-btn:disabled { opacity: 0.4; cursor: not-allowed; }

  .sim-status { display: flex; gap: 20px; align-items: center; margin-top: 12px; flex-wrap: wrap; }
  .sim-status .active-states {
    background: #0f172a; padding: 8px 16px; border-radius: 8px;
    font-family: monospace; font-size: 1em; color: #93c5fd;
  }
  .sim-status .input-display {
    font-family: monospace; font-size: 1.1em; color: #94a3b8;
  }
  .sim-status .input-display .consumed { color: #64748b; }
  .sim-status .input-display .current-char { color: #fbbf24; font-weight: bold; font-size: 1.3em; text-decoration: underline; }
  .sim-status .input-display .remaining { color: #e2e8f0; }

  .sim-verdict {
    margin-top: 12px; padding: 12px 20px; border-radius: 8px;
    font-size: 1.1em; font-weight: 600; text-align: center;
  }
  .sim-verdict.accept { background: rgba(16,185,129,0.2); color: #34d399; border: 2px solid #10b981; }
  .sim-verdict.reject { background: rgba(239,68,68,0.2); color: #f87171; border: 2px solid #ef4444; }

  /* SVG NFA diagram */
  .nfa-svg { width: 100%; max-width: 520px; margin: 0 auto; display: block; }
  .nfa-svg .state-circle { fill: #1e293b; stroke: #475569; stroke-width: 2; transition: all 0.3s; }
  .nfa-svg .state-circle.active { fill: #1e3a5f; stroke: #3b82f6; stroke-width: 3; filter: drop-shadow(0 0 8px rgba(59,130,246,0.5)); }
  .nfa-svg .state-circle.dead { fill: #1e293b; stroke: #ef4444; stroke-width: 2; opacity: 0.4; }
  .nfa-svg .state-circle.accepted { fill: #064e3b; stroke: #10b981; stroke-width: 3; filter: drop-shadow(0 0 10px rgba(16,185,129,0.6)); }
  .nfa-svg .state-label { fill: #e2e8f0; font-family: 'SF Mono', monospace; font-size: 14px; text-anchor: middle; dominant-baseline: central; }
  .nfa-svg .arrow-line { stroke: #475569; stroke-width: 2; fill: none; marker-end: url(#arrowhead); }
  .nfa-svg .arrow-label { fill: #f59e0b; font-family: 'SF Mono', monospace; font-size: 13px; text-anchor: middle; }
  .nfa-svg .accept-inner { fill: none; stroke: #475569; stroke-width: 2; transition: all 0.3s; }
  .nfa-svg .accept-inner.active { stroke: #3b82f6; }
  .nfa-svg .accept-inner.accepted { stroke: #10b981; }

  /* Quiz / Challenge styles */
  .challenge-container { background: #1e293b; border: 1px solid #334155; border-radius: 16px; padding: 24px; margin: 16px 0; }
  .quiz-btn {
    padding: 12px 28px; border-radius: 8px; border: 2px solid #475569;
    background: #1e293b; color: #e2e8f0; cursor: pointer;
    font-size: 1em; font-weight: 600; transition: all 0.2s; margin: 6px;
  }
  .quiz-btn:hover { border-color: #3b82f6; background: #1e3a5f; }
  .quiz-btn.correct { border-color: #10b981; background: rgba(16,185,129,0.2); color: #34d399; }
  .quiz-btn.wrong { border-color: #ef4444; background: rgba(239,68,68,0.2); color: #f87171; }
  .quiz-btn:disabled { cursor: not-allowed; opacity: 0.7; }

  .feedback-box {
    margin-top: 16px; padding: 16px 20px; border-radius: 8px;
    font-size: 1em; line-height: 1.6; display: none;
  }
  .feedback-box.show { display: block; }
  .feedback-box.correct { background: rgba(16,185,129,0.15); border-left: 4px solid #10b981; color: #a7f3d0; }
  .feedback-box.wrong { background: rgba(239,68,68,0.15); border-left: 4px solid #ef4444; color: #fecaca; }

  .score-display {
    font-size: 1.1em; color: #93c5fd; margin-bottom: 12px;
  }

  /* Subset construction challenge */
  .subset-grid { display: inline-grid; gap: 0; margin: 16px 0; }
  .subset-grid .cell {
    border: 1px solid #475569; padding: 10px 14px; text-align: center;
    font-family: monospace; font-size: 0.95em; min-width: 90px; transition: all 0.2s;
  }
  .subset-grid .cell.header { background: #334155; color: #93c5fd; font-weight: 600; }
  .subset-grid .cell.editable { background: #0f172a; color: #64748b; cursor: pointer; }
  .subset-grid .cell.editable:hover { background: #1e3a5f; border-color: #3b82f6; }
  .subset-grid .cell.filled { color: #e2e8f0; }
  .subset-grid .cell.correct-cell { background: rgba(16,185,129,0.2); color: #34d399; border-color: #10b981; }
  .subset-grid .cell.wrong-cell { background: rgba(239,68,68,0.2); color: #f87171; border-color: #ef4444; }

  /* State picker modal */
  .state-picker {
    display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: #1e293b; border: 2px solid #3b82f6; border-radius: 16px; padding: 24px;
    z-index: 200; min-width: 280px;
  }
  .state-picker.show { display: block; }
  .state-picker-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 199; }
  .state-picker-overlay.show { display: block; }
  .state-picker h3 { text-align: center; margin-bottom: 16px; }
  .state-picker .state-options { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-bottom: 16px; }
  .state-picker .state-toggle {
    padding: 8px 16px; border-radius: 20px; border: 2px solid #475569;
    background: #0f172a; color: #e2e8f0; cursor: pointer; font-family: monospace;
    font-size: 1em; transition: all 0.2s;
  }
  .state-picker .state-toggle.selected { border-color: #3b82f6; background: #1e3a5f; color: #93c5fd; }
  .state-picker .picker-actions { display: flex; gap: 12px; justify-content: center; }

  /* Spot the bug */
  .bug-table { border-collapse: collapse; margin: 12px 0; }
  .bug-table td, .bug-table th { border: 1px solid #475569; padding: 10px 14px; text-align: center; font-family: monospace; }
  .bug-table th { background: #334155; color: #93c5fd; }
  .bug-table td { background: #1e293b; color: #e2e8f0; }
  .bug-table td.clickable { cursor: pointer; transition: all 0.2s; }
  .bug-table td.clickable:hover { background: #1e3a5f; border-color: #3b82f6; }
  .bug-table td.bug-found { background: rgba(16,185,129,0.2); color: #34d399; border: 2px solid #10b981; }
  .bug-table td.bug-miss { background: rgba(239,68,68,0.2); color: #f87171; border: 2px solid #ef4444; }
  .bug-table td.bug-actual { background: rgba(245,158,11,0.2); color: #fbbf24; border: 2px solid #f59e0b; }

  /* Subset Construction Visualizer */
  .sc-container { display: grid; grid-template-columns: 1fr 1.3fr; gap: 24px; align-items: start; }
  .sc-panel { background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 20px; }
  .sc-panel h3 { margin-bottom: 12px; }
  .sc-controls { display: flex; gap: 10px; margin-bottom: 14px; flex-wrap: wrap; }
  .sc-log { background: #0f172a; border: 1px solid #334155; border-radius: 8px; padding: 12px 16px; font-family: 'SF Mono', monospace; font-size: 0.82em; line-height: 1.6; color: #94a3b8; max-height: 90px; overflow-y: auto; margin-top: 12px; }
  .sc-log .log-new { color: #34d399; }
  .sc-log .log-seen { color: #93c5fd; }
  .sc-table { border-collapse: collapse; width: 100%; margin-bottom: 14px; font-size: 0.9em; }
  .sc-table th, .sc-table td { border: 1px solid #475569; padding: 7px 10px; text-align: center; font-family: monospace; }
  .sc-table th { background: #334155; color: #93c5fd; }
  .sc-table td { background: #1e293b; color: #e2e8f0; }
  .sc-table tr.sc-processing td { background: rgba(59,130,246,0.18); border-color: #3b82f6; }
  .sc-table tr.sc-new td { animation: scGlow 0.6s ease-out; }
  @keyframes scGlow { from { background: rgba(16,185,129,0.3); } to { background: #1e293b; } }
  .sc-dfa-svg { width: 100%; max-width: 480px; margin: 0 auto; display: block; }
  .sc-dfa-svg .dfa-node { fill: #1e293b; stroke: #475569; stroke-width: 2; transition: all 0.4s; }
  .sc-dfa-svg .dfa-node.sc-active { fill: #1e3a5f; stroke: #3b82f6; stroke-width: 3; filter: drop-shadow(0 0 8px rgba(59,130,246,0.5)); }
  .sc-dfa-svg .dfa-node.sc-accept { stroke: #10b981; stroke-width: 2; }
  .sc-dfa-svg .dfa-node.sc-accept.sc-active { stroke: #10b981; stroke-width: 3; filter: drop-shadow(0 0 8px rgba(16,185,129,0.5)); }
  .sc-dfa-svg .dfa-label { fill: #e2e8f0; font-family: 'SF Mono', monospace; font-size: 11px; text-anchor: middle; dominant-baseline: central; }
  .sc-dfa-svg .dfa-arrow { stroke: #475569; stroke-width: 2; fill: none; marker-end: url(#scArrow); }
  .sc-dfa-svg .dfa-arrow-label { fill: #f59e0b; font-family: 'SF Mono', monospace; font-size: 11px; text-anchor: middle; }
  .sc-dfa-svg .dfa-arrow-new { animation: scArrowIn 0.5s ease-out; }
  @keyframes scArrowIn { from { opacity: 0; stroke-dashoffset: 40; } to { opacity: 1; stroke-dashoffset: 0; } }
  .sc-done { background: rgba(16,185,129,0.15); border: 2px solid #10b981; border-radius: 8px; padding: 12px 16px; color: #34d399; font-weight: 600; text-align: center; margin-top: 10px; }

  /* Epsilon-NFA SVG */
  .enfa-svg { width: 100%; max-width: 500px; margin: 0 auto; display: block; }
  .enfa-svg .eps-arrow { stroke: #8b5cf6; stroke-width: 2; fill: none; stroke-dasharray: 6 4; }
  .enfa-svg .eps-label { fill: #a78bfa; font-family: 'SF Mono', monospace; font-size: 13px; text-anchor: middle; font-style: italic; }
  .enfa-svg .eps-arrow.ecl-glow { stroke: #c084fc; stroke-width: 3; filter: drop-shadow(0 0 6px rgba(139,92,246,0.7)); stroke-dasharray: none; }
  .enfa-svg .state-circle.ecl-found { fill: #1e3a5f; stroke: #3b82f6; stroke-width: 3; filter: drop-shadow(0 0 8px rgba(59,130,246,0.5)); }
  @keyframes eclPulse { 0% { filter: drop-shadow(0 0 12px rgba(59,130,246,0.9)); } 100% { filter: drop-shadow(0 0 6px rgba(59,130,246,0.4)); } }
  .enfa-svg .state-circle.ecl-discover { fill: #1e3a5f; stroke: #3b82f6; stroke-width: 3; animation: eclPulse 0.5s ease-out; filter: drop-shadow(0 0 8px rgba(59,130,246,0.5)); }

  /* Epsilon-Closure Explorer */
  .ecl-buttons { display: flex; gap: 8px; margin: 12px 0; flex-wrap: wrap; }
  .ecl-state-btn {
    padding: 8px 18px; border-radius: 20px; border: 2px solid #475569;
    background: #1e293b; color: #e2e8f0; cursor: pointer; font-family: 'SF Mono', monospace;
    font-size: 1em; font-weight: 600; transition: all 0.2s;
  }
  .ecl-state-btn:hover { border-color: #3b82f6; background: #1e3a5f; }
  .ecl-state-btn.ecl-selected { border-color: #3b82f6; background: #1e3a5f; color: #93c5fd; }
  .ecl-result {
    background: #0f172a; border: 1px solid #334155; border-radius: 8px; padding: 14px 18px;
    font-family: 'SF Mono', monospace; font-size: 0.95em; line-height: 1.7; color: #94a3b8;
    min-height: 60px; margin-top: 12px;
  }
  .ecl-result .ecl-set { color: #93c5fd; font-weight: 600; }
  .ecl-result .ecl-step { color: #a78bfa; }
  .ecl-result .ecl-chain { color: #34d399; }

  /* Real-world analogy cards */
  .analogy-cards { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin: 20px 0; }
  .analogy-card {
    background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 20px;
    transition: transform 0.2s, border-color 0.2s;
  }
  .analogy-card:hover { transform: translateY(-4px); border-color: #3b82f6; }
  .analogy-card .card-icon { font-size: 2.2em; margin-bottom: 12px; }
  .analogy-card h3 { font-size: 1.15em; margin-bottom: 8px; }
  .analogy-card p { font-size: 0.95em; }

  @media (max-width: 900px) {
    .two-col, .analogy-cards, .sc-container { grid-template-columns: 1fr; }
    .slide { padding: 20px 24px; }
    h1 { font-size: 2em; }
    .vs-box { flex-direction: column; }
  }
</style>
</head>
<body>

<div class="progress" id="progress"></div>

<!-- ==================== SLIDE 1: TITLE ==================== -->
<div class="slide active" id="s1">
  <div class="center">
    <h1>Nondeterministic Finite Automata (NFA)</h1>
    <p class="subtitle">A step-by-step guide to understanding NFAs, Subset Construction, and epsilon-transitions</p>
    <div style="margin-top: 40px; color: #64748b;">
      <p>Based on CS154/CS305 lecture materials (Ullman)</p>
      <p style="margin-top:20px; font-size: 0.9em;">Use <b>Arrow Keys</b> or the buttons below to navigate. Press <b>S</b> to step through animations.</p>
    </div>
  </div>
  <div class="slide-number">1</div>
</div>

<!-- ==================== SLIDE 2: BIG PICTURE ==================== -->
<div class="slide" id="s2">
  <h1>The Big Picture</h1>
  <p class="subtitle">Where does this lecture fit?</p>
  <div class="diagram">
                     All recognize the SAME languages!
                        (the Regular Languages)

   +---------+        +---------+        +-----------+
   |   DFA   | &lt;----&gt; |   NFA   | &lt;----&gt; |  epsilon-  |
   |         |        |         |        |    NFA     |
   +---------+        +---------+        +-----------+
       ^                                       ^
       |                                       |
  Only one that        "Free" transitions      |
  can actually         (no input consumed)     |
  be executed                                  |
  on a computer       Easiest to design -------+

  This lecture teaches you HOW to convert between them.
  </div>
  <div class="key-idea">
    <h3>Why care?</h3>
    <p>NFAs are <b>much easier to design</b> (fewer states, more flexibility). But computers can only <b>run DFAs</b> (one state at a time). So we need a way to convert NFA -> DFA. That's the <b>Subset Construction</b>.</p>
  </div>
  <div class="slide-number">2</div>
</div>

<!-- ==================== SLIDE 3: DFA RECAP ==================== -->
<div class="slide" id="s3">
  <h1>Quick Recap: What's a DFA?</h1>
  <p class="subtitle">Before we learn NFAs, let's remember DFAs</p>
  <div class="two-col">
    <div>
      <p>A <b>DFA</b> (Deterministic Finite Automaton) has:</p>
      <ul>
        <li><b>Exactly one</b> current state at any time</li>
        <li>For each state + input symbol, there is <b>exactly one</b> next state</li>
        <li>No choices, no ambiguity</li>
      </ul>
      <div class="diagram">
  Input: "01"

  Step 0: in state A          (start)
  Step 1: read '0' -> go to B (only option)
  Step 2: read '1' -> go to C (only option)
  Done: C is accept? -> YES or NO
      </div>
    </div>
    <div>
      <div class="analogy">
        <h3>Analogy: Following GPS</h3>
        <p>A DFA is like following GPS directions. At every intersection, you're told <b>exactly one</b> way to turn. There are no choices -- you just follow the instructions.</p>
      </div>
      <div class="diagram">
       ----0--->         ----1--->
  -->( A )         ( B )         (( C ))
       <---1----         <---0----

  start state: A
  accept state: C (double circle)
  Every state has exactly one arrow per symbol.
      </div>
    </div>
  </div>
  <div class="slide-number">3</div>
</div>

<!-- ==================== SLIDE 4: WHAT IS AN NFA ==================== -->
<div class="slide" id="s4">
  <h1>So What's an NFA?</h1>
  <p class="subtitle">The key difference: CHOICE</p>
  <div class="two-col">
    <div>
      <p>An <b>NFA</b> (Nondeterministic Finite Automaton) changes two rules:</p>
      <ul>
        <li>From one state on one input, there can be <b>zero, one, or MANY</b> possible next states</li>
        <li>The NFA can be in <b>several states at once</b> (or conceptually, it explores all paths simultaneously)</li>
      </ul>
      <div class="key-idea">
        <h3>Acceptance Rule</h3>
        <p>An NFA accepts a string if <b>ANY</b> sequence of choices leads to a final state. It only needs <b>one</b> successful path.</p>
      </div>
    </div>
    <div>
      <div class="analogy">
        <h3>Analogy: A Maze</h3>
        <p>Imagine you're in a maze with forking paths. A DFA is like a maze where every junction has exactly one door. An NFA is like a maze where junctions can have <b>multiple doors</b> (or even zero doors!).</p>
        <p style="margin-top:10px">The NFA "accepts" if there <b>exists</b> some path through the maze from start to exit. It's as if you can clone yourself at every fork and explore all paths at once.</p>
      </div>
      <div class="diagram">
        NFA: "guesses right"

  -->( q0 )---0--->( q0 )   (stay)
        |
        +---0--->( q1 )---1--->((  q2 ))

  On input '0' from q0:
    choice 1: stay in q0
    choice 2: move to q1
  Both happen simultaneously!
      </div>
    </div>
  </div>
  <div class="slide-number">4</div>
</div>

<!-- ==================== SLIDE 5: NFAs IN THE REAL WORLD (NEW) ==================== -->
<div class="slide" id="s5">
  <h1>NFAs in the Real World</h1>
  <p class="subtitle">You've been using nondeterminism your whole life</p>
  <div class="analogy-cards">
    <div class="analogy-card">
      <div class="card-icon">&#x1F50D;</div>
      <h3>Spell-Checker</h3>
      <p>When you type <b>"helo"</b>, the spell-checker simultaneously considers <b>"hello", "help", "halo", "hero"</b> -- exploring multiple correction paths at once, just like an NFA.</p>
      <p style="margin-top:8px; color:#94a3b8; font-size:0.85em;">Each candidate is a parallel "branch" of computation.</p>
    </div>
    <div class="analogy-card">
      <div class="card-icon">&#x1F5FA;</div>
      <h3>GPS Navigation</h3>
      <p>Your GPS shows <b>3 routes</b> simultaneously -- via highway, through downtown, scenic route. An NFA explores all paths; a DFA would commit to just one.</p>
      <p style="margin-top:8px; color:#94a3b8; font-size:0.85em;">If ANY route reaches the destination, you accept it.</p>
    </div>
    <div class="analogy-card">
      <div class="card-icon">&#x1F4BB;</div>
      <h3>grep / Regex</h3>
      <p>When you run <code style="color:#a5f3fc;">grep "ab*c"</code>, it compiles to an NFA internally. The engine explores multiple match positions <b>simultaneously</b>.</p>
      <p style="margin-top:8px; color:#94a3b8; font-size:0.85em;">That's why regex is fast -- NFA parallelism!</p>
    </div>
  </div>
  <div class="key-idea">
    <h3>The Pattern</h3>
    <p>In every example, the system <b>explores multiple possibilities at once</b> and succeeds if <b>any one</b> works out. That's exactly what an NFA does -- parallel exploration with existential acceptance.</p>
  </div>
  <div class="slide-number">5</div>
</div>

<!-- ==================== SLIDE 6: WHY NONDETERMINISM MATTERS (NEW) ==================== -->
<div class="slide" id="s6">
  <h1>Why Nondeterminism Matters</h1>
  <p class="subtitle">It's a design tool, not a physical machine</p>
  <div class="two-col">
    <div>
      <div class="key-idea">
        <h3>Nondeterminism = Description Power</h3>
        <p>An NFA lets you describe <b>WHAT</b> to recognize, not <b>HOW</b> to recognize it. You say "the string ends with 01" and the NFA just guesses when the ending starts.</p>
      </div>
      <div class="step">
        <h3>Design Advantage</h3>
        <p>NFAs are often <b>exponentially</b> more compact. An NFA for "n-th symbol from the end is 1" needs ~n states. The equivalent DFA needs ~2<sup>n</sup> states!</p>
      </div>
      <div class="step">
        <h3>Composability</h3>
        <p>Want L1 &cup; L2? Just add a new start state with epsilon-transitions to both NFAs. Try doing that with DFAs -- it's much harder!</p>
      </div>
    </div>
    <div>
      <div class="warning">
        <h3>Common Misconception</h3>
        <p>"NFAs are more powerful than DFAs."</p>
        <p style="margin-top:8px;"><b>FALSE!</b> They recognize <b>exactly the same languages</b>. Nondeterminism gives you design convenience, not extra power. The subset construction proves this.</p>
      </div>
      <div class="step">
        <div class="analogy">
          <h3>Foreshadowing: P vs NP</h3>
          <p>The "N" in NP stands for <b>Nondeterministic</b> Polynomial time. Same idea, grander scale: "if I could magically guess the right answer, could I verify it quickly?"</p>
          <p style="margin-top:8px;">For finite automata, nondeterminism doesn't add power. For polynomial time... <b>that's the biggest open question in CS!</b></p>
        </div>
      </div>
    </div>
  </div>
  <div class="slide-number">6</div>
</div>

<!-- ==================== SLIDE 7: DFA vs NFA SIDE BY SIDE ==================== -->
<div class="slide" id="s7">
  <h1>DFA vs NFA: Side by Side</h1>
  <div class="vs-box">
    <div class="vs-card dfa">
      <h3 style="color: #60a5fa;">DFA (Deterministic)</h3>
      <div class="diagram" style="font-size: 0.85em;">
  delta(q, a) = ONE state

  "From state q, reading symbol a,
   go to exactly ONE state."
      </div>
      <ul>
        <li>Always in <b>exactly one</b> state</li>
        <li>Every state has <b>exactly one</b> transition per input symbol</li>
        <li>No dead ends (total function)</li>
        <li><b>Easy to simulate</b> on a computer</li>
      </ul>
    </div>
    <div class="vs-card nfa">
      <h3 style="color: #a78bfa;">NFA (Nondeterministic)</h3>
      <div class="diagram" style="font-size: 0.85em;">
  delta(q, a) = SET of states

  "From state q, reading symbol a,
   go to any of THESE states."
  (could be 0, 1, or many states)
      </div>
      <ul>
        <li>Can be in <b>multiple states</b> simultaneously</li>
        <li>A state may have <b>0 or many</b> transitions per symbol</li>
        <li>Dead ends allowed (just kills that path)</li>
        <li><b>Easier to design</b> (more compact)</li>
      </ul>
    </div>
  </div>
  <div class="warning">
    <h3>The Punchline</h3>
    <p>Despite looking more powerful, NFAs recognize <b>exactly the same languages</b> as DFAs -- the regular languages. NFAs are just a more convenient notation. We can always convert NFA -> DFA.</p>
  </div>
  <div class="slide-number">7</div>
</div>

<!-- ==================== SLIDE 8: FORMAL DEFINITION ==================== -->
<div class="slide" id="s8">
  <h1>Formal Definition of an NFA</h1>
  <p class="subtitle">The 5-tuple: same components as a DFA, one key difference</p>
  <div class="two-col">
    <div>
      <p>An NFA is a 5-tuple <b>(Q, &Sigma;, &delta;, q<sub>0</sub>, F)</b>:</p>
      <table>
        <tr><th>Symbol</th><th>Meaning</th><th>Same as DFA?</th></tr>
        <tr><td><b>Q</b></td><td>Finite set of states</td><td>Yes</td></tr>
        <tr><td><b>&Sigma;</b></td><td>Input alphabet</td><td>Yes</td></tr>
        <tr><td><b>&delta;</b></td><td>Transition function</td><td style="color:#f59e0b;">DIFFERENT!</td></tr>
        <tr><td><b>q<sub>0</sub></b></td><td>Start state (one state)</td><td>Yes</td></tr>
        <tr><td><b>F</b></td><td>Set of final/accept states</td><td>Yes</td></tr>
      </table>
    </div>
    <div>
      <div class="key-idea">
        <h3>The Key Difference: &delta;</h3>
        <p><b>DFA:</b> &delta;(q, a) = <b>one state</b> (a single state p)</p>
        <p><b>NFA:</b> &delta;(q, a) = <b>a SET of states</b> (like {p, r, s} or even {} )</p>
        <p style="margin-top:10px">That's it! The only formal difference is that &delta; returns a <b>set</b> instead of a single state.</p>
      </div>
      <div class="diagram" style="font-size: 0.9em;">
  DFA:  delta(q0, 'a') = q1      (one answer)
  NFA:  delta(q0, 'a') = {q1,q3} (multiple answers)
  NFA:  delta(q2, 'b') = {}      (no answer = dead end)
      </div>
    </div>
  </div>
  <div class="slide-number">8</div>
</div>

<!-- ==================== SLIDE 9: CHESSBOARD EXAMPLE INTRO ==================== -->
<div class="slide" id="s9">
  <h1>Example: Moves on a Chessboard</h1>
  <p class="subtitle">The slides' first example -- let's break it down carefully</p>
  <div class="two-col">
    <div>
      <h3>The Setup</h3>
      <p>Imagine a 3x3 chessboard. The squares alternate in color (like a real chessboard):</p>
      <div class="diagram">
   +-----+-----+-----+
   |  1  |  2  |  3  |
   | red | BLK | red |
   +-----+-----+-----+
   |  4  |  5  |  6  |
   | BLK | red | BLK |
   +-----+-----+-----+
   |  7  |  8  |  9  |
   | red | BLK | red |
   +-----+-----+-----+
      </div>
    </div>
    <div>
      <h3>Building the NFA</h3>
      <ul>
        <li><b>States</b> = the 9 squares (1 through 9)</li>
        <li><b>Alphabet</b> = {r, b}
          <ul>
            <li><b>r</b> = "move to an adjacent <b>red</b> square"</li>
            <li><b>b</b> = "move to an adjacent <b>black</b> square"</li>
          </ul>
        </li>
        <li><b>Start state</b> = square 1 (top-left)</li>
        <li><b>Accept state</b> = square 9 (bottom-right, opposite corner)</li>
      </ul>
      <div class="key-idea">
        <h3>Why is this an NFA?</h3>
        <p>From square 5 (center), reading 'r', you could move to 1, 3, 7, or 9. That's <b>four choices</b> -- impossible in a DFA, natural in an NFA!</p>
      </div>
    </div>
  </div>
  <div class="slide-number">9</div>
</div>

<!-- ==================== SLIDE 10: CHESSBOARD TRANSITION TABLE ==================== -->
<div class="slide" id="s10">
  <h1>Chessboard: The Transition Table</h1>
  <p class="subtitle">Where can you go from each square?</p>
  <div class="two-col">
    <div>
      <p>"Adjacent" = shares an edge or corner (king's moves in chess).</p>
      <table>
        <tr><th>State</th><th>&delta;(_, r)</th><th>&delta;(_, b)</th></tr>
        <tr><td><b>-> 1</b></td><td>{5}</td><td>{2, 4}</td></tr>
        <tr><td>2</td><td>{1, 3, 5}</td><td>{4, 6}</td></tr>
        <tr><td>3</td><td>{5}</td><td>{2, 6}</td></tr>
        <tr><td>4</td><td>{1, 5, 7}</td><td>{2, 8}</td></tr>
        <tr><td>5</td><td>{1, 3, 7, 9}</td><td>{2, 4, 6, 8}</td></tr>
        <tr><td>6</td><td>{3, 5, 9}</td><td>{2, 8}</td></tr>
        <tr><td>7</td><td>{5}</td><td>{4, 8}</td></tr>
        <tr><td>8</td><td>{5, 7, 9}</td><td>{4, 6}</td></tr>
        <tr class="highlight"><td><b>* 9</b></td><td>{5}</td><td>{6, 8}</td></tr>
      </table>
      <p style="font-size:0.9em; color:#94a3b8;">-> = start, * = accept</p>
    </div>
    <div>
      <h3>Reading the table</h3>
      <p>Row "5", column "r" says <b>{1,3,7,9}</b>. This means: "from center square 5, if you move to an adjacent <b>red</b> square, you could go to any corner."</p>

      <h3 style="margin-top:20px;">Does the NFA accept "rr"?</h3>
      <div class="diagram" style="font-size: 0.9em;">
  Start: {1}

  Read 'r': from 1, go to {5}

  Read 'r': from 5, go to {1,3,7,9}

  9 is in the final set, and 9 is
  an accept state. So: ACCEPT!

  (Shortest path: 1 → 5 → 9,
   moving through red squares only.)
      </div>
    </div>
  </div>
  <div class="slide-number">10</div>
</div>

<!-- ==================== SLIDE 11: INTERACTIVE NFA SIMULATOR (NEW) ==================== -->
<div class="slide" id="s11">
  <h1>Try It Yourself: NFA Simulator</h1>
  <p class="subtitle">Watch the NFA for "ends with 01" process your string step by step</p>
  <div class="two-col">
    <div>
      <svg class="nfa-svg" viewBox="0 0 480 180" id="nfaSvg">
        <defs>
          <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#475569" />
          </marker>
        </defs>
        <!-- Start arrow -->
        <line x1="30" y1="90" x2="68" y2="90" class="arrow-line" />
        <!-- q0 -->
        <circle cx="100" cy="90" r="30" class="state-circle" id="svg-q0" />
        <text x="100" y="90" class="state-label">q0</text>
        <!-- Self-loop on q0 for 0,1 -->
        <path d="M 85 62 C 70 20, 130 20, 115 62" class="arrow-line" fill="none" />
        <text x="100" y="30" class="arrow-label">0, 1</text>
        <!-- q0 -> q1 on 0 -->
        <line x1="130" y1="90" x2="218" y2="90" class="arrow-line" />
        <text x="175" y="80" class="arrow-label">0</text>
        <!-- q1 -->
        <circle cx="250" cy="90" r="30" class="state-circle" id="svg-q1" />
        <text x="250" y="90" class="state-label">q1</text>
        <!-- q1 -> q2 on 1 -->
        <line x1="280" y1="90" x2="368" y2="90" class="arrow-line" />
        <text x="325" y="80" class="arrow-label">1</text>
        <!-- q2 (accept - double circle) -->
        <circle cx="400" cy="90" r="30" class="state-circle" id="svg-q2" />
        <circle cx="400" cy="90" r="24" class="accept-inner" id="svg-q2-inner" />
        <text x="400" y="90" class="state-label">q2</text>
      </svg>
      <p style="font-size:0.9em; color:#94a3b8; text-align:center; margin-top:4px;">NFA: accepts strings over {0,1} that end with "01"</p>
    </div>
    <div>
      <div class="sim-container" id="simContainer">
        <div class="sim-controls">
          <input type="text" id="simInput" placeholder="e.g. 1001" maxlength="20" />
          <button class="sim-btn primary" id="simStepBtn" onclick="simStep()">Step</button>
          <button class="sim-btn secondary" id="simRunBtn" onclick="simRun()">Run</button>
          <button class="sim-btn reset" id="simResetBtn" onclick="simReset()">Reset</button>
        </div>
        <div class="sim-status">
          <div class="input-display" id="simInputDisplay"></div>
        </div>
        <div class="sim-status" style="margin-top:8px;">
          <span style="color:#94a3b8;">Active states:</span>
          <span class="active-states" id="simActiveStates">-</span>
        </div>
        <div id="simVerdict"></div>
      </div>
    </div>
  </div>
  <div class="slide-number">11</div>
</div>

<!-- ==================== SLIDE 12: EXTENDED TRANSITION FUNCTION ==================== -->
<div class="slide" id="s12">
  <h1>Extended Transition Function</h1>
  <p class="subtitle">How &delta; works on entire strings, not just single symbols</p>
  <div class="two-col">
    <div>
      <p>We need to extend &delta;(q, a) -- which handles one symbol -- to &delta;(q, w) -- which handles an entire string w.</p>
      <h3>The definition (by induction):</h3>
      <div class="key-idea">
        <p><b>Base case:</b> &delta;(q, &epsilon;) = {q}</p>
        <p style="color:#94a3b8;">"Reading the empty string from q, you're still just at q."</p>
        <p style="margin-top:12px;"><b>Inductive case:</b> &delta;(q, wa) = &Union; &delta;(p, a) for all p in &delta;(q, w)</p>
        <p style="color:#94a3b8;">"To process string wa: first process w to get a set of states S. Then, from each state in S, follow the transition on symbol a. Union all results."</p>
      </div>
    </div>
    <div>
      <div class="analogy">
        <h3>Analogy: Spreading Water</h3>
        <p>Think of the NFA as a network of pipes. You pour water in at the start state. At each symbol, water flows through all possible transitions. The water "spreads" to all reachable states simultaneously. At the end, if water reaches any accept state, the string is accepted.</p>
      </div>
      <h3>Language of an NFA</h3>
      <p>A string w is <b>accepted</b> if &delta;(q<sub>0</sub>, w) contains <b>at least one</b> final state.</p>
      <p>The <b>language</b> L(N) = { w | &delta;(q<sub>0</sub>, w) &cap; F &ne; &empty; }</p>
    </div>
  </div>
  <div class="slide-number">12</div>
</div>

<!-- ==================== SLIDE 13: EQUIVALENCE INTRO ==================== -->
<div class="slide" id="s13">
  <h1>NFAs and DFAs are Equivalent!</h1>
  <p class="subtitle">The most important theorem of this lecture</p>
  <div class="key-idea">
    <h3>Theorem</h3>
    <p>For every NFA, there exists a DFA that accepts <b>exactly the same language</b>. And vice versa.</p>
  </div>
  <h3>Direction 1: DFA -> NFA (trivial)</h3>
  <p>Every DFA is already an NFA! Just wrap the single next-state in a set:</p>
  <div class="diagram" style="font-size: 0.95em;">
  If the DFA has:   delta_D(q, a) = p        (single state)
  Make the NFA:     delta_N(q, a) = {p}      (set containing one state)

  The NFA always has sets of size 1, so it behaves identically to the DFA.
  </div>
  <h3 style="margin-top: 20px;">Direction 2: NFA -> DFA (the hard part!)</h3>
  <p>This requires the <b>Subset Construction</b> -- the central algorithm of this lecture.</p>
  <div class="warning">
    <h3>Heads up: exponential blowup</h3>
    <p>If the NFA has <b>n</b> states, the equivalent DFA can have up to <b>2<sup>n</sup></b> states! (one for each subset of NFA states). In practice it's usually much less, but the worst case is real.</p>
  </div>
  <div class="slide-number">13</div>
</div>

<!-- ==================== SLIDE 14: SUBSET CONSTRUCTION IDEA ==================== -->
<div class="slide" id="s14">
  <h1>Subset Construction: The Idea</h1>
  <p class="subtitle">The core insight behind converting NFA to DFA</p>
  <div class="two-col">
    <div>
      <div class="key-idea">
        <h3>Core Insight</h3>
        <p>An NFA can be in a <b>set</b> of states at once. A DFA must be in <b>one</b> state at a time. Solution: make each DFA state <b>represent a set of NFA states</b>!</p>
      </div>
      <div class="diagram">
  NFA is in states {q1, q3, q5}
         |
         | becomes ONE DFA state
         v
  DFA state named "{q1,q3,q5}"
      </div>
      <p>Each DFA state is <b>named</b> by a set, but it IS a single state in the DFA. Don't confuse the name with multiple states!</p>
    </div>
    <div>
      <h3>The Construction Recipe</h3>
      <p>Given NFA (Q, &Sigma;, &delta;<sub>N</sub>, q<sub>0</sub>, F), build DFA:</p>
      <table>
        <tr><th>DFA component</th><th>How to build it</th></tr>
        <tr><td>States</td><td>2<sup>Q</sup> = all subsets of Q</td></tr>
        <tr><td>Alphabet</td><td>Same &Sigma;</td></tr>
        <tr><td>Start state</td><td>{q<sub>0</sub>}</td></tr>
        <tr><td>Accept states</td><td>Any subset containing a member of F</td></tr>
        <tr><td>&delta;<sub>D</sub>(S, a)</td><td>Union of &delta;<sub>N</sub>(q, a) for all q in S</td></tr>
      </table>
      <div class="warning">
        <h3>Critical point</h3>
        <p>{p, q} is a <b>single DFA state</b> whose <b>name</b> happens to be a set. Don't think of it as "being in two places."</p>
      </div>
    </div>
  </div>
  <div class="slide-number">14</div>
</div>

<!-- ==================== SLIDE 15: SUBSET CONSTRUCTION WALKTHROUGH ==================== -->
<div class="slide" id="s15">
  <h1>Subset Construction: Step by Step</h1>
  <p class="subtitle">Let's convert the chessboard NFA to a DFA (lazy construction)</p>
  <div class="two-col">
    <div>
      <h3>NFA Transition Table (reference)</h3>
      <table style="font-size: 0.85em;">
        <tr><th></th><th>r</th><th>b</th></tr>
        <tr><td>-> 1</td><td>5</td><td>2,4</td></tr>
        <tr><td>2</td><td>1,3,5</td><td>4,6</td></tr>
        <tr><td>3</td><td>5</td><td>2,6</td></tr>
        <tr><td>4</td><td>1,5,7</td><td>2,8</td></tr>
        <tr><td>5</td><td>1,3,7,9</td><td>2,4,6,8</td></tr>
        <tr><td>6</td><td>3,5,9</td><td>2,8</td></tr>
        <tr><td>7</td><td>5</td><td>4,8</td></tr>
        <tr><td>8</td><td>5,7,9</td><td>4,6</td></tr>
        <tr><td>*9</td><td>5</td><td>6,8</td></tr>
      </table>
    </div>
    <div>
      <h3>Building the DFA (lazy -- only states we need)</h3>
      <div class="diagram small">
Step 1: Start state = {1}
  {1} --r--> delta(1,r) = {5}              NEW
  {1} --b--> delta(1,b) = {2,4}            NEW

Step 2: Process {5}
  {5} --r--> {1,3,7,9}                          NEW
  {5} --b--> {2,4,6,8}                          NEW

Step 3: Process {2,4}
  {2,4} --r--> {1,3,5} U {1,5,7} = {1,3,5,7}   NEW
  {2,4} --b--> {4,6} U {2,8} = {2,4,6,8}   (seen)

Step 4: Process {1,3,7,9}  (accept -- contains 9)
  --r--> {5}U{5}U{5}U{5} = {5}            (seen)
  --b--> {2,4}U{2,6}U{4,8}U{6,8}
       = {2,4,6,8}                          (seen)

Step 5: Process {2,4,6,8}
  --r--> {1,3,5}U{1,5,7}U{3,5,9}U{5,7,9}
       = {1,3,5,7,9}                        NEW
  --b--> {4,6}U{2,8}U{2,8}U{4,6}
       = {2,4,6,8}                     (self-loop!)

...continue until no new states appear.
      </div>
    </div>
  </div>
  <div class="slide-number">15</div>
</div>

<!-- ==================== SLIDE 16: COMPLETED DFA TABLE ==================== -->
<div class="slide" id="s16">
  <h1>Chessboard: Completed DFA</h1>
  <p class="subtitle">The final result after subset construction</p>
  <div class="two-col">
    <div>
      <table>
        <tr><th>DFA State</th><th>r</th><th>b</th></tr>
        <tr><td>-> {1}</td><td>{5}</td><td>{2,4}</td></tr>
        <tr><td>{5}</td><td>{1,3,7,9}</td><td>{2,4,6,8}</td></tr>
        <tr><td>{2,4}</td><td>{1,3,5,7}</td><td>{2,4,6,8}</td></tr>
        <tr class="highlight"><td>* {1,3,7,9}</td><td>{5}</td><td>{2,4,6,8}</td></tr>
        <tr><td>{2,4,6,8}</td><td>{1,3,5,7,9}</td><td>{2,4,6,8}</td></tr>
        <tr><td>{1,3,5,7}</td><td>{1,3,5,7,9}</td><td>{2,4,6,8}</td></tr>
        <tr class="highlight"><td>* {1,3,5,7,9}</td><td>{1,3,5,7,9}</td><td>{2,4,6,8}</td></tr>
      </table>
      <p style="font-size: 0.9em; margin-top: 10px;">* = accept (contains state 9)</p>
    </div>
    <div>
      <h3>Observations</h3>
      <ul>
        <li>The NFA had <b>9 states</b>. Worst case DFA: 2<sup>9</sup> = 512 states!</li>
        <li>But lazy construction found only <b>7 reachable states</b>. Much better!</li>
        <li>Accept states are those whose set contains <b>9</b> (the NFA's accept state)</li>
        <li>Notice {2,4,6,8} loops to itself on 'b' -- black squares lead to black squares via black moves. You can never reach 9 (red) from black squares via 'b'!</li>
      </ul>
      <div class="analogy">
        <h3>"Lazy" vs "Full" construction</h3>
        <p>We only built states we could actually <b>reach</b> from {1}. The "full" construction would enumerate all 512 subsets -- most would be unreachable waste!</p>
      </div>
    </div>
  </div>
  <div class="slide-number">16</div>
</div>

<!-- ==================== SLIDE 17: SIMPLER EXAMPLE ==================== -->
<div class="slide" id="s17">
  <h1>Simpler Example: NFA for "string ends with 01"</h1>
  <p class="subtitle">A cleaner example to solidify the idea</p>
  <div class="two-col">
    <div>
      <h3>NFA Definition</h3>
      <ul>
        <li>Alphabet: {0, 1}</li>
        <li>States: {q0, q1, q2}</li>
        <li>Start: q0 &nbsp;|&nbsp; Accept: {q2}</li>
      </ul>
      <div class="diagram">
  Transitions:
    q0 --0--> {q0, q1}   "see 0: stay OR guess this is the final 01"
    q0 --1--> {q0}        "see 1: keep waiting"
    q1 --1--> {q2}        "saw 0, now see 1: accept!"
    q1 --0--> {}          "saw 0, see 0: dead end"
    q2 --0--> {}          "already accepted, dead end"
    q2 --1--> {}          "already accepted, dead end"

           0                1
  -->(q0)----->(q0)   -->(q0)----->(q0)
       \
        0
         \       1
         (q1)---------->((q2))
      </div>
    </div>
    <div>
      <h3>The NFA's "guessing" strategy</h3>
      <p>On seeing a 0, state q0 has a <b>choice</b>:</p>
      <ol>
        <li>"This 0 might not be the second-to-last character" -> stay in q0</li>
        <li>"This 0 might BE the second-to-last character!" -> also go to q1</li>
      </ol>
      <p style="margin-top: 10px;">It pursues <b>both</b> guesses simultaneously. If the guess was wrong (q1 doesn't see a '1' next), that branch dies. If right, it reaches q2!</p>
      <div class="key-idea">
        <h3>Why this is hard as a DFA</h3>
        <p>A DFA can't "guess." It has to somehow remember it saw a 0 while also continuing to process more input. The subset construction handles this automatically.</p>
      </div>
    </div>
  </div>
  <div class="slide-number">17</div>
</div>

<!-- ==================== SLIDE 18: SIMPLER EXAMPLE SUBSET CONSTRUCTION ==================== -->
<div class="slide" id="s18">
  <h1>Subset Construction for "ends with 01"</h1>
  <p class="subtitle">Converting the 3-state NFA to a DFA</p>
  <div class="two-col">
    <div>
      <h3>NFA transitions (reference)</h3>
      <table>
        <tr><th></th><th>0</th><th>1</th></tr>
        <tr><td>-> q0</td><td>{q0, q1}</td><td>{q0}</td></tr>
        <tr><td>q1</td><td>{}</td><td>{q2}</td></tr>
        <tr><td>* q2</td><td>{}</td><td>{}</td></tr>
      </table>
      <h3 style="margin-top: 20px;">Subset Construction</h3>
      <div class="diagram" style="font-size: 0.9em;">
Start: {q0}

{q0}:
  --0--> delta(q0,0) = {q0,q1}      NEW
  --1--> delta(q0,1) = {q0}         (self)

{q0,q1}:
  --0--> delta(q0,0) U delta(q1,0)
       = {q0,q1} U {} = {q0,q1}     (self)
  --1--> delta(q0,1) U delta(q1,1)
       = {q0} U {q2} = {q0,q2}      NEW

{q0,q2}: (ACCEPT -- contains q2)
  --0--> {q0,q1} U {} = {q0,q1}     (seen)
  --1--> {q0} U {} = {q0}           (seen)

DONE! No new states discovered.
      </div>
    </div>
    <div>
      <h3>Resulting DFA</h3>
      <table>
        <tr><th>DFA State</th><th>0</th><th>1</th></tr>
        <tr><td>-> {q0}</td><td>{q0,q1}</td><td>{q0}</td></tr>
        <tr><td>{q0,q1}</td><td>{q0,q1}</td><td>{q0,q2}</td></tr>
        <tr class="highlight"><td>* {q0,q2}</td><td>{q0,q1}</td><td>{q0}</td></tr>
      </table>
      <div class="diagram">
  Visually:

        0           1           0
  -->[{q0}] ---> [{q0,q1}] ---> [{q0,q1}]
       ^    &lt;---     |      &lt;---    |
       |      1      |        0     |
       |             v 1            |
       +--------[*{q0,q2}]&lt;--------+
                  |  ^
                  +--+ (b goes to {q0,q1})
      </div>
      <div class="key-idea">
        <h3>Result</h3>
        <p>Only 3 DFA states (out of 2<sup>3</sup>=8 possible). The empty set {} and states like {q1}, {q2}, {q1,q2}, {q0,q1,q2} are all <b>unreachable</b> from {q0}.</p>
      </div>
    </div>
  </div>
  <div class="slide-number">18</div>
</div>

<!-- ==================== SLIDE 19: INTERACTIVE SUBSET CONSTRUCTION VISUALIZER (NEW) ==================== -->
<div class="slide" id="s19">
  <h1>Interactive Subset Construction</h1>
  <p class="subtitle">Watch the algorithm build a DFA from the "ends with 01" NFA, step by step</p>
  <div class="sc-container">
    <div>
      <div class="sc-panel">
        <h3>NFA Reference</h3>
        <svg class="nfa-svg" viewBox="0 0 480 180" id="scNfaSvg">
          <defs>
            <marker id="scNfaArrow" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
              <polygon points="0 0, 10 3.5, 0 7" fill="#475569" />
            </marker>
          </defs>
          <line x1="30" y1="90" x2="68" y2="90" stroke="#475569" stroke-width="2" marker-end="url(#scNfaArrow)" />
          <circle cx="100" cy="90" r="30" class="state-circle" id="sc-nfa-q0" />
          <text x="100" y="90" class="state-label">q0</text>
          <path d="M 85 62 C 70 20, 130 20, 115 62" stroke="#475569" stroke-width="2" fill="none" marker-end="url(#scNfaArrow)" />
          <text x="100" y="30" class="arrow-label">0, 1</text>
          <line x1="130" y1="90" x2="218" y2="90" stroke="#475569" stroke-width="2" fill="none" marker-end="url(#scNfaArrow)" />
          <text x="175" y="80" class="arrow-label">0</text>
          <circle cx="250" cy="90" r="30" class="state-circle" id="sc-nfa-q1" />
          <text x="250" y="90" class="state-label">q1</text>
          <line x1="280" y1="90" x2="368" y2="90" stroke="#475569" stroke-width="2" fill="none" marker-end="url(#scNfaArrow)" />
          <text x="325" y="80" class="arrow-label">1</text>
          <circle cx="400" cy="90" r="30" class="state-circle" id="sc-nfa-q2" />
          <circle cx="400" cy="90" r="24" fill="none" stroke="#475569" stroke-width="2" />
          <text x="400" y="90" class="state-label">q2</text>
        </svg>
        <table style="font-size:0.82em; margin-top:10px; width:100%;">
          <tr><th></th><th>0</th><th>1</th></tr>
          <tr><td>-> q0</td><td>{q0, q1}</td><td>{q0}</td></tr>
          <tr><td>q1</td><td>{}</td><td>{q2}</td></tr>
          <tr><td>* q2</td><td>{}</td><td>{}</td></tr>
        </table>
      </div>
      <div class="sc-log" id="scLog">Click "Next Step" to begin...</div>
    </div>
    <div>
      <div class="sc-panel">
        <h3>DFA Being Built</h3>
        <div class="sc-controls">
          <button class="sim-btn primary" id="scNextBtn" onclick="scNext()">Next Step</button>
          <button class="sim-btn secondary" id="scAutoBtn" onclick="scAuto()">Auto Run</button>
          <button class="sim-btn reset" id="scResetBtn" onclick="scReset()">Reset</button>
          <span id="scStepCount" style="color:#64748b; font-size:0.9em; margin-left:8px;"></span>
        </div>
        <table class="sc-table" id="scTable">
          <thead><tr><th>DFA State</th><th>0</th><th>1</th></tr></thead>
          <tbody id="scTableBody"></tbody>
        </table>
        <svg class="sc-dfa-svg" viewBox="0 0 480 240" id="scDfaSvg">
          <defs>
            <marker id="scArrow" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
              <polygon points="0 0, 10 3.5, 0 7" fill="#475569" />
            </marker>
          </defs>
        </svg>
        <div id="scDone" style="display:none;"></div>
      </div>
    </div>
  </div>
  <div class="slide-number">19</div>
</div>

<!-- ==================== SLIDE 20: PROOF SKETCH ==================== -->
<div class="slide" id="s20">
  <h1>Why Does Subset Construction Work?</h1>
  <p class="subtitle">Proof sketch (by induction on string length)</p>
  <div class="two-col">
    <div>
      <div class="key-idea">
        <h3>What we need to show</h3>
        <p>For any string w: &delta;<sub>N</sub>(q<sub>0</sub>, w) = &delta;<sub>D</sub>({q<sub>0</sub>}, w)</p>
        <p style="color:#94a3b8;">"The set of NFA states after reading w equals the single DFA state (which is named by that set) after reading w."</p>
      </div>
      <h3>Base Case: w = &epsilon; (empty string)</h3>
      <p>&delta;<sub>N</sub>(q<sub>0</sub>, &epsilon;) = {q<sub>0</sub>} = &delta;<sub>D</sub>({q<sub>0</sub>}, &epsilon;)</p>
      <p>Both just stay at the start.</p>
    </div>
    <div>
      <h3>Inductive Step: w = xa (string x then symbol a)</h3>
      <p>Assume it works for x: &delta;<sub>N</sub>(q<sub>0</sub>, x) = &delta;<sub>D</sub>({q<sub>0</sub>}, x) = S</p>
      <p>Then for w = xa:</p>
      <div class="diagram" style="font-size: 0.9em;">
  NFA side:
    delta_N(q0, xa) = Union of delta_N(p, a)
                      for all p in S

  DFA side:
    delta_D({q0}, xa) = delta_D(S, a)
                      = Union of delta_N(p, a)
                        for all p in S

  They're computed the same way!
      </div>
      <div class="analogy">
        <h3>In plain English</h3>
        <p>The DFA state after reading w literally IS the set of all NFA states after reading w. The DFA's transition function was <b>defined</b> to make this true. So of course it works!</p>
      </div>
    </div>
  </div>
  <div class="slide-number">20</div>
</div>

<!-- ==================== SLIDE 21: EPSILON-NFA INTRO ==================== -->
<div class="slide" id="s21">
  <h1>Epsilon-NFA (&epsilon;-NFA)</h1>
  <p class="subtitle">Adding "free" transitions that consume no input</p>
  <div class="two-col">
    <div>
      <h3>What's new?</h3>
      <p>An &epsilon;-NFA has everything an NFA has, <b>plus</b> transitions on the special symbol &epsilon; (epsilon).</p>
      <div class="key-idea">
        <h3>&epsilon;-transitions</h3>
        <p>An &epsilon;-transition lets the automaton move from one state to another <b>without reading any input</b>. It's a "free move" -- spontaneous, no input consumed.</p>
      </div>
      <div class="analogy">
        <h3>Analogy: Secret Passages</h3>
        <p>Think of &epsilon;-transitions as <b>secret passages</b> in a maze. You can walk through them at any time without using a key (input symbol). They're like hidden shortcuts between rooms.</p>
      </div>
    </div>
    <div>
      <h3>Example &epsilon;-NFA</h3>
      <svg class="enfa-svg nfa-svg" viewBox="0 0 500 280">
        <defs>
          <marker id="enfaArrow" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#475569" />
          </marker>
          <marker id="enfaArrowEps" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#8b5cf6" />
          </marker>
        </defs>
        <!-- Start arrow -->
        <line x1="15" y1="70" x2="53" y2="70" stroke="#475569" stroke-width="2" marker-end="url(#enfaArrow)" />
        <!-- State A -->
        <circle cx="80" cy="70" r="25" class="state-circle" />
        <text x="80" y="70" class="state-label">A</text>
        <!-- State B -->
        <circle cx="240" cy="70" r="25" class="state-circle" />
        <text x="240" y="70" class="state-label">B</text>
        <!-- State C -->
        <circle cx="400" cy="70" r="25" class="state-circle" />
        <text x="400" y="70" class="state-label">C</text>
        <!-- State E -->
        <circle cx="80" cy="210" r="25" class="state-circle" />
        <text x="80" y="210" class="state-label">E</text>
        <!-- State F -->
        <circle cx="240" cy="210" r="25" class="state-circle" />
        <text x="240" y="210" class="state-label">F</text>
        <!-- State D (accept - double circle) -->
        <circle cx="400" cy="210" r="25" class="state-circle" />
        <circle cx="400" cy="210" r="20" fill="none" stroke="#475569" stroke-width="2" />
        <text x="400" y="210" class="state-label">D</text>

        <!-- A --1--> B -->
        <line x1="105" y1="70" x2="213" y2="70" class="arrow-line" marker-end="url(#enfaArrow)" />
        <text x="160" y="60" class="arrow-label">1</text>
        <!-- A --0--> E -->
        <line x1="80" y1="97" x2="80" y2="183" class="arrow-line" marker-end="url(#enfaArrow)" />
        <text x="68" y="145" class="arrow-label">0</text>
        <!-- B --1--> C -->
        <line x1="265" y1="70" x2="373" y2="70" class="arrow-line" marker-end="url(#enfaArrow)" />
        <text x="320" y="60" class="arrow-label">1</text>
        <!-- C --1--> D -->
        <line x1="400" y1="97" x2="400" y2="183" class="arrow-line" marker-end="url(#enfaArrow)" />
        <text x="415" y="145" class="arrow-label">1</text>
        <!-- E --0--> F -->
        <line x1="105" y1="210" x2="213" y2="210" class="arrow-line" marker-end="url(#enfaArrow)" />
        <text x="160" y="230" class="arrow-label">0</text>
        <!-- F --0--> D -->
        <line x1="265" y1="210" x2="373" y2="210" class="arrow-line" marker-end="url(#enfaArrow)" />
        <text x="320" y="230" class="arrow-label">0</text>

        <!-- EPSILON transitions (dashed, purple) -->
        <!-- B --ε--> D -->
        <path d="M 258 90 Q 330 170 393 188" class="eps-arrow" marker-end="url(#enfaArrowEps)" />
        <text x="340" y="145" class="eps-label">&epsilon;</text>
        <!-- E --ε--> B -->
        <path d="M 98 193 Q 155 130 228 80" class="eps-arrow" marker-end="url(#enfaArrowEps)" />
        <text x="148" y="120" class="eps-label">&epsilon;</text>
        <!-- E --ε--> C -->
        <path d="M 100 195 Q 250 100 383 78" class="eps-arrow" marker-end="url(#enfaArrowEps)" />
        <text x="250" y="108" class="eps-label">&epsilon;</text>
      </svg>
      <p style="font-size:0.85em; color:#94a3b8; text-align:center; margin-top:4px;">
        Solid arrows = real transitions (consume input). <span style="color:#a78bfa;">Dashed arrows = &epsilon; (free moves).</span><br>
        E can teleport to B and C via &epsilon;. B can teleport to D.
      </p>
      <p>The transition table now has an extra <b>&epsilon; column</b>:</p>
      <table style="font-size: 0.85em;">
        <tr><th></th><th>0</th><th>1</th><th>&epsilon;</th></tr>
        <tr><td>-> A</td><td>{E}</td><td>{B}</td><td>&empty;</td></tr>
        <tr><td>B</td><td>&empty;</td><td>{C}</td><td>{D}</td></tr>
        <tr><td>C</td><td>&empty;</td><td>{D}</td><td>&empty;</td></tr>
        <tr><td>* D</td><td>&empty;</td><td>&empty;</td><td>&empty;</td></tr>
        <tr><td>E</td><td>{F}</td><td>&empty;</td><td>{B,C}</td></tr>
        <tr><td>F</td><td>{D}</td><td>&empty;</td><td>&empty;</td></tr>
      </table>
    </div>
  </div>
  <div class="slide-number">21</div>
</div>

<!-- ==================== SLIDE 22: EPSILON CLOSURE (INTERACTIVE) ==================== -->
<div class="slide" id="s22">
  <h1>Epsilon-Closure: CL(q)</h1>
  <p class="subtitle">Click a state to watch its &epsilon;-closure expand step by step</p>
  <div class="two-col">
    <div>
      <div class="key-idea">
        <h3>Definition</h3>
        <p><b>CL(q)</b> = the set of all states you can reach from q by following <b>zero or more &epsilon;-transitions</b>.</p>
        <p style="margin-top:8px">Note: q itself is always in CL(q) (zero &epsilon;-transitions = stay put).</p>
      </div>
      <svg class="enfa-svg nfa-svg" viewBox="0 0 500 280" id="eclSvg">
        <defs>
          <marker id="eclArrow" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#475569" />
          </marker>
          <marker id="eclArrowEps" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#8b5cf6" />
          </marker>
          <marker id="eclArrowEpsGlow" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#c084fc" />
          </marker>
        </defs>
        <!-- Start arrow -->
        <line x1="15" y1="70" x2="53" y2="70" stroke="#475569" stroke-width="2" marker-end="url(#eclArrow)" />
        <!-- State A -->
        <circle cx="80" cy="70" r="25" class="state-circle" id="ecl-A" />
        <text x="80" y="70" class="state-label">A</text>
        <!-- State B -->
        <circle cx="240" cy="70" r="25" class="state-circle" id="ecl-B" />
        <text x="240" y="70" class="state-label">B</text>
        <!-- State C -->
        <circle cx="400" cy="70" r="25" class="state-circle" id="ecl-C" />
        <text x="400" y="70" class="state-label">C</text>
        <!-- State E -->
        <circle cx="80" cy="210" r="25" class="state-circle" id="ecl-E" />
        <text x="80" y="210" class="state-label">E</text>
        <!-- State F -->
        <circle cx="240" cy="210" r="25" class="state-circle" id="ecl-F" />
        <text x="240" y="210" class="state-label">F</text>
        <!-- State D (accept) -->
        <circle cx="400" cy="210" r="25" class="state-circle" id="ecl-D" />
        <circle cx="400" cy="210" r="20" fill="none" stroke="#475569" stroke-width="2" id="ecl-D-inner" />
        <text x="400" y="210" class="state-label">D</text>

        <!-- Regular transitions (dimmed for this slide) -->
        <line x1="105" y1="70" x2="213" y2="70" class="arrow-line" marker-end="url(#eclArrow)" opacity="0.3" />
        <text x="160" y="60" class="arrow-label" opacity="0.3">1</text>
        <line x1="80" y1="97" x2="80" y2="183" class="arrow-line" marker-end="url(#eclArrow)" opacity="0.3" />
        <text x="68" y="145" class="arrow-label" opacity="0.3">0</text>
        <line x1="265" y1="70" x2="373" y2="70" class="arrow-line" marker-end="url(#eclArrow)" opacity="0.3" />
        <text x="320" y="60" class="arrow-label" opacity="0.3">1</text>
        <line x1="400" y1="97" x2="400" y2="183" class="arrow-line" marker-end="url(#eclArrow)" opacity="0.3" />
        <text x="415" y="145" class="arrow-label" opacity="0.3">1</text>
        <line x1="105" y1="210" x2="213" y2="210" class="arrow-line" marker-end="url(#eclArrow)" opacity="0.3" />
        <text x="160" y="230" class="arrow-label" opacity="0.3">0</text>
        <line x1="265" y1="210" x2="373" y2="210" class="arrow-line" marker-end="url(#eclArrow)" opacity="0.3" />
        <text x="320" y="230" class="arrow-label" opacity="0.3">0</text>

        <!-- EPSILON transitions (prominent - these are what closure follows) -->
        <!-- B --ε--> D -->
        <path d="M 258 90 Q 330 170 393 188" class="eps-arrow" id="ecl-eps-B-D" marker-end="url(#eclArrowEps)" />
        <text x="340" y="145" class="eps-label">&epsilon;</text>
        <!-- E --ε--> B -->
        <path d="M 98 193 Q 155 130 228 80" class="eps-arrow" id="ecl-eps-E-B" marker-end="url(#eclArrowEps)" />
        <text x="148" y="120" class="eps-label">&epsilon;</text>
        <!-- E --ε--> C -->
        <path d="M 100 195 Q 250 100 383 78" class="eps-arrow" id="ecl-eps-E-C" marker-end="url(#eclArrowEps)" />
        <text x="250" y="108" class="eps-label">&epsilon;</text>
      </svg>
      <p style="font-size:0.82em; color:#94a3b8; text-align:center; margin-top:2px;">
        Regular transitions dimmed. <span style="color:#a78bfa;">&epsilon;-transitions highlighted</span> &mdash; these are what closure follows.
      </p>
    </div>
    <div>
      <h3>Explore &epsilon;-closure</h3>
      <p style="font-size:0.95em; color:#94a3b8; margin-bottom:8px;">Click a state to compute CL(q):</p>
      <div class="ecl-buttons">
        <button class="ecl-state-btn" onclick="eclExplore('A')">A</button>
        <button class="ecl-state-btn" onclick="eclExplore('B')">B</button>
        <button class="ecl-state-btn" onclick="eclExplore('C')">C</button>
        <button class="ecl-state-btn" onclick="eclExplore('D')">D</button>
        <button class="ecl-state-btn" onclick="eclExplore('E')">E</button>
        <button class="ecl-state-btn" onclick="eclExplore('F')">F</button>
        <button class="sim-btn reset" onclick="eclReset()" style="margin-left:8px;">Reset</button>
      </div>
      <div class="ecl-result" id="eclResult">
        Click any state above to visualize its &epsilon;-closure...
      </div>
      <div class="warning" style="margin-top:16px;">
        <h3>Follow the chain!</h3>
        <p>CL(E) isn't just {E, B, C}. Since B has its own &epsilon;-transition to D, you must follow that too! CL(E) = {E} &cup; {B,C} &cup; CL(B) &cup; CL(C) = {E, B, C, D}.</p>
        <p style="margin-top:8px; font-size:0.9em; color:#94a3b8;">Try clicking <b>E</b> to see the chained closure in action.</p>
      </div>
    </div>
  </div>
  <div class="slide-number">22</div>
</div>

<!-- ==================== SLIDE 23: EXTENDED DELTA FOR EPSILON NFA ==================== -->
<div class="slide" id="s23">
  <h1>Extended &delta; for &epsilon;-NFA</h1>
  <p class="subtitle">Processing strings in an &epsilon;-NFA means accounting for "free moves" at every step</p>
  <div class="two-col">
    <div>
      <h3>The algorithm: &delta;-hat(q, w)</h3>
      <div class="key-idea">
        <p><b>Base:</b> &delta;&#770;(q, &epsilon;) = CL(q)</p>
        <p style="color:#94a3b8;">"Before reading anything, you can already be in any state reachable via &epsilon;-transitions."</p>
        <p style="margin-top:12px;"><b>Induction:</b> &delta;&#770;(q, xa) is computed:</p>
        <ol>
          <li>Compute S = &delta;&#770;(q, x) &nbsp; [states after reading x]</li>
          <li>For each state p in S, look up &delta;(p, a) &nbsp; [follow real transition on 'a']</li>
          <li>Take the <b>closure</b> of each result &nbsp; [follow &epsilon;-transitions after]</li>
          <li>Union everything</li>
        </ol>
      </div>
    </div>
    <div>
      <h3>Worked example: &delta;&#770;(A, "01")</h3>
      <div class="diagram" style="font-size: 0.9em;">
Step 0: Start
  delta-hat(A, epsilon) = CL(A) = {A}

Step 1: Read '0'
  From A, delta(A, 0) = {E}
  Take closure: CL({E}) = {E, B, C, D}
  So delta-hat(A, "0") = {B, C, D, E}

Step 2: Read '1'
  From B: delta(B, 1) = {C}, CL = {C}
  From C: delta(C, 1) = {D}, CL = {D}
  From D: delta(D, 1) = {},  CL = {}
  From E: delta(E, 1) = {},  CL = {}
  Union = {C, D}
  So delta-hat(A, "01") = {C, D}

  D is an accept state => "01" is ACCEPTED!
      </div>
    </div>
  </div>
  <div class="slide-number">23</div>
</div>

<!-- ==================== SLIDE 24: EPSILON-NFA TO NFA ==================== -->
<div class="slide" id="s24">
  <h1>Converting &epsilon;-NFA to ordinary NFA</h1>
  <p class="subtitle">Eliminating &epsilon;-transitions by "baking them in"</p>
  <div class="two-col">
    <div>
      <h3>The recipe</h3>
      <p>Given &epsilon;-NFA with transition function &delta;<sub>E</sub>, build an ordinary NFA with &delta;<sub>N</sub>:</p>
      <div class="key-idea">
        <p><b>Same states, same alphabet, same start state.</b></p>
        <p style="margin-top:8px;"><b>New transitions:</b> &delta;<sub>N</sub>(q, a) = </p>
        <ol>
          <li>Start with CL(q) -- everywhere you can be before reading 'a'</li>
          <li>From each state in CL(q), follow the real transition on 'a'</li>
          <li>Union all results (but do NOT take closure after -- that will be handled by the next step's closure)</li>
        </ol>
        <p style="margin-top:8px;"><b>New accept states F':</b> any state q where CL(q) contains a state in F.</p>
        <p style="color:#94a3b8;">(If you can reach an accept state via &epsilon; alone, you're accepting too.)</p>
      </div>
    </div>
    <div>
      <h3>Example result</h3>
      <div class="two-col" style="gap: 20px;">
        <div>
          <p style="font-size: 0.85em;"><b>&epsilon;-NFA</b></p>
          <table style="font-size: 0.8em;">
            <tr><th></th><th>0</th><th>1</th><th>&epsilon;</th></tr>
            <tr><td>->A</td><td>{E}</td><td>{B}</td><td>&empty;</td></tr>
            <tr><td>B</td><td>&empty;</td><td>{C}</td><td>{D}</td></tr>
            <tr><td>C</td><td>&empty;</td><td>{D}</td><td>&empty;</td></tr>
            <tr><td>*D</td><td>&empty;</td><td>&empty;</td><td>&empty;</td></tr>
            <tr><td>E</td><td>{F}</td><td>&empty;</td><td>{B,C}</td></tr>
            <tr><td>F</td><td>{D}</td><td>&empty;</td><td>&empty;</td></tr>
          </table>
        </div>
        <div>
          <p style="font-size: 0.85em;"><b>Ordinary NFA</b></p>
          <table style="font-size: 0.8em;">
            <tr><th></th><th>0</th><th>1</th></tr>
            <tr><td>->A</td><td>{E}</td><td>{B}</td></tr>
            <tr><td>*B</td><td>&empty;</td><td>{C}</td></tr>
            <tr><td>C</td><td>&empty;</td><td>{D}</td></tr>
            <tr><td>*D</td><td>&empty;</td><td>&empty;</td></tr>
            <tr><td>*E</td><td>{F}</td><td>{C,D}</td></tr>
            <tr><td>F</td><td>{D}</td><td>&empty;</td></tr>
          </table>
        </div>
      </div>
      <p style="margin-top: 12px; font-size: 0.95em;"><b>What changed?</b></p>
      <ul style="font-size: 0.9em;">
        <li>&epsilon; column removed entirely</li>
        <li>E on '1': CL(E)={E,B,C,D}. B--1-->{C}, C--1-->{D}. So &delta;<sub>N</sub>(E,1)={C,D}</li>
        <li>B and E become accept states (CL(B)={B,D} and CL(E)={E,B,C,D} both contain D)</li>
      </ul>
    </div>
  </div>
  <div class="slide-number">24</div>
</div>

<!-- ==================== SLIDE 25: CHALLENGE 1 - DOES THIS NFA ACCEPT? (NEW) ==================== -->
<div class="slide" id="s25">
  <h1>Challenge: Does This NFA Accept?</h1>
  <p class="subtitle">Test your understanding -- trace the computation!</p>
  <div class="two-col">
    <div>
      <div class="challenge-container">
        <div class="score-display" id="c1Score">Question 1 of 3</div>
        <div id="c1Diagram" style="margin-bottom:12px;"></div>
        <div id="c1Question" style="font-size:1.1em; margin-bottom:16px;"></div>
        <div id="c1Buttons" style="text-align:center;"></div>
        <div class="feedback-box" id="c1Feedback"></div>
      </div>
    </div>
    <div>
      <div class="key-idea">
        <h3>How to solve it</h3>
        <ol>
          <li>Start with the set containing just the start state</li>
          <li>For each symbol in the string, compute the <b>union</b> of all transitions from all active states</li>
          <li>After the last symbol, check: does the final set contain an <b>accept state</b>?</li>
        </ol>
      </div>
      <div id="c1Walkthrough" style="margin-top:16px;"></div>
    </div>
  </div>
  <div class="slide-number">25</div>
</div>

<!-- ==================== SLIDE 26: CHALLENGE 2 - BUILD SUBSET CONSTRUCTION (NEW) ==================== -->
<div class="slide" id="s26">
  <h1>Challenge: Build the Subset Construction</h1>
  <p class="subtitle">Fill in the DFA transition table from this NFA</p>
  <div class="two-col">
    <div>
      <h3>NFA (accepts strings ending with "ab")</h3>
      <div class="diagram" style="font-size:0.9em;">
  States: {q0, q1, q2}
  Start: q0  |  Accept: {q2}
  Alphabet: {a, b}

    q0 --a--> {q0, q1}
    q0 --b--> {q0}
    q1 --a--> {}
    q1 --b--> {q2}
    q2 --a--> {}
    q2 --b--> {}
      </div>
      <table style="font-size:0.9em;">
        <tr><th></th><th>a</th><th>b</th></tr>
        <tr><td>-> q0</td><td>{q0, q1}</td><td>{q0}</td></tr>
        <tr><td>q1</td><td>{}</td><td>{q2}</td></tr>
        <tr><td>* q2</td><td>{}</td><td>{}</td></tr>
      </table>
    </div>
    <div>
      <h3>Fill in the DFA table</h3>
      <p style="font-size:0.9em; color:#94a3b8; margin-bottom:12px;">Click each <span style="color:#64748b;">?</span> cell to select the correct set of states.</p>
      <div id="c2Grid"></div>
      <div style="margin-top:12px;">
        <button class="sim-btn primary" id="c2CheckBtn" onclick="c2Check()">Check Answers</button>
        <button class="sim-btn secondary" onclick="c2Reset()">Reset</button>
      </div>
      <div class="feedback-box" id="c2Feedback"></div>
    </div>
  </div>
  <div class="slide-number">26</div>
</div>

<!-- ==================== SLIDE 27: CHALLENGE 3 - SPOT THE BUG (NEW) ==================== -->
<div class="slide" id="s27">
  <h1>Challenge: Spot the Bug!</h1>
  <p class="subtitle">A student did subset construction but made a mistake. Can you find it?</p>
  <div class="two-col">
    <div>
      <h3>NFA (accepts strings ending with "10")</h3>
      <table style="font-size:0.9em;">
        <tr><th></th><th>0</th><th>1</th></tr>
        <tr><td>-> p0</td><td>{p0}</td><td>{p0, p1}</td></tr>
        <tr><td>p1</td><td>{p2}</td><td>{}</td></tr>
        <tr><td>* p2</td><td>{}</td><td>{}</td></tr>
      </table>
      <h3 style="margin-top:16px;">Student's Subset Construction</h3>
      <p style="font-size:0.9em; color:#94a3b8;">One cell is WRONG. Click it!</p>
      <div id="c3Table"></div>
      <div class="feedback-box" id="c3Feedback"></div>
    </div>
    <div>
      <div id="c3Hints">
        <div class="key-idea">
          <h3>Common Mistakes in Subset Construction</h3>
          <ul>
            <li><b>Forgetting to union:</b> When multiple NFA states are active, you must union ALL their transitions</li>
            <li><b>Missing the empty set:</b> If no transitions exist, the result is {} (not omitted!)</li>
            <li><b>Wrong accept states:</b> A DFA state is accepting if it contains ANY NFA accept state</li>
          </ul>
        </div>
        <div id="c3HintBtn" style="margin-top:12px;">
          <button class="sim-btn secondary" onclick="c3ShowHint()">Need a hint?</button>
        </div>
        <div id="c3HintText" style="display:none; margin-top:12px;" class="analogy">
          <h3>Hint</h3>
          <p>Look carefully at state {p0, p1} under input 0. What should &delta;(p0, 0) &cup; &delta;(p1, 0) be?</p>
        </div>
      </div>
    </div>
  </div>
  <div class="slide-number">27</div>
</div>

<!-- ==================== SLIDE 28: SUMMARY ==================== -->
<div class="slide" id="s28">
  <h1>Summary: The Complete Picture</h1>
  <p class="subtitle">Everything connects</p>
  <div class="diagram" style="font-size: 1em; text-align: center;">
   +------------------+    subset      +------------------+     eliminate    +------------------+
   |                  | construction   |                  |   epsilon-trans  |                  |
   |       DFA        |&lt;-------------- |       NFA        |&lt;--------------- |   epsilon-NFA    |
   |                  |                |                  |                 |                  |
   | (1 state at a    |  (may blow up  | (multiple states | (use closure    | (free moves +    |
   |  time, easy to   |   to 2^n       |  at once, more   |  to absorb      |  real moves)     |
   |  implement)      |   states)      |  compact)        |  epsilon-moves) |                  |
   +------------------+                +------------------+                 +------------------+
           |                                   ^                                    ^
           |        trivial (just wrap          |           trivial (it's a          |
           +---------in singleton sets)---------+           special case)  ----------+
  </div>
  <div class="key-idea" style="margin-top: 20px;">
    <h3>Key Takeaways</h3>
    <ul>
      <li><b>DFA, NFA, and &epsilon;-NFA all recognize the same class of languages: the regular languages.</b></li>
      <li>NFAs/&epsilon;-NFAs are often <b>much easier to design</b> and can have exponentially fewer states than the equivalent DFA.</li>
      <li>But only DFAs can be directly <b>implemented</b> (executed) on a computer.</li>
      <li>The <b>Subset Construction</b> is the practical algorithm to convert NFA -> DFA.</li>
      <li>&epsilon;-closure lets us eliminate &epsilon;-transitions systematically.</li>
    </ul>
  </div>
  <div class="slide-number">28</div>
</div>

<!-- ==================== SLIDE 29: CHEAT SHEET ==================== -->
<div class="slide" id="s29">
  <h1>Cheat Sheet</h1>
  <p class="subtitle">Quick reference for exams</p>
  <div class="two-col">
    <div>
      <h3>Subset Construction (NFA -> DFA)</h3>
      <div class="diagram small">
1. DFA start state = {q0}  (NFA start in a set)
2. For each new DFA state S = {p1,...,pk}:
   For each symbol a:
     delta_D(S, a) = Union of delta_N(pi, a)
                     for i = 1..k
3. DFA accept states = any S containing
   a member of F
4. Repeat until no new states appear
   (use lazy construction -- only reachable states)
      </div>
      <h3>&epsilon;-NFA -> NFA</h3>
      <div class="diagram small">
1. Same states Q, alphabet Sigma, start q0
2. delta_N(q, a) = Union of delta_E(p, a)
                   for all p in CL(q)
3. F' = { q | CL(q) intersects F }
   (any state that can epsilon-reach an
    accept state becomes accepting)
      </div>
    </div>
    <div>
      <h3>&epsilon;-Closure</h3>
      <div class="diagram small">
CL(q) = {q} union
  { all states reachable from q
    by following only epsilon-arrows }

To compute: BFS/DFS following only
epsilon-edges from q.

CL(set S) = Union of CL(q) for q in S
      </div>
      <h3>Common Mistakes to Avoid</h3>
      <div class="warning" style="margin-top: 8px;">
        <ul style="font-size: 0.9em;">
          <li>Don't forget: {p,q} is ONE DFA state, not two</li>
          <li>CL() is transitive -- follow the full chain</li>
          <li>NFA accepts if ANY path succeeds</li>
          <li>DFA might need the &empty; (dead) state</li>
          <li>In &epsilon;-NFA->NFA, update accept states F' too!</li>
        </ul>
      </div>
    </div>
  </div>
  <div class="slide-number">29</div>
</div>

<!-- State Picker Modal -->
<div class="state-picker-overlay" id="pickerOverlay"></div>
<div class="state-picker" id="statePicker">
  <h3>Select states in this set</h3>
  <div class="state-options" id="pickerOptions"></div>
  <div class="picker-actions">
    <button class="sim-btn primary" onclick="pickerConfirm()">Confirm</button>
    <button class="sim-btn secondary" onclick="pickerCancel()">Cancel</button>
  </div>
</div>

<!-- Navigation -->
<div class="nav">
  <button id="prevBtn" onclick="changeSlide(-1)">&larr; Prev</button>
  <button id="nextBtn" onclick="changeSlide(1)">Next &rarr;</button>
</div>

<script>
// ===========================
// SLIDE NAVIGATION
// ===========================
const totalSlides = 29;
let current = 1;

function showSlide(n) {
  document.querySelectorAll('.slide').forEach(s => s.classList.remove('active'));
  const slide = document.getElementById('s' + n);
  if (slide) {
    slide.classList.add('active');
    slide.classList.add('fade-in');
  }
  document.getElementById('prevBtn').disabled = (n === 1);
  document.getElementById('nextBtn').disabled = (n === totalSlides);
  document.getElementById('progress').style.width = ((n / totalSlides) * 100) + '%';
}

function changeSlide(delta) {
  const next = current + delta;
  if (next >= 1 && next <= totalSlides) {
    current = next;
    showSlide(current);
  }
}

document.addEventListener('keydown', (e) => {
  // Don't navigate when typing in the simulator input
  if (e.target.tagName === 'INPUT') return;
  if (e.key === 'ArrowRight' || e.key === 'ArrowDown' || e.key === ' ') {
    e.preventDefault();
    changeSlide(1);
  } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
    e.preventDefault();
    changeSlide(-1);
  } else if (e.key === 's' || e.key === 'S') {
    const slide = document.getElementById('s' + current);
    const steps = slide.querySelectorAll('.step:not(.revealed)');
    if (steps.length > 0) steps[0].classList.add('revealed');
  }
});

showSlide(1);

// ===========================
// NFA SIMULATOR (Slide 11)
// ===========================
// NFA for "ends with 01": states q0, q1, q2
// delta(q0, 0) = {q0, q1}, delta(q0, 1) = {q0}
// delta(q1, 0) = {}, delta(q1, 1) = {q2}
// delta(q2, 0) = {}, delta(q2, 1) = {}
// Accept: {q2}

const simNFA = {
  states: ['q0', 'q1', 'q2'],
  start: 'q0',
  accept: ['q2'],
  delta: {
    'q0': { '0': ['q0', 'q1'], '1': ['q0'] },
    'q1': { '0': [], '1': ['q2'] },
    'q2': { '0': [], '1': [] }
  }
};

let simState = { active: null, pos: -1, input: '', running: false, done: false };

function simReset() {
  simState = { active: null, pos: -1, input: '', running: false, done: false };
  // Reset SVG
  simNFA.states.forEach(s => {
    const el = document.getElementById('svg-' + s);
    if (el) { el.className.baseVal = 'state-circle'; }
  });
  const inner = document.getElementById('svg-q2-inner');
  if (inner) inner.className.baseVal = 'accept-inner';
  document.getElementById('simActiveStates').textContent = '-';
  document.getElementById('simInputDisplay').innerHTML = '';
  document.getElementById('simVerdict').innerHTML = '';
  document.getElementById('simStepBtn').disabled = false;
  document.getElementById('simRunBtn').disabled = false;
  document.getElementById('simInput').disabled = false;
  document.getElementById('simInput').value = '';
}

function simInit() {
  const input = document.getElementById('simInput').value.trim();
  if (!/^[01]*$/.test(input)) {
    document.getElementById('simVerdict').innerHTML =
      '<div class="sim-verdict reject">Only 0s and 1s allowed!</div>';
    return false;
  }
  simState.input = input;
  simState.pos = -1;
  simState.active = new Set([simNFA.start]);
  simState.done = false;
  document.getElementById('simInput').disabled = true;
  updateSimDisplay();
  return true;
}

function simStep() {
  if (simState.active === null) {
    if (!simInit()) return;
    if (simState.input.length === 0) {
      simFinish();
      return;
    }
    return; // First step just shows initial state
  }
  if (simState.done) return;

  simState.pos++;
  if (simState.pos >= simState.input.length) {
    simFinish();
    return;
  }

  const symbol = simState.input[simState.pos];
  const nextActive = new Set();
  for (const state of simState.active) {
    const targets = simNFA.delta[state][symbol] || [];
    targets.forEach(t => nextActive.add(t));
  }
  simState.active = nextActive;
  updateSimDisplay();

  if (simState.pos === simState.input.length - 1) {
    simFinish();
  }
}

function simFinish() {
  simState.done = true;
  document.getElementById('simStepBtn').disabled = true;
  document.getElementById('simRunBtn').disabled = true;

  const accepted = [...simState.active].some(s => simNFA.accept.includes(s));

  // Update SVG final states
  simNFA.states.forEach(s => {
    const el = document.getElementById('svg-' + s);
    if (!el) return;
    if (simState.active.has(s)) {
      if (simNFA.accept.includes(s) && accepted) {
        el.className.baseVal = 'state-circle accepted';
      } else {
        el.className.baseVal = 'state-circle active';
      }
    } else {
      el.className.baseVal = 'state-circle dead';
    }
  });
  const inner = document.getElementById('svg-q2-inner');
  if (inner) {
    if (simState.active.has('q2') && accepted) {
      inner.className.baseVal = 'accept-inner accepted';
    } else {
      inner.className.baseVal = 'accept-inner';
    }
  }

  const verdict = document.getElementById('simVerdict');
  if (accepted) {
    verdict.innerHTML = '<div class="sim-verdict accept">ACCEPTED! The active set ' +
      formatSet([...simState.active]) + ' contains accept state q2.</div>';
  } else {
    verdict.innerHTML = '<div class="sim-verdict reject">REJECTED. The active set ' +
      formatSet([...simState.active]) + ' does not contain any accept state.</div>';
  }
}

function simRun() {
  if (simState.active === null) {
    if (!simInit()) return;
  }
  simState.running = true;
  document.getElementById('simStepBtn').disabled = true;
  document.getElementById('simRunBtn').disabled = true;

  function autoStep() {
    if (simState.done) return;
    simStep();
    if (!simState.done) {
      setTimeout(autoStep, 600);
    }
  }
  setTimeout(autoStep, 400);
}

function updateSimDisplay() {
  // Update SVG circles
  simNFA.states.forEach(s => {
    const el = document.getElementById('svg-' + s);
    if (!el) return;
    if (simState.active.has(s)) {
      el.className.baseVal = 'state-circle active';
    } else {
      el.className.baseVal = 'state-circle';
    }
  });
  const inner = document.getElementById('svg-q2-inner');
  if (inner) {
    inner.className.baseVal = simState.active.has('q2') ? 'accept-inner active' : 'accept-inner';
  }

  // Update active states text
  document.getElementById('simActiveStates').textContent =
    '{' + [...simState.active].sort().join(', ') + '}';

  // Update input display
  const display = document.getElementById('simInputDisplay');
  if (simState.input.length === 0) {
    display.innerHTML = '<span style="color:#94a3b8;">(empty string &epsilon;)</span>';
    return;
  }
  let html = 'Input: ';
  for (let i = 0; i < simState.input.length; i++) {
    if (i < simState.pos) {
      html += '<span class="consumed">' + simState.input[i] + '</span>';
    } else if (i === simState.pos) {
      html += '<span class="current-char">' + simState.input[i] + '</span>';
    } else {
      html += '<span class="remaining">' + simState.input[i] + '</span>';
    }
  }
  display.innerHTML = html;
}

function formatSet(arr) {
  if (arr.length === 0) return '{}';
  return '{' + arr.sort().join(', ') + '}';
}

// ===========================
// CHALLENGE 1: Does this NFA accept? (Slide 25)
// ===========================
const c1Problems = [
  {
    // NFA "ends with 01" — same as simulator
    nfaDesc: 'NFA for "ends with 01" (q0, q1, q2)',
    diagram: '<div class="diagram" style="font-size:0.85em;">  -->(q0)--0-->{q0,q1}  -->(q0)--1-->{q0}\n       (q1)--1-->{q2}   (q1)--0-->{}\n       Accept: q2</div>',
    string: '101',
    answer: true,
    walkthrough: 'Start: {q0}\nRead 1: {q0}\nRead 0: {q0, q1}\nRead 1: {q0, q2}\nq2 is accept => ACCEPT'
  },
  {
    nfaDesc: 'NFA for "ends with 01" (q0, q1, q2)',
    diagram: '<div class="diagram" style="font-size:0.85em;">  -->(q0)--0-->{q0,q1}  -->(q0)--1-->{q0}\n       (q1)--1-->{q2}   (q1)--0-->{}\n       Accept: q2</div>',
    string: '110',
    answer: false,
    walkthrough: 'Start: {q0}\nRead 1: {q0}\nRead 1: {q0}\nRead 0: {q0, q1}\nNo accept state => REJECT'
  },
  {
    nfaDesc: 'NFA for "ends with 01" (q0, q1, q2)',
    diagram: '<div class="diagram" style="font-size:0.85em;">  -->(q0)--0-->{q0,q1}  -->(q0)--1-->{q0}\n       (q1)--1-->{q2}   (q1)--0-->{}\n       Accept: q2</div>',
    string: '0001',
    answer: true,
    walkthrough: 'Start: {q0}\nRead 0: {q0, q1}\nRead 0: {q0, q1}\nRead 0: {q0, q1}\nRead 1: {q0, q2}\nq2 is accept => ACCEPT'
  },
  {
    nfaDesc: 'NFA for "ends with 01" (q0, q1, q2)',
    diagram: '<div class="diagram" style="font-size:0.85em;">  -->(q0)--0-->{q0,q1}  -->(q0)--1-->{q0}\n       (q1)--1-->{q2}   (q1)--0-->{}\n       Accept: q2</div>',
    string: '10',
    answer: false,
    walkthrough: 'Start: {q0}\nRead 1: {q0}\nRead 0: {q0, q1}\nNo accept state (q1 is not accept) => REJECT'
  },
  {
    nfaDesc: 'NFA for "ends with 01" (q0, q1, q2)',
    diagram: '<div class="diagram" style="font-size:0.85em;">  -->(q0)--0-->{q0,q1}  -->(q0)--1-->{q0}\n       (q1)--1-->{q2}   (q1)--0-->{}\n       Accept: q2</div>',
    string: '01',
    answer: true,
    walkthrough: 'Start: {q0}\nRead 0: {q0, q1}\nRead 1: {q0, q2}\nq2 is accept => ACCEPT'
  },
  {
    nfaDesc: 'NFA for "ends with 01" (q0, q1, q2)',
    diagram: '<div class="diagram" style="font-size:0.85em;">  -->(q0)--0-->{q0,q1}  -->(q0)--1-->{q0}\n       (q1)--1-->{q2}   (q1)--0-->{}\n       Accept: q2</div>',
    string: '11',
    answer: false,
    walkthrough: 'Start: {q0}\nRead 1: {q0}\nRead 1: {q0}\nNo accept state => REJECT'
  }
];

let c1State = { problems: [], current: 0, score: 0, answered: false };

function c1Init() {
  // Shuffle and pick 3
  const shuffled = c1Problems.slice().sort(() => Math.random() - 0.5);
  c1State.problems = shuffled.slice(0, 3);
  c1State.current = 0;
  c1State.score = 0;
  c1State.answered = false;
  c1Render();
}

function c1Render() {
  const p = c1State.problems[c1State.current];
  document.getElementById('c1Score').textContent =
    'Question ' + (c1State.current + 1) + ' of 3  |  Score: ' + c1State.score + '/' + c1State.current;
  document.getElementById('c1Diagram').innerHTML = p.diagram;
  document.getElementById('c1Question').innerHTML =
    'Does this NFA accept the string <b>"' + p.string + '"</b>?';

  const btns = document.getElementById('c1Buttons');
  btns.innerHTML =
    '<button class="quiz-btn" id="c1Yes" onclick="c1Answer(true)">YES - Accepts</button>' +
    '<button class="quiz-btn" id="c1No" onclick="c1Answer(false)">NO - Rejects</button>';

  document.getElementById('c1Feedback').className = 'feedback-box';
  document.getElementById('c1Feedback').innerHTML = '';
  document.getElementById('c1Walkthrough').innerHTML = '';
  c1State.answered = false;
}

function c1Answer(guess) {
  if (c1State.answered) return;
  c1State.answered = true;
  const p = c1State.problems[c1State.current];
  const correct = (guess === p.answer);

  if (correct) c1State.score++;

  const yesBtn = document.getElementById('c1Yes');
  const noBtn = document.getElementById('c1No');
  yesBtn.disabled = true;
  noBtn.disabled = true;

  if (p.answer) {
    yesBtn.className = 'quiz-btn correct';
    if (!correct) noBtn.className = 'quiz-btn wrong';
  } else {
    noBtn.className = 'quiz-btn correct';
    if (!correct) yesBtn.className = 'quiz-btn wrong';
  }

  const fb = document.getElementById('c1Feedback');
  fb.className = 'feedback-box show ' + (correct ? 'correct' : 'wrong');
  fb.innerHTML = correct
    ? '<b>Correct!</b> Nice trace work.'
    : '<b>Not quite.</b> The answer is <b>' + (p.answer ? 'ACCEPT' : 'REJECT') + '</b>.';

  // Show walkthrough
  document.getElementById('c1Walkthrough').innerHTML =
    '<div class="diagram" style="font-size:0.85em;">' + p.walkthrough + '</div>';

  // Auto-advance after delay
  document.getElementById('c1Score').textContent =
    'Question ' + (c1State.current + 1) + ' of 3  |  Score: ' + c1State.score + '/' + (c1State.current + 1);

  if (c1State.current < 2) {
    setTimeout(() => {
      c1State.current++;
      c1Render();
    }, 2500);
  } else {
    setTimeout(() => {
      document.getElementById('c1Score').innerHTML =
        '<b>Final Score: ' + c1State.score + '/3</b>' +
        (c1State.score === 3 ? ' &mdash; Perfect!' : c1State.score >= 2 ? ' &mdash; Well done!' : ' &mdash; Keep practicing!') +
        ' <button class="sim-btn secondary" onclick="c1Init()" style="margin-left:12px;font-size:0.85em;">Try Again</button>';
    }, 2500);
  }
}

// ===========================
// CHALLENGE 2: Subset Construction (Slide 26)
// ===========================
// NFA "ends with ab": q0 --a--> {q0,q1}, q0 --b--> {q0}
//                     q1 --a--> {},       q1 --b--> {q2}
//                     q2 --a--> {},       q2 --b--> {}
// DFA states: {q0}, {q0,q1}, {q0,q2}
// Transitions:
//   {q0}    --a--> {q0,q1}   --b--> {q0}
//   {q0,q1} --a--> {q0,q1}   --b--> {q0,q2}
//   {q0,q2} --a--> {q0,q1}   --b--> {q0}

const c2Answer = {
  rows: [
    { state: '{q0}', a: '{q0,q1}', b: '{q0}', accept: false },
    { state: '{q0,q1}', a: '{q0,q1}', b: '{q0,q2}', accept: false },
    { state: '{q0,q2}', a: '{q0,q1}', b: '{q0}', accept: true }
  ]
};

let c2Cells = {};  // key: "row-col" -> { element, value, correct }
let pickerCallback = null;

function c2Init() {
  const grid = document.getElementById('c2Grid');
  c2Cells = {};
  let html = '<table class="bug-table">';
  html += '<tr><th>DFA State</th><th>a</th><th>b</th></tr>';

  c2Answer.rows.forEach((row, ri) => {
    const prefix = row.accept ? '* ' : (ri === 0 ? '-> ' : '');
    html += '<tr>';
    html += '<td>' + prefix + row.state + '</td>';
    ['a', 'b'].forEach((col, ci) => {
      const id = ri + '-' + ci;
      html += '<td class="clickable" id="c2-' + id + '" onclick="c2CellClick(\'' + id + '\')">' +
        '<span style="color:#64748b;">?</span></td>';
      c2Cells[id] = { value: null, correct: row[col] };
    });
    html += '</tr>';
  });
  html += '</table>';
  grid.innerHTML = html;
  document.getElementById('c2Feedback').className = 'feedback-box';
}

function c2CellClick(id) {
  const allStates = ['q0', 'q1', 'q2'];
  openPicker(allStates, (selected) => {
    const cell = document.getElementById('c2-' + id);
    const label = selected.length === 0 ? '{}' : '{' + selected.sort().join(',') + '}';
    cell.innerHTML = label;
    cell.className = 'clickable filled';
    c2Cells[id].value = label;
  });
}

function c2Check() {
  let allCorrect = true;
  let filled = 0;
  for (const id in c2Cells) {
    const cell = c2Cells[id];
    const el = document.getElementById('c2-' + id);
    if (!cell.value) {
      el.className = 'wrong-cell';
      allCorrect = false;
      continue;
    }
    filled++;
    if (cell.value === cell.correct) {
      el.className = 'correct-cell';
    } else {
      el.className = 'wrong-cell';
      allCorrect = false;
    }
  }

  const fb = document.getElementById('c2Feedback');
  if (filled < 6) {
    fb.className = 'feedback-box show wrong';
    fb.innerHTML = 'Fill in all cells first!';
  } else if (allCorrect) {
    fb.className = 'feedback-box show correct';
    fb.innerHTML = '<b>Perfect!</b> You nailed the subset construction. The DFA has 3 reachable states out of 2<sup>3</sup>=8 possible.';
  } else {
    fb.className = 'feedback-box show wrong';
    fb.innerHTML = '<b>Some cells are incorrect.</b> Remember: for each DFA state {s1,...,sk}, union all &delta;(si, a) for the NFA. Click cells to fix them.';
  }
}

function c2Reset() {
  c2Init();
  document.getElementById('c2Feedback').className = 'feedback-box';
}

// State picker
function openPicker(states, callback) {
  pickerCallback = callback;
  const opts = document.getElementById('pickerOptions');
  opts.innerHTML = '';
  states.forEach(s => {
    const btn = document.createElement('button');
    btn.className = 'state-toggle';
    btn.textContent = s;
    btn.onclick = () => btn.classList.toggle('selected');
    opts.appendChild(btn);
  });
  // Add empty set option
  document.getElementById('statePicker').classList.add('show');
  document.getElementById('pickerOverlay').classList.add('show');
}

function pickerConfirm() {
  const selected = [];
  document.querySelectorAll('#pickerOptions .state-toggle.selected').forEach(b => {
    selected.push(b.textContent);
  });
  document.getElementById('statePicker').classList.remove('show');
  document.getElementById('pickerOverlay').classList.remove('show');
  if (pickerCallback) pickerCallback(selected);
}

function pickerCancel() {
  document.getElementById('statePicker').classList.remove('show');
  document.getElementById('pickerOverlay').classList.remove('show');
}

// ===========================
// CHALLENGE 3: Spot the Bug (Slide 27)
// ===========================
// NFA "ends with 10": p0 --0--> {p0}, p0 --1--> {p0,p1}
//                     p1 --0--> {p2}, p1 --1--> {}
//                     p2 --0--> {},   p2 --1--> {}
// Correct subset construction:
//   {p0}     --0--> {p0}      --1--> {p0,p1}
//   {p0,p1}  --0--> {p0,p2}   --1--> {p0,p1}
//   *{p0,p2} --0--> {p0}      --1--> {p0,p1}
//
// Bug: Student wrote {p0,p1} --0--> {p0} instead of {p0,p2}
//   (forgot delta(p1,0) = {p2})

const c3CorrectTable = [
  ['{p0}',    '{p0}',    '{p0,p1}'],
  ['{p0,p1}', '{p0,p2}', '{p0,p1}'],
  ['*{p0,p2}','{p0}',    '{p0,p1}']
];

const c3BuggyTable = [
  ['{p0}',    '{p0}',    '{p0,p1}'],
  ['{p0,p1}', '{p0}',    '{p0,p1}'],    // BUG: should be {p0,p2}
  ['*{p0,p2}','{p0}',    '{p0,p1}']
];

const c3BugRow = 1, c3BugCol = 1; // 0-indexed
let c3Answered = false;

function c3Init() {
  c3Answered = false;
  const container = document.getElementById('c3Table');
  let html = '<table class="bug-table">';
  html += '<tr><th>DFA State</th><th>0</th><th>1</th></tr>';
  c3BuggyTable.forEach((row, ri) => {
    html += '<tr>';
    row.forEach((cell, ci) => {
      if (ci === 0) {
        const prefix = ri === 0 ? '-> ' : '';
        html += '<td>' + prefix + cell + '</td>';
      } else {
        html += '<td class="clickable" id="c3-' + ri + '-' + ci +
          '" onclick="c3Click(' + ri + ',' + ci + ')">' + cell + '</td>';
      }
    });
    html += '</tr>';
  });
  html += '</table>';
  container.innerHTML = html;
  document.getElementById('c3Feedback').className = 'feedback-box';
  document.getElementById('c3HintText').style.display = 'none';
}

function c3Click(row, col) {
  if (c3Answered) return;
  c3Answered = true;

  const fb = document.getElementById('c3Feedback');
  const clicked = document.getElementById('c3-' + row + '-' + col);
  const bugCell = document.getElementById('c3-' + c3BugRow + '-' + c3BugCol);

  if (row === c3BugRow && col === c3BugCol) {
    clicked.className = 'bug-found';
    clicked.innerHTML = '{p0} <span style="font-size:0.8em;">&#10060;</span>';
    fb.className = 'feedback-box show correct';
    fb.innerHTML = '<b>You found it!</b> The cell {p0,p1} on input 0 should be <b>{p0,p2}</b>, not {p0}.<br>' +
      '&delta;(p0,0) &cup; &delta;(p1,0) = {p0} &cup; {p2} = <b>{p0,p2}</b>. The student forgot to include p2 from &delta;(p1,0).' +
      '<br><button class="sim-btn secondary" onclick="c3Init()" style="margin-top:8px;font-size:0.85em;">Try Again</button>';
  } else {
    clicked.className = 'bug-miss';
    bugCell.className = 'bug-actual';
    fb.className = 'feedback-box show wrong';
    fb.innerHTML = '<b>Not that one.</b> The bug is in the highlighted cell: {p0,p1} on input 0.<br>' +
      'It says {p0}, but &delta;(p0,0) &cup; &delta;(p1,0) = {p0} &cup; {p2} = <b>{p0,p2}</b>.' +
      '<br><button class="sim-btn secondary" onclick="c3Init()" style="margin-top:8px;font-size:0.85em;">Try Again</button>';
  }
}

function c3ShowHint() {
  document.getElementById('c3HintText').style.display = 'block';
}

// ===========================
// SUBSET CONSTRUCTION VISUALIZER (Slide 19)
// ===========================
const scNFA = {
  states: ['q0', 'q1', 'q2'],
  accept: new Set(['q2']),
  delta: { 'q0': { '0': ['q0','q1'], '1': ['q0'] }, 'q1': { '0': [], '1': ['q2'] }, 'q2': { '0': [], '1': [] } }
};
const scAlphabet = ['0', '1'];

// Precomputed steps: each step is { fromState, symbol, components, result, isNew, isAccept }
// fromState = subset label, symbol = '0'|'1', components = detail string, result = subset label
const scSteps = [];
const scDFAStates = []; // ordered list of subset labels
const scDFATransitions = {}; // label -> { '0': label, '1': label }

function scBuildSteps() {
  scSteps.length = 0;
  scDFAStates.length = 0;
  for (const k in scDFATransitions) delete scDFATransitions[k];

  const seen = new Set();
  const queue = [];
  const startLabel = '{q0}';
  seen.add(startLabel);
  scDFAStates.push(startLabel);
  queue.push(['q0']);

  // Step 0: start state discovered (no transition step)
  scSteps.push({ type: 'start', state: startLabel, isAccept: false });

  while (queue.length > 0) {
    const subset = queue.shift();
    const fromLabel = scSetLabel(subset);
    scDFATransitions[fromLabel] = {};

    for (const sym of scAlphabet) {
      const parts = [];
      const resultSet = new Set();
      for (const s of subset) {
        const targets = scNFA.delta[s][sym] || [];
        parts.push('\u03B4(' + s + ',' + sym + ')=' + scSetLabel(targets));
        targets.forEach(t => resultSet.add(t));
      }
      const resultArr = [...resultSet].sort();
      const resultLabel = scSetLabel(resultArr);
      const isNew = !seen.has(resultLabel);
      const isAccept = resultArr.some(s => scNFA.accept.has(s));

      scDFATransitions[fromLabel][sym] = resultLabel;

      scSteps.push({
        type: 'transition',
        fromState: fromLabel,
        symbol: sym,
        components: parts.join(' \u222A '),
        result: resultLabel,
        isNew: isNew,
        isAccept: isAccept
      });

      if (isNew) {
        seen.add(resultLabel);
        scDFAStates.push(resultLabel);
        queue.push(resultArr);
      }
    }
  }

  scSteps.push({ type: 'done' });
}

function scSetLabel(arr) {
  if (!arr || arr.length === 0) return '{}';
  const sorted = [...arr].sort();
  return '{' + sorted.join(',') + '}';
}

// Visualizer state
let scCurrentStep = 0;
let scAutoRunning = false;
let scAutoTimer = null;

// DFA node positions (precomputed for 3 states)
const scNodePos = {
  '{q0}':    { x: 100, y: 120 },
  '{q0,q1}': { x: 280, y: 50 },
  '{q0,q2}': { x: 280, y: 190 }
};

function scReset() {
  scCurrentStep = 0;
  scAutoRunning = false;
  if (scAutoTimer) { clearTimeout(scAutoTimer); scAutoTimer = null; }
  document.getElementById('scTableBody').innerHTML = '';
  document.getElementById('scLog').innerHTML = 'Click "Next Step" to begin...';
  document.getElementById('scStepCount').textContent = '';
  document.getElementById('scNextBtn').disabled = false;
  document.getElementById('scAutoBtn').disabled = false;
  document.getElementById('scDone').style.display = 'none';

  // Clear DFA SVG (keep defs)
  const svg = document.getElementById('scDfaSvg');
  const defs = svg.querySelector('defs');
  svg.innerHTML = '';
  svg.appendChild(defs);

  // Reset NFA highlights
  ['q0','q1','q2'].forEach(s => {
    const el = document.getElementById('sc-nfa-' + s);
    if (el) el.className.baseVal = 'state-circle';
  });
}

function scNext() {
  if (scCurrentStep >= scSteps.length) return;
  const step = scSteps[scCurrentStep];
  scCurrentStep++;

  const totalTrans = scSteps.filter(s => s.type === 'transition').length;
  const doneTrans = scSteps.slice(0, scCurrentStep).filter(s => s.type === 'transition').length;

  if (step.type === 'start') {
    scAddTableRow(step.state, step.isAccept);
    scDrawNode(step.state, step.isAccept, true);
    scDrawStartArrow();
    scHighlightNFAStates(['q0']);
    scLogMsg('Start: DFA start state = ' + step.state, 'log-new');
    document.getElementById('scStepCount').textContent = 'Step 0 / ' + totalTrans;
  } else if (step.type === 'transition') {
    // Highlight processing row
    scHighlightRow(step.fromState);
    // Fill cell in table
    scFillCell(step.fromState, step.symbol, step.result);

    // If new state, add row and draw node
    if (step.isNew) {
      scAddTableRow(step.result, step.isAccept);
      scDrawNode(step.result, step.isAccept, false);
    }

    // Draw arrow
    scDrawArrow(step.fromState, step.symbol, step.result);

    // Highlight NFA states in the current subset being processed
    const fromStates = step.fromState.replace(/[{}]/g, '').split(',').filter(Boolean);
    scHighlightNFAStates(fromStates);

    // Log
    const tag = step.isNew ? (step.isAccept ? 'NEW, ACCEPT' : 'NEW') : 'already seen';
    scLogMsg(step.fromState + ' on \'' + step.symbol + '\': ' + step.components + ' = ' + step.result + ' (' + tag + ')',
             step.isNew ? 'log-new' : 'log-seen');

    document.getElementById('scStepCount').textContent = 'Step ' + doneTrans + ' / ' + totalTrans;
  } else if (step.type === 'done') {
    document.getElementById('scNextBtn').disabled = true;
    document.getElementById('scAutoBtn').disabled = true;
    scHighlightRow(null);
    scHighlightNFAStates([]);
    const doneDiv = document.getElementById('scDone');
    doneDiv.style.display = 'block';
    doneDiv.className = 'sc-done';
    doneDiv.innerHTML = 'Done! 3 DFA states discovered (out of 2<sup>3</sup>=8 possible). Accept state: {q0,q2}';
    scLogMsg('Algorithm complete! No new states to explore.', 'log-new');
  }
}

function scAuto() {
  if (scAutoRunning) return;
  scAutoRunning = true;
  document.getElementById('scNextBtn').disabled = true;
  document.getElementById('scAutoBtn').disabled = true;

  function tick() {
    if (scCurrentStep >= scSteps.length || !scAutoRunning) {
      scAutoRunning = false;
      return;
    }
    scNext();
    if (scCurrentStep < scSteps.length) {
      scAutoTimer = setTimeout(tick, 800);
    }
  }
  tick();
}

// Table helpers
function scAddTableRow(label, isAccept) {
  const tbody = document.getElementById('scTableBody');
  const tr = document.createElement('tr');
  tr.id = 'sc-row-' + label.replace(/[{},]/g, '_');
  const isStart = (label === '{q0}');
  const prefix = (isStart ? '-> ' : '') + (isAccept ? '* ' : '');
  tr.innerHTML = '<td>' + prefix + label + '</td><td id="sc-cell-' + label.replace(/[{},]/g, '_') + '-0"></td><td id="sc-cell-' + label.replace(/[{},]/g, '_') + '-1"></td>';
  tr.classList.add('sc-new');
  tbody.appendChild(tr);
}

function scFillCell(fromLabel, symbol, result) {
  const colIdx = symbol === '0' ? 0 : 1;
  const cellId = 'sc-cell-' + fromLabel.replace(/[{},]/g, '_') + '-' + colIdx;
  const cell = document.getElementById(cellId);
  if (cell) cell.textContent = result;
}

function scHighlightRow(label) {
  document.querySelectorAll('.sc-table tbody tr').forEach(tr => tr.classList.remove('sc-processing'));
  if (label) {
    const row = document.getElementById('sc-row-' + label.replace(/[{},]/g, '_'));
    if (row) row.classList.add('sc-processing');
  }
}

// NFA highlights
function scHighlightNFAStates(states) {
  ['q0','q1','q2'].forEach(s => {
    const el = document.getElementById('sc-nfa-' + s);
    if (el) el.className.baseVal = states.includes(s) ? 'state-circle active' : 'state-circle';
  });
}

// SVG drawing helpers
function scDrawStartArrow() {
  const svg = document.getElementById('scDfaSvg');
  const pos = scNodePos['{q0}'];
  const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  line.setAttribute('x1', pos.x - 55);
  line.setAttribute('y1', pos.y);
  line.setAttribute('x2', pos.x - 28);
  line.setAttribute('y2', pos.y);
  line.setAttribute('class', 'dfa-arrow');
  svg.appendChild(line);
}

function scDrawNode(label, isAccept, animate) {
  const svg = document.getElementById('scDfaSvg');
  const pos = scNodePos[label];
  if (!pos) return;

  const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  g.id = 'sc-dfa-node-' + label.replace(/[{},]/g, '_');

  const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
  circle.setAttribute('cx', pos.x);
  circle.setAttribute('cy', pos.y);
  circle.setAttribute('r', 26);
  circle.setAttribute('class', 'dfa-node' + (isAccept ? ' sc-accept' : '') + (animate ? '' : ' sc-active'));

  g.appendChild(circle);

  if (isAccept) {
    const inner = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    inner.setAttribute('cx', pos.x);
    inner.setAttribute('cy', pos.y);
    inner.setAttribute('r', 21);
    inner.setAttribute('fill', 'none');
    inner.setAttribute('stroke', '#10b981');
    inner.setAttribute('stroke-width', '2');
    g.appendChild(inner);
  }

  const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  text.setAttribute('x', pos.x);
  text.setAttribute('y', pos.y);
  text.setAttribute('class', 'dfa-label');
  text.textContent = label;
  g.appendChild(text);

  svg.appendChild(g);

  if (!animate) {
    setTimeout(() => circle.classList.remove('sc-active'), 600);
  }
}

function scDrawArrow(from, symbol, to) {
  const svg = document.getElementById('scDfaSvg');
  const p1 = scNodePos[from];
  const p2 = scNodePos[to];
  if (!p1 || !p2) return;

  if (from === to) {
    scDrawSelfLoop(svg, p1, symbol, from);
    return;
  }

  // Check if reverse arrow exists to offset
  const reverseKey = to + '->' + from;
  const forwardKey = from + '->' + to;
  const existingReverse = svg.querySelector('[data-edge="' + reverseKey + '"]');

  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  const len = Math.sqrt(dx * dx + dy * dy);
  const nx = dx / len;
  const ny = dy / len;

  // Perpendicular offset for curved arrows
  const offset = existingReverse ? 12 : 0;
  const px = -ny * offset;
  const py = nx * offset;

  const startX = p1.x + nx * 28 + px;
  const startY = p1.y + ny * 28 + py;
  const endX = p2.x - nx * 28 + px;
  const endY = p2.y - ny * 28 + py;

  const midX = (startX + endX) / 2 + px;
  const midY = (startY + endY) / 2 + py;

  const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  g.setAttribute('data-edge', forwardKey);
  g.setAttribute('class', 'dfa-arrow-new');

  if (offset !== 0) {
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const cpx = (startX + endX) / 2 + px * 1.5;
    const cpy = (startY + endY) / 2 + py * 1.5;
    path.setAttribute('d', 'M ' + startX + ' ' + startY + ' Q ' + cpx + ' ' + cpy + ' ' + endX + ' ' + endY);
    path.setAttribute('class', 'dfa-arrow');
    g.appendChild(path);

    const labelEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    labelEl.setAttribute('x', cpx);
    labelEl.setAttribute('y', cpy - 6);
    labelEl.setAttribute('class', 'dfa-arrow-label');
    labelEl.textContent = symbol;
    g.appendChild(labelEl);
  } else {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', startX);
    line.setAttribute('y1', startY);
    line.setAttribute('x2', endX);
    line.setAttribute('y2', endY);
    line.setAttribute('class', 'dfa-arrow');
    g.appendChild(line);

    const labelEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    labelEl.setAttribute('x', midX);
    labelEl.setAttribute('y', midY - 8);
    labelEl.setAttribute('class', 'dfa-arrow-label');
    labelEl.textContent = symbol;
    g.appendChild(labelEl);
  }

  svg.appendChild(g);
}

function scDrawSelfLoop(svg, pos, symbol, stateLabel) {
  const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  g.setAttribute('class', 'dfa-arrow-new');

  // Determine loop direction based on position
  let loopDir;
  if (stateLabel === '{q0}') loopDir = 'left';
  else if (stateLabel === '{q0,q1}') loopDir = 'top';
  else loopDir = 'bottom';

  let pathD, labelX, labelY;
  if (loopDir === 'left') {
    pathD = 'M ' + (pos.x - 18) + ' ' + (pos.y - 20) + ' C ' + (pos.x - 60) + ' ' + (pos.y - 50) + ', ' + (pos.x - 60) + ' ' + (pos.y + 50) + ', ' + (pos.x - 18) + ' ' + (pos.y + 20);
    labelX = pos.x - 62;
    labelY = pos.y;
  } else if (loopDir === 'top') {
    pathD = 'M ' + (pos.x - 18) + ' ' + (pos.y - 20) + ' C ' + (pos.x - 35) + ' ' + (pos.y - 60) + ', ' + (pos.x + 35) + ' ' + (pos.y - 60) + ', ' + (pos.x + 18) + ' ' + (pos.y - 20);
    labelX = pos.x;
    labelY = pos.y - 56;
  } else {
    pathD = 'M ' + (pos.x - 18) + ' ' + (pos.y + 20) + ' C ' + (pos.x - 35) + ' ' + (pos.y + 60) + ', ' + (pos.x + 35) + ' ' + (pos.y + 60) + ', ' + (pos.x + 18) + ' ' + (pos.y + 20);
    labelX = pos.x;
    labelY = pos.y + 68;
  }

  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('d', pathD);
  path.setAttribute('class', 'dfa-arrow');
  g.appendChild(path);

  const labelEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  labelEl.setAttribute('x', labelX);
  labelEl.setAttribute('y', labelY);
  labelEl.setAttribute('class', 'dfa-arrow-label');
  labelEl.textContent = symbol;
  g.appendChild(labelEl);

  svg.appendChild(g);
}

function scLogMsg(msg, cls) {
  const log = document.getElementById('scLog');
  if (log.innerHTML === 'Click "Next Step" to begin...') log.innerHTML = '';
  log.innerHTML += '<div class="' + (cls || '') + '">' + msg + '</div>';
  log.scrollTop = log.scrollHeight;
}

scBuildSteps();

// ===========================
// EPSILON-CLOSURE EXPLORER (Slide 22)
// ===========================
const eclEpsilonEdges = {
  'A': [],
  'B': [{ to: 'D', edgeId: 'ecl-eps-B-D' }],
  'C': [],
  'D': [],
  'E': [{ to: 'B', edgeId: 'ecl-eps-E-B' }, { to: 'C', edgeId: 'ecl-eps-E-C' }],
  'F': []
};

const eclAllStates = ['A', 'B', 'C', 'D', 'E', 'F'];
let eclTimers = [];

function eclReset() {
  eclTimers.forEach(t => clearTimeout(t));
  eclTimers = [];
  eclAllStates.forEach(s => {
    const el = document.getElementById('ecl-' + s);
    if (el) el.className.baseVal = 'state-circle';
  });
  const dInner = document.getElementById('ecl-D-inner');
  if (dInner) { dInner.setAttribute('stroke', '#475569'); }
  // Reset epsilon edges
  ['ecl-eps-B-D', 'ecl-eps-E-B', 'ecl-eps-E-C'].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.className.baseVal = 'eps-arrow';
      el.setAttribute('marker-end', 'url(#eclArrowEps)');
    }
  });
  document.getElementById('eclResult').innerHTML = 'Click any state above to visualize its &epsilon;-closure...';
  document.querySelectorAll('.ecl-state-btn').forEach(b => b.classList.remove('ecl-selected'));
}

function eclExplore(state) {
  eclReset();
  // Highlight selected button
  document.querySelectorAll('.ecl-state-btn').forEach(b => {
    if (b.textContent === state) b.classList.add('ecl-selected');
  });

  // BFS to compute closure with step-by-step info
  const closure = new Set([state]);
  const bfsWaves = []; // each wave: { discovered: [...], edges: [...] }
  const queue = [state];
  const visited = new Set([state]);

  // BFS
  while (queue.length > 0) {
    const current = queue.shift();
    const edges = eclEpsilonEdges[current] || [];
    const newStates = [];
    const newEdges = [];
    for (const e of edges) {
      if (!visited.has(e.to)) {
        visited.add(e.to);
        closure.add(e.to);
        queue.push(e.to);
        newStates.push(e.to);
        newEdges.push(e.edgeId);
      }
    }
    if (newStates.length > 0) {
      bfsWaves.push({ from: current, discovered: newStates, edges: newEdges });
    }
  }

  // Animate: step 0 = highlight source
  const srcEl = document.getElementById('ecl-' + state);
  if (srcEl) srcEl.className.baseVal = 'state-circle ecl-found';
  if (state === 'D') {
    document.getElementById('ecl-D-inner').setAttribute('stroke', '#3b82f6');
  }

  let resultHtml = '<span class="ecl-set">CL(' + state + ')</span> = {' + state + '}';

  if (bfsWaves.length === 0) {
    resultHtml += '<br><span class="ecl-step">No &epsilon;-transitions from ' + state + '.</span>';
    resultHtml += '<br><b style="color:#e2e8f0;">Result: {' + state + '}</b>';
    document.getElementById('eclResult').innerHTML = resultHtml;
    return;
  }

  document.getElementById('eclResult').innerHTML = resultHtml + '<br><span class="ecl-step">Following &epsilon;-transitions...</span>';

  let delay = 500;
  bfsWaves.forEach((wave, wi) => {
    eclTimers.push(setTimeout(() => {
      // Glow edges
      wave.edges.forEach(edgeId => {
        const edgeEl = document.getElementById(edgeId);
        if (edgeEl) {
          edgeEl.className.baseVal = 'eps-arrow ecl-glow';
          edgeEl.setAttribute('marker-end', 'url(#eclArrowEpsGlow)');
        }
      });
      // Highlight discovered states
      wave.discovered.forEach(s => {
        const el = document.getElementById('ecl-' + s);
        if (el) el.className.baseVal = 'state-circle ecl-discover';
        if (s === 'D') {
          document.getElementById('ecl-D-inner').setAttribute('stroke', '#3b82f6');
        }
      });

      // Update result text
      const closureSoFar = [state];
      for (let i = 0; i <= wi; i++) {
        bfsWaves[i].discovered.forEach(s => closureSoFar.push(s));
      }
      const sortedClosure = closureSoFar.sort();
      let html = '<span class="ecl-set">CL(' + state + ')</span><br>';
      html += '<span class="ecl-step">' + wave.from + ' &mdash;&epsilon;&rarr; ' + wave.discovered.join(', ') + '</span>';
      if (wi < bfsWaves.length - 1) {
        html += '<br><span class="ecl-chain">Chaining: ' + wave.discovered.filter(s => eclEpsilonEdges[s].length > 0).join(', ') + ' also has &epsilon;-transitions...</span>';
      }
      html += '<br><b style="color:#e2e8f0;">Result so far: {' + sortedClosure.join(', ') + '}</b>';
      if (wi === bfsWaves.length - 1) {
        html += '<br><span style="color:#34d399;">Done! CL(' + state + ') = {' + sortedClosure.join(', ') + '}</span>';
      }
      document.getElementById('eclResult').innerHTML = html;
    }, delay));
    delay += 600;
  });
}

// ===========================
// INITIALIZATION
// ===========================
c1Init();
c2Init();
c3Init();
</script>
</body>
</html>
