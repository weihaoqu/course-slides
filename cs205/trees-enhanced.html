<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>CS205 — Trees Enhanced</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; background: #0f172a; color: #e2e8f0; }
.slide { display: none; min-height: 100vh; padding: 40px 60px; position: relative; }
.slide.active { display: flex; flex-direction: column; justify-content: center; }
.slide-number { position: absolute; bottom: 20px; right: 40px; color: #64748b; font-size: 14px; }
.nav { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; z-index: 100; }
.nav button { background: #334155; border: 1px solid #475569; color: #e2e8f0; padding: 8px 20px; border-radius: 8px; cursor: pointer; font-size: 14px; transition: all 0.2s; }
.nav button:hover { background: #475569; }
.nav button:disabled { opacity: 0.3; cursor: not-allowed; }
#progress-bar { position: fixed; top: 0; left: 0; width: 100%; height: 3px; background: rgba(51,65,85,0.5); z-index: 100; }
#progress { height: 100%; width: 0; background: linear-gradient(90deg, #6366f1, #8b5cf6); transition: width 0.3s; }
h1 { font-size: 2.8em; margin-bottom: 20px; background: linear-gradient(135deg, #6366f1, #8b5cf6); -webkit-background-clip: text; -webkit-text-fill-color: transparent; line-height: 1.2; }
h2 { font-size: 1.8em; margin-bottom: 16px; color: #38bdf8; }
h3 { font-size: 1.2em; margin-bottom: 10px; color: #a78bfa; }
p, li { font-size: 1.05em; line-height: 1.7; color: #cbd5e1; margin-bottom: 8px; }
code { background: #1e293b; padding: 2px 8px; border-radius: 4px; font-family: monospace; color: #a5f3fc; font-size: 0.95em; }
ul { padding-left: 24px; }
ul li { margin-bottom: 6px; }
table { border-collapse: collapse; margin: 12px 0; }
th, td { border: 1px solid #475569; padding: 8px 14px; text-align: center; font-size: 0.9em; }
th { background: #334155; color: #38bdf8; font-weight: 600; }
td { background: rgba(30,41,59,0.6); color: #e2e8f0; }
.fade-in { animation: fadeIn 0.4s ease-in; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
.btn { background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; border: none; padding: 8px 18px; border-radius: 8px; cursor: pointer; font-size: 0.9em; transition: all 0.2s; }
.btn:hover { opacity: 0.9; transform: translateY(-1px); }
.btn-sm { padding: 5px 14px; font-size: 0.82em; }
.btn-secondary { background: #334155; border: 1px solid #475569; }
.btn-secondary:hover { background: #475569; }
.key-idea { background: linear-gradient(135deg, rgba(59,130,246,0.15), rgba(139,92,246,0.15)); border-left: 4px solid #3b82f6; border-radius: 0 12px 12px 0; padding: 16px 20px; margin: 12px 0; }
.warning { background: rgba(245,158,11,0.12); border-left: 4px solid #f59e0b; border-radius: 0 12px 12px 0; padding: 16px 20px; margin: 12px 0; }
.warning h3 { color: #fbbf24; }
.analogy { background: rgba(16,185,129,0.12); border-left: 4px solid #10b981; border-radius: 0 12px 12px 0; padding: 16px 20px; margin: 12px 0; }
.analogy h3 { color: #34d399; }
.code-block { background: #1e293b; border: 1px solid #334155; border-radius: 10px; padding: 16px; margin: 10px 0; overflow-x: auto; }
.code-content { font-family: monospace; font-size: 0.88em; line-height: 1.7; }
.line { padding: 1px 8px; border-left: 3px solid transparent; border-radius: 2px; white-space: pre; color: #e2e8f0; }
.line.active { background: rgba(99,102,241,0.15); border-left-color: #6366f1; }
</style>
</head>
<body>

<div id="progress-bar"><div id="progress"></div></div>

<!-- ============================================================ -->
<!-- SLIDE 1: Title -->
<!-- ============================================================ -->
<div class="slide active fade-in" id="s1">
  <div style="text-align:center;width:100%;">
    <h1 style="font-size:3.2em;margin-bottom:10px;">Trees</h1>
    <p style="font-size:1.4em;color:#94a3b8;margin-bottom:8px;">Hierarchical Data Structures</p>
    <p style="font-size:1.1em;color:#64748b;margin-bottom:30px;">CS205 Data Structures</p>
    <canvas id="cS1" width="520" height="300" style="background:rgba(0,0,0,0.2);border-radius:12px;display:inline-block;"></canvas>
    <p style="color:#64748b;margin-top:20px;font-size:0.95em;">Use arrow keys or buttons to navigate</p>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS1');
  const ctx=canvas.getContext('2d');
  // Animated tree growing node by node
  const nodes=[
    {id:'A',x:260,y:40,parent:-1},
    {id:'B',x:140,y:120,parent:0},
    {id:'C',x:380,y:120,parent:0},
    {id:'D',x:80,y:210,parent:1},
    {id:'E',x:200,y:210,parent:1},
    {id:'F',x:380,y:210,parent:2}
  ];
  let visCount=0, timer=null;

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // edges
    for(let i=1;i<visCount;i++){
      const n=nodes[i],p=nodes[n.parent];
      ctx.strokeStyle='#475569';ctx.lineWidth=2;
      ctx.beginPath();ctx.moveTo(p.x,p.y+20);ctx.lineTo(n.x,n.y-20);ctx.stroke();
    }
    // nodes
    for(let i=0;i<visCount;i++){
      const n=nodes[i];
      const isLeaf=!nodes.some((c,j)=>j<visCount&&c.parent===i);
      ctx.fillStyle=i===0?'#f59e0b':isLeaf?'#22c55e':'#6366f1';
      ctx.strokeStyle=i===0?'#fbbf24':isLeaf?'#4ade80':'#818cf8';
      ctx.lineWidth=2;
      ctx.beginPath();ctx.arc(n.x,n.y,20,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 16px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(n.id,n.x,n.y);
    }
    // labels
    if(visCount>0){
      ctx.fillStyle='#f59e0b';ctx.font='11px monospace';ctx.textAlign='left';
      ctx.fillText('← root',nodes[0].x+26,nodes[0].y+4);
    }
    if(visCount>=6){
      ctx.fillStyle='#22c55e';ctx.font='11px monospace';ctx.textAlign='right';
      ctx.fillText('leaves →',nodes[3].x-26,nodes[3].y+4);
    }
    // legend
    ctx.fillStyle='#64748b';ctx.font='11px monospace';ctx.textAlign='center';
    ctx.fillText('nodes: '+visCount+'   edges: '+Math.max(0,visCount-1),canvas.width/2,canvas.height-15);
  }

  function grow(){
    if(visCount<nodes.length){
      visCount++;draw();
    } else {
      clearInterval(timer);timer=null;
      // restart after pause
      setTimeout(()=>{visCount=0;draw();setTimeout(startGrow,800);},3000);
    }
  }

  function startGrow(){
    if(timer) return;
    timer=setInterval(grow,600);
  }

  const obs=new MutationObserver(()=>{
    if(document.getElementById('s1').classList.contains('active')){visCount=0;draw();setTimeout(startGrow,500);}
    else{if(timer){clearInterval(timer);timer=null;}}
  });
  obs.observe(document.getElementById('s1'),{attributes:true,attributeFilter:['class']});
  visCount=0;draw();setTimeout(startGrow,500);
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 2: What Is a Tree? -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s2">
  <h2>What Is a Tree?</h2>
  <p>A <strong>tree</strong> is a hierarchical data structure of <strong>nodes</strong> connected by <strong>edges</strong>.</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cS2" width="520" height="320" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
      <div id="s2Info" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.6rem;font-family:monospace;font-size:0.8rem;min-height:40px;margin-top:0.5rem;color:#94a3b8;text-align:center;">Click any node to explore</div>
    </div>
    <div>
      <ul style="font-size:0.92rem;line-height:1.9;">
        <li><strong style="color:#f59e0b;">Root</strong> — topmost node (no parent)</li>
        <li><strong style="color:#a78bfa;">Children</strong> — nodes directly below a node</li>
        <li><strong style="color:#38bdf8;">Parent</strong> — the node directly above</li>
        <li><strong style="color:#22c55e;">Leaves</strong> — nodes with no children</li>
        <li><strong>Edge</strong> — connection between parent and child</li>
      </ul>
      <div class="analogy" style="margin-top:1rem;">
        <h3>Analogy: Family Tree</h3>
        <p>One ancestor at the top, descendants branching down. Or a <strong>file system</strong>: root folder with subfolders and files.</p>
      </div>
      <div class="key-idea" style="margin-top:0.75rem;">
        <h3>Key Property</h3>
        <p>n nodes → exactly <strong>n − 1 edges</strong>. There is exactly <strong>one path</strong> between any two nodes.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS2');
  const ctx=canvas.getContext('2d');
  const nodes=[
    {id:'A',x:260,y:45,parent:-1},
    {id:'B',x:140,y:130,parent:0},
    {id:'C',x:380,y:130,parent:0},
    {id:'D',x:70,y:220,parent:1},
    {id:'E',x:200,y:220,parent:1},
    {id:'F',x:380,y:220,parent:2}
  ];
  let selected=-1;

  function getChildren(i){return nodes.map((n,j)=>n.parent===i?j:-1).filter(j=>j>=0);}
  function isLeaf(i){return getChildren(i).length===0;}

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // edges
    for(let i=1;i<nodes.length;i++){
      const n=nodes[i],p=nodes[n.parent];
      const hlEdge=(selected===i||selected===n.parent);
      ctx.strokeStyle=hlEdge?'#f59e0b':'#475569';ctx.lineWidth=hlEdge?3:2;
      ctx.beginPath();ctx.moveTo(p.x,p.y+20);ctx.lineTo(n.x,n.y-20);ctx.stroke();
    }
    // nodes
    for(let i=0;i<nodes.length;i++){
      const n=nodes[i];
      const isSel=(i===selected);
      const isChild=selected>=0&&nodes[i].parent===selected;
      const isPar=selected>=0&&i===nodes[selected].parent;
      const leaf=isLeaf(i);
      let fill=leaf?'#22c55e':(i===0?'#f59e0b':'#6366f1');
      let stroke=leaf?'#4ade80':(i===0?'#fbbf24':'#818cf8');
      if(isSel){fill='#f59e0b';stroke='#fbbf24';}
      else if(isChild){fill='#a78bfa';stroke='#c4b5fd';}
      else if(isPar){fill='#38bdf8';stroke='#7dd3fc';}
      ctx.fillStyle=fill;ctx.strokeStyle=stroke;ctx.lineWidth=isSel?3:2;
      ctx.beginPath();ctx.arc(n.x,n.y,20,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 15px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(n.id,n.x,n.y);
      // label
      if(isSel){
        ctx.fillStyle='#f59e0b';ctx.font='10px monospace';ctx.textAlign='center';
        ctx.fillText('selected',n.x,n.y+34);
      } else if(isChild){
        ctx.fillStyle='#a78bfa';ctx.font='10px monospace';ctx.textAlign='center';
        ctx.fillText('child',n.x,n.y+34);
      } else if(isPar){
        ctx.fillStyle='#38bdf8';ctx.font='10px monospace';ctx.textAlign='center';
        ctx.fillText('parent',n.x,n.y+34);
      } else if(leaf&&selected<0){
        ctx.fillStyle='#22c55e';ctx.font='10px monospace';ctx.textAlign='center';
        ctx.fillText('leaf',n.x,n.y+34);
      }
    }
    // header
    ctx.fillStyle='#e2e8f0';ctx.font='bold 12px monospace';ctx.textAlign='left';
    ctx.fillText('nodes: '+nodes.length+'   edges: '+(nodes.length-1),15,canvas.height-12);
  }

  function updateInfo(){
    const el=document.getElementById('s2Info');
    if(selected<0){el.innerHTML='Click any node to explore';return;}
    const n=nodes[selected];
    const children=getChildren(selected).map(j=>nodes[j].id);
    const parent=n.parent>=0?nodes[n.parent].id:'none (root)';
    const leaf=isLeaf(selected);
    el.innerHTML='<span style="color:#f59e0b;">'+n.id+'</span> — parent: <span style="color:#38bdf8;">'+parent+'</span>, children: <span style="color:#a78bfa;">'+(children.length?children.join(', '):'none')+'</span>'+(leaf?' <span style="color:#22c55e;">(leaf)</span>':'')+(selected===0?' <span style="color:#f59e0b;">(root)</span>':'');
  }

  canvas.addEventListener('click',(e)=>{
    const rect=canvas.getBoundingClientRect();
    const sx=canvas.width/rect.width, sy=canvas.height/rect.height;
    const mx=(e.clientX-rect.left)*sx, my=(e.clientY-rect.top)*sy;
    selected=-1;
    for(let i=0;i<nodes.length;i++){
      const dx=mx-nodes[i].x, dy=my-nodes[i].y;
      if(dx*dx+dy*dy<625){selected=i;break;}
    }
    draw();updateInfo();
  });

  const obs=new MutationObserver(()=>{
    if(document.getElementById('s2').classList.contains('active')){selected=-1;draw();updateInfo();}
  });
  obs.observe(document.getElementById('s2'),{attributes:true,attributeFilter:['class']});
  draw();
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 3: Tree Terminology -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s3">
  <h2>Tree Terminology</h2>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cS3" width="520" height="340" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
      <div id="s3Info" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.6rem;font-family:monospace;font-size:0.78rem;min-height:40px;margin-top:0.5rem;color:#94a3b8;text-align:center;">Click any node to see its properties</div>
    </div>
    <div>
      <ul style="font-size:0.88rem;line-height:1.8;">
        <li><strong>Root</strong> — node with no parent (A)</li>
        <li><strong>Siblings</strong> — same parent (B, C, D)</li>
        <li><strong>Ancestor</strong> of E — B, A</li>
        <li><strong>Descendant</strong> of B — E, F</li>
        <li><strong>Leaf / External</strong> — no children</li>
        <li><strong>Internal node</strong> — has children</li>
        <li><strong style="color:#f59e0b;">Depth</strong> — edges from root to node</li>
        <li><strong style="color:#22c55e;">Height</strong> — edges on longest path down to a leaf</li>
        <li><strong>Subtree</strong> rooted at B — B, E, F</li>
      </ul>
      <div class="key-idea" style="margin-top:0.75rem;">
        <h3>Height of tree = max depth of any leaf</h3>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS3');
  const ctx=canvas.getContext('2d');
  // A at top, B/C/D at depth 1, E/F under B, G/H under D
  const nodes=[
    {id:'A',x:260,y:40,parent:-1,depth:0,height:2},
    {id:'B',x:120,y:130,parent:0,depth:1,height:1},
    {id:'C',x:260,y:130,parent:0,depth:1,height:0},
    {id:'D',x:400,y:130,parent:0,depth:1,height:1},
    {id:'E',x:70,y:230,parent:1,depth:2,height:0},
    {id:'F',x:170,y:230,parent:1,depth:2,height:0},
    {id:'G',x:350,y:230,parent:3,depth:2,height:0},
    {id:'H',x:450,y:230,parent:3,depth:2,height:0}
  ];
  let selected=-1;

  function getChildren(i){return nodes.map((n,j)=>n.parent===i?j:-1).filter(j=>j>=0);}
  function getAncestors(i){const a=[];let c=nodes[i].parent;while(c>=0){a.push(c);c=nodes[c].parent;}return a;}
  function getDescendants(i){const d=[];const q=[i];while(q.length){const c=q.shift();getChildren(c).forEach(ch=>{d.push(ch);q.push(ch);});}return d;}

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const ancestors=selected>=0?getAncestors(selected):[];
    const descendants=selected>=0?getDescendants(selected):[];
    // depth labels on left
    for(let d=0;d<=2;d++){
      const y=40+d*95;
      ctx.fillStyle='#64748b';ctx.font='10px monospace';ctx.textAlign='right';
      ctx.fillText('depth '+d,35,y+4);
      ctx.strokeStyle='#1e293b';ctx.lineWidth=1;ctx.setLineDash([4,4]);
      ctx.beginPath();ctx.moveTo(40,y);ctx.lineTo(canvas.width-10,y);ctx.stroke();
      ctx.setLineDash([]);
    }
    // edges
    for(let i=1;i<nodes.length;i++){
      const n=nodes[i],p=nodes[n.parent];
      const hl=selected>=0&&(i===selected||n.parent===selected||ancestors.includes(i)||ancestors.includes(n.parent));
      ctx.strokeStyle=hl?'#f59e0b':'#475569';ctx.lineWidth=hl?2.5:1.5;
      ctx.beginPath();ctx.moveTo(p.x,p.y+18);ctx.lineTo(n.x,n.y-18);ctx.stroke();
    }
    // nodes
    for(let i=0;i<nodes.length;i++){
      const n=nodes[i];
      const isSel=i===selected;
      const isAnc=ancestors.includes(i);
      const isDesc=descendants.includes(i);
      const leaf=getChildren(i).length===0;
      let fill=isSel?'#f59e0b':isAnc?'#38bdf8':isDesc?'#a78bfa':leaf?'#22c55e':'#6366f1';
      let stroke=isSel?'#fbbf24':isAnc?'#7dd3fc':isDesc?'#c4b5fd':leaf?'#4ade80':'#818cf8';
      ctx.fillStyle=fill;ctx.strokeStyle=stroke;ctx.lineWidth=isSel?3:2;
      ctx.beginPath();ctx.arc(n.x,n.y,18,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 14px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(n.id,n.x,n.y);
      // depth/height label
      if(isSel){
        ctx.fillStyle='#f59e0b';ctx.font='bold 10px monospace';ctx.textAlign='center';
        ctx.fillText('d='+n.depth+' h='+n.height,n.x,n.y+30);
      }
    }
    ctx.fillStyle='#e2e8f0';ctx.font='bold 11px monospace';ctx.textAlign='left';
    ctx.fillText('Height of tree = 2',15,canvas.height-12);
  }

  function updateInfo(){
    const el=document.getElementById('s3Info');
    if(selected<0){el.innerHTML='Click any node to see its properties';return;}
    const n=nodes[selected];
    const ch=getChildren(selected).map(j=>nodes[j].id);
    const anc=getAncestors(selected).map(j=>nodes[j].id);
    const desc=getDescendants(selected).map(j=>nodes[j].id);
    const siblings=selected>0?getChildren(nodes[selected].parent).filter(j=>j!==selected).map(j=>nodes[j].id):[];
    const leaf=ch.length===0;
    el.innerHTML='<span style="color:#f59e0b;">'+n.id+'</span> — depth: <strong>'+n.depth+'</strong>, height: <strong>'+n.height+'</strong> | '+(leaf?'<span style="color:#22c55e;">leaf</span>':'internal')+' | ancestors: <span style="color:#38bdf8;">'+(anc.length?anc.join(','):'none')+'</span> | descendants: <span style="color:#a78bfa;">'+(desc.length?desc.join(','):'none')+'</span>'+(siblings.length?' | siblings: '+siblings.join(','):'');
  }

  canvas.addEventListener('click',(e)=>{
    const rect=canvas.getBoundingClientRect();
    const sx=canvas.width/rect.width,sy=canvas.height/rect.height;
    const mx=(e.clientX-rect.left)*sx,my=(e.clientY-rect.top)*sy;
    selected=-1;
    for(let i=0;i<nodes.length;i++){
      const dx=mx-nodes[i].x,dy=my-nodes[i].y;
      if(dx*dx+dy*dy<400){selected=i;break;}
    }
    draw();updateInfo();
  });

  const obs=new MutationObserver(()=>{
    if(document.getElementById('s3').classList.contains('active')){selected=-1;draw();updateInfo();}
  });
  obs.observe(document.getElementById('s3'),{attributes:true,attributeFilter:['class']});
  draw();
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 4: Formal Definition -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s4">
  <h2>Formal Definition of a Tree</h2>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cS4" width="520" height="340" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
      <div style="display:flex;gap:0.5rem;margin-top:0.5rem;">
        <button class="btn btn-sm" onclick="s4Zoom('A')">Full Tree</button>
        <button class="btn btn-sm btn-secondary" onclick="s4Zoom('B')">Subtree at B</button>
        <button class="btn btn-sm btn-secondary" onclick="s4Zoom('C')">Subtree at C</button>
        <button class="btn btn-sm btn-secondary" onclick="s4Zoom('D')">Leaf D</button>
      </div>
    </div>
    <div>
      <div class="key-idea">
        <h3>Recursive Definition</h3>
        <p>A <strong>tree T</strong> is either:</p>
        <ul style="font-size:0.9rem;">
          <li><strong>Empty</strong> (null / no nodes), OR</li>
          <li>A <strong>root node r</strong> with zero or more <strong>subtrees</strong> T<sub>1</sub>, T<sub>2</sub>, ..., T<sub>k</sub></li>
        </ul>
      </div>
      <div class="warning" style="margin-top:0.75rem;">
        <h3>Key Property</h3>
        <p>A tree with <strong>n</strong> nodes always has exactly <strong>n − 1</strong> edges. Exactly <strong>one path</strong> between any two nodes (no cycles!).</p>
      </div>
      <div class="analogy" style="margin-top:0.75rem;">
        <h3>Think Recursively</h3>
        <p>Every node is the root of its own subtree. "Zoom in" on any node and you see a smaller tree. Click the buttons to see this in action!</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS4');
  const ctx=canvas.getContext('2d');
  const tree={id:'A',children:[
    {id:'B',children:[{id:'D',children:[]},{id:'E',children:[]}]},
    {id:'C',children:[{id:'F',children:[]}]}
  ]};

  function findNode(node,id){
    if(node.id===id) return node;
    for(const c of node.children){const r=findNode(c,id);if(r)return r;}
    return null;
  }

  function countNodes(node){let c=1;node.children.forEach(ch=>c+=countNodes(ch));return c;}

  function layoutTree(node,x,y,spread){
    const positions=[{id:node.id,x,y}];
    const n=node.children.length;
    if(n>0){
      const totalW=spread;
      const step=totalW/(n);
      let sx=x-totalW/2+step/2;
      for(let i=0;i<n;i++){
        const sub=layoutTree(node.children[i],sx,y+85,spread/n*0.9);
        positions.push(...sub);
        sx+=step;
      }
    }
    return positions;
  }

  let currentRoot='A';

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const sub=findNode(tree,currentRoot);
    if(!sub) return;
    const positions=layoutTree(sub,canvas.width/2,50,400);
    // build parent map
    function drawEdges(node,pmap){
      for(const c of node.children){
        const pi=positions.find(p=>p.id===node.id);
        const ci=positions.find(p=>p.id===c.id);
        if(pi&&ci){
          ctx.strokeStyle='#475569';ctx.lineWidth=2;
          ctx.beginPath();ctx.moveTo(pi.x,pi.y+18);ctx.lineTo(ci.x,ci.y-18);ctx.stroke();
        }
        drawEdges(c,pmap);
      }
    }
    drawEdges(sub,{});
    // nodes
    for(const pos of positions){
      const node=findNode(sub,pos.id);
      const isLeaf=node.children.length===0;
      const isRoot=pos.id===currentRoot;
      ctx.fillStyle=isRoot?'#f59e0b':isLeaf?'#22c55e':'#6366f1';
      ctx.strokeStyle=isRoot?'#fbbf24':isLeaf?'#4ade80':'#818cf8';
      ctx.lineWidth=isRoot?3:2;
      ctx.beginPath();ctx.arc(pos.x,pos.y,18,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 14px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(pos.id,pos.x,pos.y);
    }
    // title
    const nc=countNodes(sub);
    ctx.fillStyle='#e2e8f0';ctx.font='bold 12px monospace';ctx.textAlign='left';
    ctx.fillText(currentRoot==='A'?'Full Tree T':'Subtree rooted at '+currentRoot,15,canvas.height-28);
    ctx.fillStyle='#94a3b8';ctx.font='11px monospace';
    ctx.fillText('nodes: '+nc+', edges: '+(nc-1),15,canvas.height-12);
    // recursive notation
    if(currentRoot!=='A'){
      ctx.fillStyle='#a78bfa';ctx.font='11px monospace';ctx.textAlign='right';
      ctx.fillText('This subtree is itself a valid tree!',canvas.width-15,canvas.height-12);
    }
  }

  window.s4Zoom = function(id){currentRoot=id;draw();};

  const obs=new MutationObserver(()=>{
    if(document.getElementById('s4').classList.contains('active')){currentRoot='A';draw();}
  });
  obs.observe(document.getElementById('s4'),{attributes:true,attributeFilter:['class']});
  draw();
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 5: Tree ADT -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s5">
  <h2>Tree ADT</h2>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cS5" width="520" height="340" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
      <div style="display:flex;gap:0.5rem;margin-top:0.5rem;">
        <button class="btn btn-sm" onclick="s5Compute('depth')">Compute depth()</button>
        <button class="btn btn-sm" onclick="s5Compute('height')">Compute height()</button>
        <button class="btn btn-sm btn-secondary" onclick="s5Reset()">Reset</button>
      </div>
      <div id="s5Log" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.6rem;font-family:monospace;font-size:0.75rem;max-height:80px;overflow-y:auto;margin-top:0.5rem;color:#94a3b8;"></div>
    </div>
    <div>
      <h3 style="color:#38bdf8;font-size:0.9rem;">Accessor Methods</h3>
      <table style="font-size:0.82rem;width:100%;">
        <tr><th>Method</th><th>Description</th></tr>
        <tr><td><code>root()</code></td><td>Return root node</td></tr>
        <tr><td><code>parent(v)</code></td><td>Return parent of v</td></tr>
        <tr><td><code>children(v)</code></td><td>Return children of v</td></tr>
        <tr><td><code>size()</code></td><td>Number of nodes</td></tr>
      </table>
      <div class="code-block" style="margin-top:0.75rem;font-size:0.8rem;">
        <div class="code-content">
          <div class="line" id="s5Ld1">depth(v):</div>
          <div class="line" id="s5Ld2">  if isRoot(v): return 0</div>
          <div class="line" id="s5Ld3">  return 1 + depth(parent(v))</div>
          <div class="line"> </div>
          <div class="line" id="s5Lh1">height(T):</div>
          <div class="line" id="s5Lh2">  if isExternal(T): return 0</div>
          <div class="line" id="s5Lh3">  h = 0</div>
          <div class="line" id="s5Lh4">  for each child c: h = max(h, height(c))</div>
          <div class="line" id="s5Lh5">  return 1 + h</div>
        </div>
      </div>
      <div class="key-idea" style="margin-top:0.75rem;">
        <h3>depth() goes UP, height() goes DOWN</h3>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS5');
  const ctx=canvas.getContext('2d');
  const nodes=[
    {id:'A',x:260,y:45,parent:-1,depth:0,height:3},
    {id:'B',x:140,y:125,parent:0,depth:1,height:2},
    {id:'C',x:380,y:125,parent:0,depth:1,height:0},
    {id:'D',x:80,y:210,parent:1,depth:2,height:1},
    {id:'E',x:200,y:210,parent:1,depth:2,height:0},
    {id:'F',x:80,y:290,parent:3,depth:3,height:0}
  ];
  let labels=[], hlNodes=[], timer=null;

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(let i=1;i<nodes.length;i++){
      const n=nodes[i],p=nodes[n.parent];
      const hl=hlNodes.includes(i)||hlNodes.includes(n.parent);
      ctx.strokeStyle=hl?'#f59e0b':'#475569';ctx.lineWidth=hl?3:2;
      ctx.beginPath();ctx.moveTo(p.x,p.y+18);ctx.lineTo(n.x,n.y-18);ctx.stroke();
    }
    for(let i=0;i<nodes.length;i++){
      const n=nodes[i];
      const hl=hlNodes.includes(i);
      ctx.fillStyle=hl?'#f59e0b':'#6366f1';
      ctx.strokeStyle=hl?'#fbbf24':'#818cf8';ctx.lineWidth=hl?3:2;
      ctx.beginPath();ctx.arc(n.x,n.y,18,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 14px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(n.id,n.x,n.y);
    }
    // labels
    for(const lb of labels){
      const n=nodes[lb.idx];
      ctx.fillStyle=lb.color||'#f59e0b';ctx.font='bold 11px monospace';ctx.textAlign='center';
      ctx.fillText(lb.text,n.x,n.y+32);
    }
  }

  function log(msg){document.getElementById('s5Log').innerHTML+='<div>'+msg+'</div>';document.getElementById('s5Log').scrollTop=9999;}
  function clearLines(){['s5Ld1','s5Ld2','s5Ld3','s5Lh1','s5Lh2','s5Lh3','s5Lh4','s5Lh5'].forEach(id=>document.getElementById(id).classList.remove('active'));}

  window.s5Compute = function(type){
    if(timer) return;
    clearLines(); labels=[]; hlNodes=[]; document.getElementById('s5Log').innerHTML='';
    if(type==='depth'){
      // animate depth for node F (index 5): goes up F→D→B→A
      const path=[5,3,1,0];
      let step=0;
      timer=setInterval(()=>{
        if(step>=path.length){clearInterval(timer);timer=null;
          log('depth(F) = <span style="color:#22c55e;">3</span>');return;}
        const i=path[step];
        hlNodes=[i];
        if(step===0){document.getElementById('s5Ld1').classList.add('active');log('depth('+nodes[i].id+'): is root? No');}
        else{
          clearLines();
          if(i===0){document.getElementById('s5Ld2').classList.add('active');log('depth('+nodes[i].id+'): is root? Yes → return 0');}
          else{document.getElementById('s5Ld3').classList.add('active');log('depth('+nodes[i].id+'): 1 + depth('+nodes[nodes[i].parent].id+')');}
        }
        labels.push({idx:i,text:'d='+nodes[i].depth,color:'#f59e0b'});
        draw();step++;
      },900);
    } else {
      // animate height for full tree: bottom-up F→D→E→B→C→A
      const order=[5,3,4,1,2,0];
      let step=0;
      timer=setInterval(()=>{
        if(step>=order.length){clearInterval(timer);timer=null;
          log('height(A) = <span style="color:#22c55e;">3</span>');return;}
        const i=order[step];
        hlNodes=[i];
        const n=nodes[i];
        const children=nodes.filter((nd,j)=>nd.parent===i).map(nd=>nd.id);
        clearLines();
        if(children.length===0){
          document.getElementById('s5Lh2').classList.add('active');
          log('height('+n.id+'): leaf → return 0');
        } else {
          document.getElementById('s5Lh4').classList.add('active');
          log('height('+n.id+'): 1 + max(children) = '+n.height);
        }
        labels.push({idx:i,text:'h='+n.height,color:'#22c55e'});
        draw();step++;
      },900);
    }
  };

  window.s5Reset = function(){
    if(timer){clearInterval(timer);timer=null;}
    clearLines();labels=[];hlNodes=[];document.getElementById('s5Log').innerHTML='';draw();
  };

  const obs=new MutationObserver(()=>{
    if(document.getElementById('s5').classList.contains('active')){s5Reset();}
    else{if(timer){clearInterval(timer);timer=null;}}
  });
  obs.observe(document.getElementById('s5'),{attributes:true,attributeFilter:['class']});
  draw();
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 6: Depth and Height -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s6">
  <h2>Depth and Height</h2>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cS6" width="520" height="370" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
      <div id="s6Info" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.6rem;font-family:monospace;font-size:0.78rem;min-height:36px;margin-top:0.5rem;color:#94a3b8;text-align:center;">Click a node to see its depth path (↑) and height path (↓)</div>
    </div>
    <div>
      <div class="key-idea">
        <h3>Depth of a Node</h3>
        <p><strong>depth(v)</strong> = edges from root to v.<br>Root has depth 0. Goes <strong style="color:#f59e0b;">top-down ↓</strong>.</p>
      </div>
      <div class="key-idea" style="margin-top:0.75rem;">
        <h3>Height of a Node</h3>
        <p><strong>height(v)</strong> = edges on longest path from v down to a leaf.<br>Leaves have height 0. Goes <strong style="color:#22c55e;">bottom-up ↑</strong>.</p>
      </div>
      <div class="key-idea" style="margin-top:0.75rem;">
        <h3>Height of Tree</h3>
        <p>height(T) = height of root = max depth of any leaf.<br>Here: height(A) = 3 (path A → B → D → F).</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS6');
  const ctx=canvas.getContext('2d');
  const nodes=[
    {id:'A',x:260,y:40,parent:-1,depth:0,height:3},
    {id:'B',x:150,y:120,parent:0,depth:1,height:2},
    {id:'C',x:400,y:120,parent:0,depth:1,height:0},
    {id:'D',x:90,y:210,parent:1,depth:2,height:1},
    {id:'E',x:220,y:210,parent:1,depth:2,height:0},
    {id:'F',x:90,y:300,parent:3,depth:3,height:0}
  ];
  let selected=-1;

  function getPath(i){const p=[];let c=i;while(c>=0){p.unshift(c);c=nodes[c].parent;}return p;}
  function getLongestDown(i){
    const ch=nodes.map((n,j)=>n.parent===i?j:-1).filter(j=>j>=0);
    if(ch.length===0) return [i];
    let best=[];
    for(const c of ch){const sub=getLongestDown(c);if(sub.length>best.length) best=sub;}
    return [i,...best];
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const depthPath=selected>=0?getPath(selected):[];
    const heightPath=selected>=0?getLongestDown(selected):[];
    // depth level lines
    for(let d=0;d<=3;d++){
      const y=40+d*90;
      ctx.strokeStyle='#1e293b';ctx.lineWidth=1;ctx.setLineDash([4,4]);
      ctx.beginPath();ctx.moveTo(40,y);ctx.lineTo(canvas.width-10,y);ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle='#64748b';ctx.font='10px monospace';ctx.textAlign='right';
      ctx.fillText('d='+d,35,y+4);
    }
    // edges
    for(let i=1;i<nodes.length;i++){
      const n=nodes[i],p=nodes[n.parent];
      const isDepthEdge=depthPath.includes(i)&&depthPath.includes(n.parent);
      const isHeightEdge=heightPath.includes(i)&&heightPath.includes(n.parent);
      if(isDepthEdge&&isHeightEdge){
        ctx.strokeStyle='#f59e0b';ctx.lineWidth=3;
      } else if(isDepthEdge){
        ctx.strokeStyle='#f59e0b';ctx.lineWidth=3;
      } else if(isHeightEdge){
        ctx.strokeStyle='#22c55e';ctx.lineWidth=3;
      } else {
        ctx.strokeStyle='#475569';ctx.lineWidth=1.5;
      }
      ctx.beginPath();ctx.moveTo(p.x,p.y+18);ctx.lineTo(n.x,n.y-18);ctx.stroke();
    }
    // nodes
    for(let i=0;i<nodes.length;i++){
      const n=nodes[i],isSel=i===selected;
      const leaf=!nodes.some(nd=>nd.parent===i);
      ctx.fillStyle=isSel?'#f59e0b':leaf?'#22c55e':'#6366f1';
      ctx.strokeStyle=isSel?'#fbbf24':leaf?'#4ade80':'#818cf8';
      ctx.lineWidth=isSel?3:2;
      ctx.beginPath();ctx.arc(n.x,n.y,18,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 14px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(n.id,n.x,n.y);
      // labels
      ctx.font='10px monospace';ctx.textAlign='center';
      ctx.fillStyle='#f59e0b';ctx.fillText('d='+n.depth,n.x-28,n.y-8);
      ctx.fillStyle='#22c55e';ctx.fillText('h='+n.height,n.x+28,n.y+8);
    }
  }

  function updateInfo(){
    const el=document.getElementById('s6Info');
    if(selected<0){el.innerHTML='Click a node to see its depth path (↑) and height path (↓)';return;}
    const n=nodes[selected];
    const dp=getPath(selected).map(i=>nodes[i].id).join(' → ');
    const hp=getLongestDown(selected).map(i=>nodes[i].id).join(' → ');
    el.innerHTML='<span style="color:#f59e0b;">depth('+n.id+') = '+n.depth+'</span> path: '+dp+' | <span style="color:#22c55e;">height('+n.id+') = '+n.height+'</span> longest down: '+hp;
  }

  canvas.addEventListener('click',(e)=>{
    const rect=canvas.getBoundingClientRect();
    const sx=canvas.width/rect.width,sy=canvas.height/rect.height;
    const mx=(e.clientX-rect.left)*sx,my=(e.clientY-rect.top)*sy;
    selected=-1;
    for(let i=0;i<nodes.length;i++){
      const dx=mx-nodes[i].x,dy=my-nodes[i].y;
      if(dx*dx+dy*dy<400){selected=i;break;}
    }
    draw();updateInfo();
  });

  const obs=new MutationObserver(()=>{
    if(document.getElementById('s6').classList.contains('active')){selected=-1;draw();updateInfo();}
  });
  obs.observe(document.getElementById('s6'),{attributes:true,attributeFilter:['class']});
  draw();
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 7: Binary Trees -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s7">
  <h2>Binary Trees</h2>
  <p>Each node has <strong>at most 2 children</strong>: a <strong>left</strong> and a <strong>right</strong> child.</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cS7" width="520" height="320" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
      <div style="display:flex;gap:0.5rem;flex-wrap:wrap;margin-top:0.5rem;">
        <input type="number" id="s7input" placeholder="value" style="width:70px;padding:0.4rem 0.6rem;background:#1e293b;border:1px solid #475569;border-radius:6px;color:#e2e8f0;font-family:monospace;">
        <button class="btn btn-sm" onclick="s7Insert()">Insert (BST)</button>
        <button class="btn btn-sm btn-secondary" onclick="s7Reset()">Reset</button>
      </div>
      <div id="s7Stats" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.6rem;font-family:monospace;font-size:0.78rem;margin-top:0.5rem;color:#94a3b8;"></div>
    </div>
    <div>
      <h3 style="color:#38bdf8;font-size:0.9rem;">Properties of Binary Trees</h3>
      <table style="font-size:0.82rem;width:100%;" id="s7Table">
        <tr><th>Property</th><th>Formula</th><th>Current</th></tr>
        <tr><td>Max nodes at depth d</td><td>2<sup>d</sup></td><td id="s7p1">—</td></tr>
        <tr><td>Max total nodes</td><td>2<sup>h+1</sup> − 1</td><td id="s7p2">—</td></tr>
        <tr><td>Min height (n nodes)</td><td>⌊log₂ n⌋</td><td id="s7p3">—</td></tr>
        <tr><td>Actual height</td><td>—</td><td id="s7p4">—</td></tr>
      </table>
      <div class="key-idea" style="margin-top:0.75rem;">
        <h3>Why Binary?</h3>
        <p>Binary trees enable <strong>efficient searching</strong>, <strong>sorting</strong>, and <strong>expression evaluation</strong>. The most common tree in CS.</p>
      </div>
      <div class="warning" style="margin-top:0.75rem;">
        <h3>Left vs Right Matters!</h3>
        <p>A node with one child — it matters whether it's the left or right child. They are structurally different.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS7');
  const ctx=canvas.getContext('2d');
  let root=null;

  function makeNode(val){return{val,left:null,right:null};}
  function insert(node,val){
    if(!node) return makeNode(val);
    if(val<node.val) node.left=insert(node.left,val);
    else if(val>node.val) node.right=insert(node.right,val);
    return node;
  }
  function getHeight(node){if(!node)return -1;return 1+Math.max(getHeight(node.left),getHeight(node.right));}
  function countNodes(node){if(!node)return 0;return 1+countNodes(node.left)+countNodes(node.right);}
  function getLeaves(node){if(!node)return 0;if(!node.left&&!node.right)return 1;return getLeaves(node.left)+getLeaves(node.right);}

  function drawTree(node,x,y,spread){
    if(!node) return;
    // edges
    if(node.left){
      ctx.strokeStyle='#475569';ctx.lineWidth=2;
      ctx.beginPath();ctx.moveTo(x,y+16);ctx.lineTo(x-spread,y+70-16);ctx.stroke();
      drawTree(node.left,x-spread,y+70,spread*0.52);
    }
    if(node.right){
      ctx.strokeStyle='#475569';ctx.lineWidth=2;
      ctx.beginPath();ctx.moveTo(x,y+16);ctx.lineTo(x+spread,y+70-16);ctx.stroke();
      drawTree(node.right,x+spread,y+70,spread*0.52);
    }
    // node
    const isLeaf=!node.left&&!node.right;
    ctx.fillStyle=isLeaf?'#22c55e':'#6366f1';
    ctx.strokeStyle=isLeaf?'#4ade80':'#818cf8';ctx.lineWidth=2;
    ctx.beginPath();ctx.arc(x,y,16,0,Math.PI*2);ctx.fill();ctx.stroke();
    ctx.fillStyle='#fff';ctx.font='bold 12px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
    ctx.fillText(node.val,x,y);
    // left/right labels at depth 1
    if(y<80){
      if(node.left){ctx.fillStyle='#94a3b8';ctx.font='9px monospace';ctx.textAlign='center';ctx.fillText('L',x-spread,y+70+26);}
      if(node.right){ctx.fillStyle='#94a3b8';ctx.font='9px monospace';ctx.textAlign='center';ctx.fillText('R',x+spread,y+70+26);}
    }
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(!root){
      ctx.fillStyle='#64748b';ctx.font='13px monospace';ctx.textAlign='center';
      ctx.fillText('Insert values to build a binary tree',canvas.width/2,canvas.height/2);
      return;
    }
    drawTree(root,canvas.width/2,40,130);
  }

  function updateStats(){
    const n=countNodes(root),h=getHeight(root),leaves=getLeaves(root);
    document.getElementById('s7p1').textContent=h>=0?Math.pow(2,h):'—';
    document.getElementById('s7p2').textContent=h>=0?(Math.pow(2,h+1)-1):'—';
    document.getElementById('s7p3').textContent=n>0?Math.floor(Math.log2(n)):'—';
    document.getElementById('s7p4').textContent=h>=0?h:'—';
    document.getElementById('s7Stats').innerHTML='nodes: '+n+', leaves: '+leaves+', height: '+(h>=0?h:'—')+', internal: '+(n-leaves);
  }

  window.s7Insert = function(){
    const val=parseInt(document.getElementById('s7input').value);
    if(isNaN(val)) return;
    root=insert(root,val);
    draw();updateStats();
    document.getElementById('s7input').value='';
  };

  window.s7Reset = function(){
    root=null;
    // preload a sample tree
    [8,3,10,1,6,14].forEach(v=>root=insert(root,v));
    draw();updateStats();
  };

  const obs=new MutationObserver(()=>{
    if(document.getElementById('s7').classList.contains('active')) s7Reset();
  });
  obs.observe(document.getElementById('s7'),{attributes:true,attributeFilter:['class']});
  s7Reset();
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 8: Full vs Complete vs Perfect -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s8">
  <h2>Full vs Complete vs Perfect Binary Trees</h2>
  <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:1rem;margin-top:1rem;">
    <div style="background:rgba(0,0,0,0.2);border-radius:10px;padding:1rem;text-align:center;">
      <h3 style="color:#38bdf8;font-size:0.9rem;">Full Binary Tree</h3>
      <canvas id="cS8a" width="200" height="180" style="background:rgba(0,0,0,0.15);border-radius:8px;margin:0.5rem auto;display:block;"></canvas>
      <p style="font-size:0.78rem;color:#94a3b8;">Every node has <strong>0 or 2</strong> children. No single-child nodes.</p>
    </div>
    <div style="background:rgba(0,0,0,0.2);border-radius:10px;padding:1rem;text-align:center;">
      <h3 style="color:#f59e0b;font-size:0.9rem;">Complete Binary Tree</h3>
      <canvas id="cS8b" width="200" height="180" style="background:rgba(0,0,0,0.15);border-radius:8px;margin:0.5rem auto;display:block;"></canvas>
      <p style="font-size:0.78rem;color:#94a3b8;">All levels full except last; last level filled <strong>left → right</strong>. Used in heaps!</p>
    </div>
    <div style="background:rgba(0,0,0,0.2);border-radius:10px;padding:1rem;text-align:center;">
      <h3 style="color:#22c55e;font-size:0.9rem;">Perfect Binary Tree</h3>
      <canvas id="cS8c" width="200" height="180" style="background:rgba(0,0,0,0.15);border-radius:8px;margin:0.5rem auto;display:block;"></canvas>
      <p style="font-size:0.78rem;color:#94a3b8;">All internals have 2 children; all leaves at <strong>same depth</strong>. Both full AND complete.</p>
    </div>
  </div>
  <table style="font-size:0.82rem;margin:1rem auto;">
    <tr><th>Type</th><th>Rule</th><th>Relationship</th></tr>
    <tr><td>Full</td><td>Every node: 0 or 2 children</td><td>Not necessarily complete</td></tr>
    <tr><td>Complete</td><td>All levels full; last left-filled</td><td>Used in heaps!</td></tr>
    <tr style="background:rgba(34,197,94,0.1);"><td><strong>Perfect</strong></td><td>All leaves same depth, all internals have 2</td><td>Both full AND complete</td></tr>
  </table>
  <div class="key-idea" style="text-align:center;">
    <h3>Perfect binary tree: exactly 2<sup>h+1</sup> − 1 nodes</h3>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  function drawSmallTree(canvasId, nodes){
    const canvas=document.getElementById(canvasId);
    const ctx=canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // edges
    for(let i=1;i<nodes.length;i++){
      const n=nodes[i],p=nodes[n.pi];
      ctx.strokeStyle='#475569';ctx.lineWidth=1.5;
      ctx.beginPath();ctx.moveTo(p.x,p.y+12);ctx.lineTo(n.x,n.y-12);ctx.stroke();
    }
    // nodes
    for(let i=0;i<nodes.length;i++){
      const n=nodes[i];
      const isLeaf=!nodes.some(c=>c.pi===i);
      ctx.fillStyle=isLeaf?'#22c55e':'#6366f1';
      ctx.strokeStyle=isLeaf?'#4ade80':'#818cf8';ctx.lineWidth=1.5;
      ctx.beginPath();ctx.arc(n.x,n.y,12,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 10px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(n.id,n.x,n.y);
    }
  }
  // Full: A has B,C; B has D,E; C is leaf
  const full=[
    {id:'A',x:100,y:25,pi:-1},{id:'B',x:55,y:80,pi:0},{id:'C',x:145,y:80,pi:0},
    {id:'D',x:30,y:140,pi:1},{id:'E',x:80,y:140,pi:1}
  ];
  // Complete: A has B,C; B has D,E; C has F (left only)
  const complete=[
    {id:'A',x:100,y:25,pi:-1},{id:'B',x:55,y:80,pi:0},{id:'C',x:145,y:80,pi:0},
    {id:'D',x:30,y:140,pi:1},{id:'E',x:80,y:140,pi:1},{id:'F',x:120,y:140,pi:2}
  ];
  // Perfect: A has B,C; B has D,E; C has F,G
  const perfect=[
    {id:'A',x:100,y:25,pi:-1},{id:'B',x:55,y:80,pi:0},{id:'C',x:145,y:80,pi:0},
    {id:'D',x:30,y:140,pi:1},{id:'E',x:80,y:140,pi:1},{id:'F',x:120,y:140,pi:2},{id:'G',x:170,y:140,pi:2}
  ];
  function drawAll(){drawSmallTree('cS8a',full);drawSmallTree('cS8b',complete);drawSmallTree('cS8c',perfect);}
  const obs=new MutationObserver(()=>{if(document.getElementById('s8').classList.contains('active'))drawAll();});
  obs.observe(document.getElementById('s8'),{attributes:true,attributeFilter:['class']});
  drawAll();
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 9: Traversals Overview -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s9">
  <h2>Binary Tree Traversals</h2>
  <p>Traversal = visiting every node exactly once. Choose the order based on your goal.</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cS9" width="520" height="320" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
      <div style="display:flex;gap:0.5rem;flex-wrap:wrap;margin-top:0.5rem;">
        <button class="btn btn-sm" onclick="s9Run('pre')" id="s9Bpre">Preorder</button>
        <button class="btn btn-sm btn-secondary" onclick="s9Run('in')" id="s9Bin">Inorder</button>
        <button class="btn btn-sm btn-secondary" onclick="s9Run('post')" id="s9Bpost">Postorder</button>
        <button class="btn btn-sm btn-secondary" onclick="s9Run('level')" id="s9Blevel">Level-order</button>
        <button class="btn btn-sm btn-secondary" onclick="s9Reset()">Reset</button>
      </div>
    </div>
    <div>
      <table style="font-size:0.82rem;width:100%;">
        <tr><th>Traversal</th><th>Order</th><th>Mnemonic</th><th>Use For</th></tr>
        <tr><td>Preorder</td><td>Node, L, R</td><td><strong>N</strong>LR</td><td>Copy/serialize</td></tr>
        <tr><td>Inorder</td><td>L, Node, R</td><td>L<strong>N</strong>R</td><td>Sorted output (BST)</td></tr>
        <tr><td>Postorder</td><td>L, R, Node</td><td>LR<strong>N</strong></td><td>Delete / eval expr</td></tr>
        <tr><td>Level-order</td><td>Top→bottom, L→R</td><td>BFS</td><td>Level-by-level</td></tr>
      </table>
      <div id="s9Result" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.6rem;font-family:monospace;font-size:0.85rem;min-height:36px;margin-top:0.75rem;color:#f59e0b;text-align:center;"></div>
      <div class="analogy" style="margin-top:0.75rem;">
        <h3>The "N" Position</h3>
        <p>The mnemonic tells you <strong>when you visit the node</strong>: before children (pre), between (in), or after (post).</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS9');
  const ctx=canvas.getContext('2d');
  // Tree: A(B(D,E),C(_,F))
  const tree={val:'A',l:{val:'B',l:{val:'D',l:null,r:null},r:{val:'E',l:null,r:null}},r:{val:'C',l:null,r:{val:'F',l:null,r:null}}};
  const pos={'A':{x:260,y:45},'B':{x:140,y:130},'C':{x:380,y:130},'D':{x:70,y:220},'E':{x:210,y:220},'F':{x:420,y:220}};
  let visited=[], visitIdx=0, timer=null, order=[];

  function preorder(n){if(!n)return;order.push(n.val);preorder(n.l);preorder(n.r);}
  function inorder(n){if(!n)return;inorder(n.l);order.push(n.val);inorder(n.r);}
  function postorder(n){if(!n)return;postorder(n.l);postorder(n.r);order.push(n.val);}
  function levelorder(n){
    const q=[n];
    while(q.length){const c=q.shift();if(!c)continue;order.push(c.val);q.push(c.l);q.push(c.r);}
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // edges
    const edges=[['A','B'],['A','C'],['B','D'],['B','E'],['C','F']];
    for(const[a,b] of edges){
      const pa=pos[a],pb=pos[b];
      ctx.strokeStyle='#475569';ctx.lineWidth=2;
      ctx.beginPath();ctx.moveTo(pa.x,pa.y+18);ctx.lineTo(pb.x,pb.y-18);ctx.stroke();
    }
    // nodes
    for(const[id,p] of Object.entries(pos)){
      const vi=visited.indexOf(id);
      const isCurrent=vi===visited.length-1&&visited.length>0;
      const isVisited=vi>=0;
      ctx.fillStyle=isCurrent?'#f59e0b':isVisited?'#22c55e':'#6366f1';
      ctx.strokeStyle=isCurrent?'#fbbf24':isVisited?'#4ade80':'#818cf8';
      ctx.lineWidth=isCurrent?3:2;
      ctx.beginPath();ctx.arc(p.x,p.y,18,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 15px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(id,p.x,p.y);
      // visit number
      if(isVisited){
        ctx.fillStyle='#f59e0b';ctx.font='bold 11px monospace';ctx.textAlign='center';
        ctx.fillText('①②③④⑤⑥'[vi],p.x,p.y+30);
      }
    }
    // result so far
    document.getElementById('s9Result').innerHTML=visited.length?'Visit order: <strong>'+visited.join('  ')+'</strong>'+(visited.length<6?' …':'  ✓'):'Select a traversal to animate';
  }

  function animate(){
    if(visitIdx>=order.length){clearInterval(timer);timer=null;return;}
    visited.push(order[visitIdx]);visitIdx++;draw();
  }

  window.s9Run = function(type){
    if(timer){clearInterval(timer);timer=null;}
    visited=[];visitIdx=0;order=[];
    if(type==='pre') preorder(tree);
    else if(type==='in') inorder(tree);
    else if(type==='post') postorder(tree);
    else levelorder(tree);
    ['s9Bpre','s9Bin','s9Bpost','s9Blevel'].forEach(id=>document.getElementById(id).className='btn btn-sm btn-secondary');
    document.getElementById('s9B'+type).className='btn btn-sm';
    draw();
    timer=setInterval(animate,800);
  };
  window.s9Reset = function(){
    if(timer){clearInterval(timer);timer=null;}
    visited=[];visitIdx=0;order=[];
    ['s9Bpre','s9Bin','s9Bpost','s9Blevel'].forEach(id=>document.getElementById(id).className='btn btn-sm btn-secondary');
    document.getElementById('s9Bpre').className='btn btn-sm';
    draw();
  };

  const obs=new MutationObserver(()=>{
    if(document.getElementById('s9').classList.contains('active')) s9Reset();
    else{if(timer){clearInterval(timer);timer=null;}}
  });
  obs.observe(document.getElementById('s9'),{attributes:true,attributeFilter:['class']});
  draw();
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 10: Preorder Traversal -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s10">
  <h2>Preorder Traversal (NLR)</h2>
  <p><strong>Visit node FIRST</strong>, then recurse left, then recurse right.</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cS10" width="520" height="290" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
      <div style="display:flex;gap:0.5rem;margin-top:0.5rem;">
        <button class="btn btn-sm" onclick="s10Step()">Step</button>
        <button class="btn btn-sm" onclick="s10Auto()">Auto Play</button>
        <button class="btn btn-sm btn-secondary" onclick="s10Reset()">Reset</button>
      </div>
      <div id="s10Result" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.5rem;font-family:monospace;font-size:0.85rem;margin-top:0.5rem;color:#f59e0b;text-align:center;min-height:30px;"></div>
    </div>
    <div>
      <div class="code-block" style="font-size:0.82rem;">
        <div class="code-content">
          <div class="line" id="s10L1">preorder(node):</div>
          <div class="line" id="s10L2">  if node == null: return</div>
          <div class="line" id="s10L3">  <span style="color:#fbbf24;">visit(node)</span>         // FIRST</div>
          <div class="line" id="s10L4">  preorder(node.left)</div>
          <div class="line" id="s10L5">  preorder(node.right)</div>
        </div>
      </div>
      <div class="key-idea" style="margin-top:0.75rem;">
        <h3>Use Cases</h3>
        <ul style="font-size:0.85rem;">
          <li>Create a <strong>copy</strong> of the tree</li>
          <li><strong>Serialize</strong> a tree to string</li>
          <li>Print a <strong>prefix expression</strong></li>
        </ul>
      </div>
      <div id="s10Log" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.5rem;font-family:monospace;font-size:0.72rem;max-height:80px;overflow-y:auto;margin-top:0.5rem;color:#94a3b8;"></div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS10');
  const ctx=canvas.getContext('2d');
  const pos={'A':{x:260,y:40},'B':{x:140,y:120},'C':{x:380,y:120},'D':{x:70,y:210},'E':{x:210,y:210},'F':{x:420,y:210}};
  const edges=[['A','B'],['A','C'],['B','D'],['B','E'],['C','F']];
  // Preorder steps with code line highlights and call stack info
  const steps=[
    {visit:'A',line:'s10L3',msg:'visit(A) — process root first'},
    {visit:null,line:'s10L4',msg:'preorder(A.left) → go to B'},
    {visit:'B',line:'s10L3',msg:'visit(B) — process before children'},
    {visit:null,line:'s10L4',msg:'preorder(B.left) → go to D'},
    {visit:'D',line:'s10L3',msg:'visit(D) — leaf, no children'},
    {visit:null,line:'s10L5',msg:'preorder(B.right) → go to E'},
    {visit:'E',line:'s10L3',msg:'visit(E) — leaf'},
    {visit:null,line:'s10L5',msg:'preorder(A.right) → go to C'},
    {visit:'C',line:'s10L3',msg:'visit(C) — left is null'},
    {visit:null,line:'s10L5',msg:'preorder(C.right) → go to F'},
    {visit:'F',line:'s10L3',msg:'visit(F) — leaf, done!'}
  ];
  let visited=[], stepIdx=0, timer=null;

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(const[a,b] of edges){
      ctx.strokeStyle='#475569';ctx.lineWidth=2;
      ctx.beginPath();ctx.moveTo(pos[a].x,pos[a].y+18);ctx.lineTo(pos[b].x,pos[b].y-18);ctx.stroke();
    }
    for(const[id,p] of Object.entries(pos)){
      const vi=visited.indexOf(id);
      const isCurr=vi===visited.length-1&&visited.length>0;
      ctx.fillStyle=isCurr?'#f59e0b':vi>=0?'#22c55e':'#6366f1';
      ctx.strokeStyle=isCurr?'#fbbf24':vi>=0?'#4ade80':'#818cf8';ctx.lineWidth=isCurr?3:2;
      ctx.beginPath();ctx.arc(p.x,p.y,18,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 14px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(id,p.x,p.y);
      if(vi>=0){ctx.fillStyle='#f59e0b';ctx.font='bold 11px monospace';ctx.fillText('①②③④⑤⑥'[vi],p.x,p.y+30);}
    }
    document.getElementById('s10Result').innerHTML=visited.length?'<strong>'+visited.join(' → ')+'</strong>'+(visited.length>=6?' ✓':''):'Press Step to begin';
  }
  function hlLine(id){['s10L1','s10L2','s10L3','s10L4','s10L5'].forEach(x=>document.getElementById(x).classList.remove('active'));if(id)document.getElementById(id).classList.add('active');}
  function log(m){document.getElementById('s10Log').innerHTML+='<div>'+m+'</div>';document.getElementById('s10Log').scrollTop=9999;}

  window.s10Step = function(){
    if(stepIdx>=steps.length) return;
    const s=steps[stepIdx];
    hlLine(s.line);log(s.msg);
    if(s.visit) visited.push(s.visit);
    draw();stepIdx++;
  };
  window.s10Auto = function(){if(timer)return;timer=setInterval(()=>{if(stepIdx>=steps.length){clearInterval(timer);timer=null;return;}s10Step();},800);};
  window.s10Reset = function(){if(timer){clearInterval(timer);timer=null;}visited=[];stepIdx=0;hlLine(null);document.getElementById('s10Log').innerHTML='';draw();};

  const obs=new MutationObserver(()=>{
    if(document.getElementById('s10').classList.contains('active')) s10Reset();
    else{if(timer){clearInterval(timer);timer=null;}}
  });
  obs.observe(document.getElementById('s10'),{attributes:true,attributeFilter:['class']});
  draw();
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 11: Inorder Traversal -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s11">
  <h2>Inorder Traversal (LNR)</h2>
  <p>Recurse left, <strong>visit node IN THE MIDDLE</strong>, then recurse right.</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cS11" width="520" height="290" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
      <div style="display:flex;gap:0.5rem;margin-top:0.5rem;">
        <button class="btn btn-sm" onclick="s11Step()">Step</button>
        <button class="btn btn-sm" onclick="s11Auto()">Auto Play</button>
        <button class="btn btn-sm btn-secondary" onclick="s11Reset()">Reset</button>
      </div>
      <div id="s11Result" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.5rem;font-family:monospace;font-size:0.85rem;margin-top:0.5rem;color:#f59e0b;text-align:center;min-height:30px;"></div>
    </div>
    <div>
      <div class="code-block" style="font-size:0.82rem;">
        <div class="code-content">
          <div class="line" id="s11L1">inorder(node):</div>
          <div class="line" id="s11L2">  if node == null: return</div>
          <div class="line" id="s11L3">  inorder(node.left)</div>
          <div class="line" id="s11L4">  <span style="color:#fbbf24;">visit(node)</span>         // MIDDLE</div>
          <div class="line" id="s11L5">  inorder(node.right)</div>
        </div>
      </div>
      <div class="key-idea" style="margin-top:0.75rem;">
        <h3>Sorted Output from BST!</h3>
        <p>Inorder traversal of a BST visits nodes in <strong>ascending sorted order</strong>.</p>
      </div>
      <div style="margin-top:0.75rem;">
        <h3 style="color:#38bdf8;font-size:0.85rem;">BST Example: inorder gives sorted output</h3>
        <canvas id="cS11bst" width="260" height="130" style="background:rgba(0,0,0,0.15);border-radius:8px;"></canvas>
      </div>
      <div id="s11Log" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.5rem;font-family:monospace;font-size:0.72rem;max-height:60px;overflow-y:auto;margin-top:0.5rem;color:#94a3b8;"></div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS11');
  const ctx=canvas.getContext('2d');
  const pos={'A':{x:260,y:40},'B':{x:140,y:120},'C':{x:380,y:120},'D':{x:70,y:210},'E':{x:210,y:210},'F':{x:420,y:210}};
  const edges=[['A','B'],['A','C'],['B','D'],['B','E'],['C','F']];
  const steps=[
    {visit:null,line:'s11L3',msg:'inorder(A.left) → go to B'},
    {visit:null,line:'s11L3',msg:'inorder(B.left) → go to D'},
    {visit:'D',line:'s11L4',msg:'visit(D) — left was null, visit now'},
    {visit:'B',line:'s11L4',msg:'visit(B) — left done, visit now'},
    {visit:null,line:'s11L5',msg:'inorder(B.right) → go to E'},
    {visit:'E',line:'s11L4',msg:'visit(E) — leaf'},
    {visit:'A',line:'s11L4',msg:'visit(A) — left subtree done'},
    {visit:null,line:'s11L5',msg:'inorder(A.right) → go to C'},
    {visit:'C',line:'s11L4',msg:'visit(C) — left is null'},
    {visit:null,line:'s11L5',msg:'inorder(C.right) → go to F'},
    {visit:'F',line:'s11L4',msg:'visit(F) — leaf, done!'}
  ];
  let visited=[],stepIdx=0,timer=null;

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(const[a,b] of edges){ctx.strokeStyle='#475569';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(pos[a].x,pos[a].y+18);ctx.lineTo(pos[b].x,pos[b].y-18);ctx.stroke();}
    for(const[id,p] of Object.entries(pos)){
      const vi=visited.indexOf(id);const isCurr=vi===visited.length-1&&visited.length>0;
      ctx.fillStyle=isCurr?'#f59e0b':vi>=0?'#22c55e':'#6366f1';
      ctx.strokeStyle=isCurr?'#fbbf24':vi>=0?'#4ade80':'#818cf8';ctx.lineWidth=isCurr?3:2;
      ctx.beginPath();ctx.arc(p.x,p.y,18,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 14px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(id,p.x,p.y);
      if(vi>=0){ctx.fillStyle='#f59e0b';ctx.font='bold 11px monospace';ctx.fillText('①②③④⑤⑥'[vi],p.x,p.y+30);}
    }
    document.getElementById('s11Result').innerHTML=visited.length?'<strong>'+visited.join(' → ')+'</strong>'+(visited.length>=6?' ✓':''):'Press Step to begin';
  }
  function hlLine(id){['s11L1','s11L2','s11L3','s11L4','s11L5'].forEach(x=>document.getElementById(x).classList.remove('active'));if(id)document.getElementById(id).classList.add('active');}
  function log(m){document.getElementById('s11Log').innerHTML+='<div>'+m+'</div>';document.getElementById('s11Log').scrollTop=9999;}

  window.s11Step = function(){if(stepIdx>=steps.length)return;const s=steps[stepIdx];hlLine(s.line);log(s.msg);if(s.visit)visited.push(s.visit);draw();stepIdx++;};
  window.s11Auto = function(){if(timer)return;timer=setInterval(()=>{if(stepIdx>=steps.length){clearInterval(timer);timer=null;return;}s11Step();},800);};
  window.s11Reset = function(){if(timer){clearInterval(timer);timer=null;}visited=[];stepIdx=0;hlLine(null);document.getElementById('s11Log').innerHTML='';draw();};

  // BST mini demo
  const bctx=document.getElementById('cS11bst').getContext('2d');
  function drawBST(){
    bctx.clearRect(0,0,260,130);
    const bpos={8:{x:130,y:22},3:{x:65,y:60},10:{x:195,y:60},1:{x:35,y:100},6:{x:95,y:100}};
    const bedges=[[8,3],[8,10],[3,1],[3,6]];
    for(const[a,b] of bedges){bctx.strokeStyle='#475569';bctx.lineWidth=1.5;bctx.beginPath();bctx.moveTo(bpos[a].x,bpos[a].y+10);bctx.lineTo(bpos[b].x,bpos[b].y-10);bctx.stroke();}
    for(const[v,p] of Object.entries(bpos)){
      bctx.fillStyle='#6366f1';bctx.strokeStyle='#818cf8';bctx.lineWidth=1.5;
      bctx.beginPath();bctx.arc(p.x,p.y,11,0,Math.PI*2);bctx.fill();bctx.stroke();
      bctx.fillStyle='#fff';bctx.font='bold 10px monospace';bctx.textAlign='center';bctx.textBaseline='middle';
      bctx.fillText(v,p.x,p.y);
    }
    bctx.fillStyle='#22c55e';bctx.font='bold 11px monospace';bctx.textAlign='center';
    bctx.fillText('Inorder: 1, 3, 6, 8, 10  ✓ sorted!',130,125);
  }

  const obs=new MutationObserver(()=>{
    if(document.getElementById('s11').classList.contains('active')){s11Reset();drawBST();}
    else{if(timer){clearInterval(timer);timer=null;}}
  });
  obs.observe(document.getElementById('s11'),{attributes:true,attributeFilter:['class']});
  draw();drawBST();
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 12: Postorder Traversal -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s12">
  <h2>Postorder Traversal (LRN)</h2>
  <p>Recurse left, recurse right, <strong>visit node LAST</strong>.</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cS12" width="520" height="290" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
      <div style="display:flex;gap:0.5rem;margin-top:0.5rem;">
        <button class="btn btn-sm" onclick="s12Step()">Step</button>
        <button class="btn btn-sm" onclick="s12Auto()">Auto Play</button>
        <button class="btn btn-sm btn-secondary" onclick="s12Reset()">Reset</button>
      </div>
      <div id="s12Result" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.5rem;font-family:monospace;font-size:0.85rem;margin-top:0.5rem;color:#f59e0b;text-align:center;min-height:30px;"></div>
    </div>
    <div>
      <div class="code-block" style="font-size:0.82rem;">
        <div class="code-content">
          <div class="line" id="s12L1">postorder(node):</div>
          <div class="line" id="s12L2">  if node == null: return</div>
          <div class="line" id="s12L3">  postorder(node.left)</div>
          <div class="line" id="s12L4">  postorder(node.right)</div>
          <div class="line" id="s12L5">  <span style="color:#fbbf24;">visit(node)</span>         // LAST</div>
        </div>
      </div>
      <div class="key-idea" style="margin-top:0.75rem;">
        <h3>Use Cases</h3>
        <ul style="font-size:0.85rem;">
          <li><strong>Delete/free</strong> a tree (children before parent)</li>
          <li><strong>Evaluate expression trees</strong></li>
          <li>Calculate <strong>directory sizes</strong></li>
        </ul>
      </div>
      <div class="warning" style="margin-top:0.75rem;">
        <h3>Root is always visited LAST</h3>
        <p>Must finish all descendants before processing a node. Think: "clean up children before yourself."</p>
      </div>
      <div id="s12Log" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.5rem;font-family:monospace;font-size:0.72rem;max-height:60px;overflow-y:auto;margin-top:0.5rem;color:#94a3b8;"></div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS12');
  const ctx=canvas.getContext('2d');
  const pos={'A':{x:260,y:40},'B':{x:140,y:120},'C':{x:380,y:120},'D':{x:70,y:210},'E':{x:210,y:210},'F':{x:420,y:210}};
  const edges=[['A','B'],['A','C'],['B','D'],['B','E'],['C','F']];
  // Postorder: D E B F C A
  const steps=[
    {visit:null,line:'s12L3',msg:'postorder(A.left) → go to B'},
    {visit:null,line:'s12L3',msg:'postorder(B.left) → go to D'},
    {visit:'D',line:'s12L5',msg:'visit(D) — leaf, both children null'},
    {visit:null,line:'s12L4',msg:'postorder(B.right) → go to E'},
    {visit:'E',line:'s12L5',msg:'visit(E) — leaf'},
    {visit:'B',line:'s12L5',msg:'visit(B) — both children done'},
    {visit:null,line:'s12L4',msg:'postorder(A.right) → go to C'},
    {visit:null,line:'s12L4',msg:'postorder(C.right) → go to F'},
    {visit:'F',line:'s12L5',msg:'visit(F) — leaf'},
    {visit:'C',line:'s12L5',msg:'visit(C) — children done'},
    {visit:'A',line:'s12L5',msg:'visit(A) — root visited LAST!'}
  ];
  let visited=[],stepIdx=0,timer=null;

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(const[a,b] of edges){ctx.strokeStyle='#475569';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(pos[a].x,pos[a].y+18);ctx.lineTo(pos[b].x,pos[b].y-18);ctx.stroke();}
    for(const[id,p] of Object.entries(pos)){
      const vi=visited.indexOf(id);const isCurr=vi===visited.length-1&&visited.length>0;
      ctx.fillStyle=isCurr?'#f59e0b':vi>=0?'#22c55e':'#6366f1';
      ctx.strokeStyle=isCurr?'#fbbf24':vi>=0?'#4ade80':'#818cf8';ctx.lineWidth=isCurr?3:2;
      ctx.beginPath();ctx.arc(p.x,p.y,18,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 14px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(id,p.x,p.y);
      if(vi>=0){ctx.fillStyle='#f59e0b';ctx.font='bold 11px monospace';ctx.fillText('①②③④⑤⑥'[vi],p.x,p.y+30);}
    }
    document.getElementById('s12Result').innerHTML=visited.length?'<strong>'+visited.join(' → ')+'</strong>'+(visited.length>=6?' ✓':''):'Press Step to begin';
  }
  function hlLine(id){['s12L1','s12L2','s12L3','s12L4','s12L5'].forEach(x=>document.getElementById(x).classList.remove('active'));if(id)document.getElementById(id).classList.add('active');}
  function log(m){document.getElementById('s12Log').innerHTML+='<div>'+m+'</div>';document.getElementById('s12Log').scrollTop=9999;}

  window.s12Step = function(){if(stepIdx>=steps.length)return;const s=steps[stepIdx];hlLine(s.line);log(s.msg);if(s.visit)visited.push(s.visit);draw();stepIdx++;};
  window.s12Auto = function(){if(timer)return;timer=setInterval(()=>{if(stepIdx>=steps.length){clearInterval(timer);timer=null;return;}s12Step();},800);};
  window.s12Reset = function(){if(timer){clearInterval(timer);timer=null;}visited=[];stepIdx=0;hlLine(null);document.getElementById('s12Log').innerHTML='';draw();};

  const obs=new MutationObserver(()=>{
    if(document.getElementById('s12').classList.contains('active')) s12Reset();
    else{if(timer){clearInterval(timer);timer=null;}}
  });
  obs.observe(document.getElementById('s12'),{attributes:true,attributeFilter:['class']});
  draw();
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 13: Level-Order Traversal -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s13">
  <h2>Level-Order Traversal (BFS)</h2>
  <p>Visit nodes <strong>level by level</strong>, left to right. Uses a <strong>queue</strong>.</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cS13" width="520" height="290" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
      <div style="display:flex;gap:0.5rem;margin-top:0.5rem;">
        <button class="btn btn-sm" onclick="s13Step()">Step</button>
        <button class="btn btn-sm" onclick="s13Auto()">Auto Play</button>
        <button class="btn btn-sm btn-secondary" onclick="s13Reset()">Reset</button>
      </div>
      <div id="s13Result" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.5rem;font-family:monospace;font-size:0.85rem;margin-top:0.5rem;color:#f59e0b;text-align:center;min-height:30px;"></div>
    </div>
    <div>
      <div class="code-block" style="font-size:0.82rem;">
        <div class="code-content">
          <div class="line" id="s13L1">levelOrder(root):</div>
          <div class="line" id="s13L2">  queue Q</div>
          <div class="line" id="s13L3">  Q.enqueue(root)</div>
          <div class="line" id="s13L4">  while Q not empty:</div>
          <div class="line" id="s13L5">    node = Q.dequeue()</div>
          <div class="line" id="s13L6">    <span style="color:#fbbf24;">visit(node)</span></div>
          <div class="line" id="s13L7">    enqueue children</div>
        </div>
      </div>
      <div style="margin-top:0.75rem;">
        <h3 style="color:#38bdf8;font-size:0.85rem;">Queue State:</h3>
        <div id="s13Queue" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.5rem;font-family:monospace;font-size:0.85rem;color:#a78bfa;min-height:30px;text-align:center;">Q = [ ]</div>
      </div>
      <div class="key-idea" style="margin-top:0.75rem;">
        <h3>Not Recursive!</h3>
        <p>The only standard traversal using a <strong>queue</strong> instead of recursion/stack.</p>
      </div>
      <div id="s13Log" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.5rem;font-family:monospace;font-size:0.72rem;max-height:60px;overflow-y:auto;margin-top:0.5rem;color:#94a3b8;"></div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS13');
  const ctx=canvas.getContext('2d');
  const pos={'A':{x:260,y:40},'B':{x:140,y:120},'C':{x:380,y:120},'D':{x:70,y:210},'E':{x:210,y:210},'F':{x:420,y:210}};
  const edgesArr=[['A','B'],['A','C'],['B','D'],['B','E'],['C','F']];
  const childrenMap={'A':['B','C'],'B':['D','E'],'C':['F'],'D':[],'E':[],'F':[]};
  let visited=[], queue=[], stepIdx=0, timer=null;

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // level lines
    [40,120,210].forEach((y,i)=>{
      ctx.strokeStyle='#1e293b';ctx.lineWidth=1;ctx.setLineDash([3,3]);
      ctx.beginPath();ctx.moveTo(20,y);ctx.lineTo(500,y);ctx.stroke();ctx.setLineDash([]);
      ctx.fillStyle='#64748b';ctx.font='10px monospace';ctx.textAlign='right';
      ctx.fillText('Lv '+i,18,y+4);
    });
    for(const[a,b] of edgesArr){ctx.strokeStyle='#475569';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(pos[a].x,pos[a].y+18);ctx.lineTo(pos[b].x,pos[b].y-18);ctx.stroke();}
    for(const[id,p] of Object.entries(pos)){
      const vi=visited.indexOf(id);const isCurr=vi===visited.length-1&&visited.length>0;
      const inQ=queue.includes(id);
      ctx.fillStyle=isCurr?'#f59e0b':vi>=0?'#22c55e':inQ?'#a78bfa':'#6366f1';
      ctx.strokeStyle=isCurr?'#fbbf24':vi>=0?'#4ade80':inQ?'#c4b5fd':'#818cf8';ctx.lineWidth=isCurr?3:2;
      ctx.beginPath();ctx.arc(p.x,p.y,18,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 14px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(id,p.x,p.y);
      if(vi>=0){ctx.fillStyle='#f59e0b';ctx.font='bold 11px monospace';ctx.fillText('①②③④⑤⑥'[vi],p.x,p.y+30);}
    }
    document.getElementById('s13Result').innerHTML=visited.length?'<strong>'+visited.join(' → ')+'</strong>'+(visited.length>=6?' ✓':''):'Press Step to begin';
    document.getElementById('s13Queue').innerHTML='Q = [ '+queue.map(id=>'<span style="color:#a78bfa;">'+id+'</span>').join(', ')+' ]';
  }
  function hlLine(id){['s13L1','s13L2','s13L3','s13L4','s13L5','s13L6','s13L7'].forEach(x=>document.getElementById(x).classList.remove('active'));if(id)document.getElementById(id).classList.add('active');}
  function log(m){document.getElementById('s13Log').innerHTML+='<div>'+m+'</div>';document.getElementById('s13Log').scrollTop=9999;}

  window.s13Step = function(){
    if(stepIdx===0){
      queue=['A'];hlLine('s13L3');log('enqueue root A');draw();stepIdx++;return;
    }
    if(queue.length===0){log('Queue empty — done!');return;}
    const node=queue.shift();
    hlLine('s13L5');
    visited.push(node);
    log('dequeue '+node+' → visit');
    const ch=childrenMap[node]||[];
    ch.forEach(c=>queue.push(c));
    if(ch.length)log('  enqueue children: '+ch.join(', '));
    setTimeout(()=>{hlLine('s13L6');draw();},200);
    stepIdx++;
  };
  window.s13Auto = function(){if(timer)return;timer=setInterval(()=>{if(queue.length===0&&stepIdx>0){clearInterval(timer);timer=null;return;}s13Step();},900);};
  window.s13Reset = function(){if(timer){clearInterval(timer);timer=null;}visited=[];queue=[];stepIdx=0;hlLine(null);document.getElementById('s13Log').innerHTML='';draw();};

  const obs=new MutationObserver(()=>{
    if(document.getElementById('s13').classList.contains('active')) s13Reset();
    else{if(timer){clearInterval(timer);timer=null;}}
  });
  obs.observe(document.getElementById('s13'),{attributes:true,attributeFilter:['class']});
  draw();
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 14: Binary Search Tree -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s14">
  <h2>Binary Search Tree (BST)</h2>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cS14" width="520" height="340" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
      <div style="display:flex;gap:0.5rem;flex-wrap:wrap;margin-top:0.5rem;">
        <input type="number" id="s14input" placeholder="key" style="width:70px;padding:0.4rem 0.6rem;background:#1e293b;border:1px solid #475569;border-radius:6px;color:#e2e8f0;font-family:monospace;">
        <button class="btn btn-sm" onclick="s14Insert()">Insert</button>
        <button class="btn btn-sm" onclick="s14Search()">Search</button>
        <button class="btn btn-sm btn-secondary" onclick="s14Reset()">Reset</button>
        <button class="btn btn-sm btn-secondary" onclick="s14Inorder()">Inorder</button>
      </div>
      <div id="s14Log" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.5rem;font-family:monospace;font-size:0.75rem;max-height:70px;overflow-y:auto;margin-top:0.5rem;color:#94a3b8;"></div>
    </div>
    <div>
      <div class="key-idea">
        <h3>BST Property</h3>
        <p>For <strong>every</strong> node v:</p>
        <ul style="font-size:0.88rem;">
          <li>All keys in left subtree < v's key</li>
          <li>All keys in right subtree > v's key</li>
        </ul>
      </div>
      <h3 style="color:#38bdf8;margin-top:0.75rem;font-size:0.9rem;">Why BST?</h3>
      <table style="font-size:0.78rem;width:100%;">
        <tr><th>Op</th><th>BST (balanced)</th><th>Array</th><th>Linked List</th></tr>
        <tr><td>Search</td><td style="color:#22c55e;">O(log n)</td><td>O(log n)*</td><td style="color:#ef4444;">O(n)</td></tr>
        <tr><td>Insert</td><td style="color:#22c55e;">O(log n)</td><td style="color:#ef4444;">O(n)</td><td>O(1)</td></tr>
        <tr><td>Delete</td><td style="color:#22c55e;">O(log n)</td><td style="color:#ef4444;">O(n)</td><td style="color:#ef4444;">O(n)</td></tr>
      </table>
      <p style="font-size:0.75rem;color:#64748b;">* sorted array with binary search</p>
      <div class="analogy" style="margin-top:0.75rem;">
        <h3>Analogy: Phone Book</h3>
        <p>At each node: go left (smaller) or right (larger). Like binary search on a sorted array, stored as a tree.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS14');
  const ctx=canvas.getContext('2d');
  let root=null, hlPath=[], hlFound=null;

  function makeNode(v){return{val:v,left:null,right:null};}
  function insert(node,v){
    if(!node) return makeNode(v);
    if(v<node.val) node.left=insert(node.left,v);
    else if(v>node.val) node.right=insert(node.right,v);
    return node;
  }

  function drawNode(node,x,y,spread){
    if(!node) return;
    if(node.left){
      const isHL=hlPath.includes(node.val)&&hlPath.includes(node.left.val);
      ctx.strokeStyle=isHL?'#f59e0b':'#475569';ctx.lineWidth=isHL?3:2;
      ctx.beginPath();ctx.moveTo(x,y+16);ctx.lineTo(x-spread,y+65-16);ctx.stroke();
      drawNode(node.left,x-spread,y+65,spread*0.5);
    }
    if(node.right){
      const isHL=hlPath.includes(node.val)&&hlPath.includes(node.right.val);
      ctx.strokeStyle=isHL?'#f59e0b':'#475569';ctx.lineWidth=isHL?3:2;
      ctx.beginPath();ctx.moveTo(x,y+16);ctx.lineTo(x+spread,y+65-16);ctx.stroke();
      drawNode(node.right,x+spread,y+65,spread*0.5);
    }
    const isFound=hlFound===node.val;
    const isPath=hlPath.includes(node.val);
    const leaf=!node.left&&!node.right;
    ctx.fillStyle=isFound?'#22c55e':isPath?'#f59e0b':leaf?'rgba(34,197,94,0.7)':'#6366f1';
    ctx.strokeStyle=isFound?'#4ade80':isPath?'#fbbf24':leaf?'#4ade80':'#818cf8';
    ctx.lineWidth=(isFound||isPath)?3:2;
    ctx.beginPath();ctx.arc(x,y,16,0,Math.PI*2);ctx.fill();ctx.stroke();
    ctx.fillStyle='#fff';ctx.font='bold 12px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
    ctx.fillText(node.val,x,y);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(!root){ctx.fillStyle='#64748b';ctx.font='13px monospace';ctx.textAlign='center';ctx.fillText('Insert keys to build BST',canvas.width/2,canvas.height/2);return;}
    drawNode(root,canvas.width/2,35,130);
  }

  function log(m){document.getElementById('s14Log').innerHTML+='<div>'+m+'</div>';document.getElementById('s14Log').scrollTop=9999;}

  function inorderCollect(node,arr){if(!node)return;inorderCollect(node.left,arr);arr.push(node.val);inorderCollect(node.right,arr);}

  window.s14Insert = function(){
    const v=parseInt(document.getElementById('s14input').value);
    if(isNaN(v))return;
    // trace path
    hlPath=[];hlFound=null;
    let cur=root;
    while(cur){
      hlPath.push(cur.val);
      if(v<cur.val) cur=cur.left;
      else if(v>cur.val) cur=cur.right;
      else break;
    }
    root=insert(root,v);hlPath.push(v);
    log('insert('+v+'): path '+hlPath.join(' → '));
    draw();document.getElementById('s14input').value='';
    setTimeout(()=>{hlPath=[];draw();},1500);
  };

  window.s14Search = function(){
    const v=parseInt(document.getElementById('s14input').value);
    if(isNaN(v))return;
    hlPath=[];hlFound=null;
    let cur=root;
    while(cur){
      hlPath.push(cur.val);
      if(v===cur.val){hlFound=v;break;}
      if(v<cur.val) cur=cur.left; else cur=cur.right;
    }
    log('search('+v+'): '+(hlFound!==null?'<span style="color:#22c55e">FOUND</span>':'<span style="color:#ef4444">NOT FOUND</span>')+' path: '+hlPath.join(' → '));
    draw();
    setTimeout(()=>{hlPath=[];hlFound=null;draw();},2000);
  };

  window.s14Inorder = function(){
    const arr=[];inorderCollect(root,arr);
    log('inorder: <span style="color:#22c55e">'+arr.join(', ')+'</span> (sorted!)');
  };

  window.s14Reset = function(){
    root=null;hlPath=[];hlFound=null;
    [15,8,22,4,12,18,25].forEach(v=>root=insert(root,v));
    document.getElementById('s14Log').innerHTML='';
    draw();
  };

  const obs=new MutationObserver(()=>{
    if(document.getElementById('s14').classList.contains('active')) s14Reset();
  });
  obs.observe(document.getElementById('s14'),{attributes:true,attributeFilter:['class']});
  s14Reset();
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 15: BST Search -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s15">
  <h2>BST Search</h2>
  <p>Compare target with current node. Go <strong>left</strong> if smaller, <strong>right</strong> if larger.</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cS15" width="520" height="310" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
      <div style="display:flex;gap:0.5rem;flex-wrap:wrap;margin-top:0.5rem;">
        <input type="number" id="s15input" value="12" style="width:60px;padding:0.4rem 0.6rem;background:#1e293b;border:1px solid #475569;border-radius:6px;color:#e2e8f0;font-family:monospace;">
        <button class="btn btn-sm" onclick="s15Search()">Search</button>
        <button class="btn btn-sm btn-secondary" onclick="s15Reset()">Reset</button>
      </div>
      <div id="s15Status" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.5rem;font-family:monospace;font-size:0.82rem;margin-top:0.5rem;color:#94a3b8;text-align:center;min-height:30px;"></div>
    </div>
    <div>
      <div class="code-block" style="font-size:0.82rem;">
        <div class="code-content">
          <div class="line" id="s15L1">search(node, key):</div>
          <div class="line" id="s15L2">  if node == null:</div>
          <div class="line" id="s15L3">    return null       // not found</div>
          <div class="line" id="s15L4">  if key == node.key:</div>
          <div class="line" id="s15L5">    return node       // found!</div>
          <div class="line" id="s15L6">  if key &lt; node.key:</div>
          <div class="line" id="s15L7">    return search(node.left, key)</div>
          <div class="line" id="s15L8">  else:</div>
          <div class="line" id="s15L9">    return search(node.right, key)</div>
        </div>
      </div>
      <div class="key-idea" style="margin-top:0.75rem;">
        <h3>Each comparison eliminates half the tree</h3>
        <p>Like binary search on an array! Comparisons = <strong>depth of target node</strong>.</p>
      </div>
      <div id="s15Log" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.5rem;font-family:monospace;font-size:0.72rem;max-height:80px;overflow-y:auto;margin-top:0.5rem;color:#94a3b8;"></div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS15');
  const ctx=canvas.getContext('2d');
  const vals=[15,8,22,4,12,18,25];
  let root=null;
  function mkN(v){return{val:v,left:null,right:null};}
  function ins(n,v){if(!n)return mkN(v);if(v<n.val)n.left=ins(n.left,v);else if(v>n.val)n.right=ins(n.right,v);return n;}
  function build(){root=null;vals.forEach(v=>root=ins(root,v));}

  let hlPath=[],hlFound=null,stepIdx=0,searchSteps=[],timer=null;

  function drawN(node,x,y,sp){
    if(!node)return;
    if(node.left){
      const isE=hlPath.includes(node.val)&&hlPath.includes(node.left.val);
      ctx.strokeStyle=isE?'#f59e0b':'#475569';ctx.lineWidth=isE?3:2;
      ctx.beginPath();ctx.moveTo(x,y+16);ctx.lineTo(x-sp,y+65-16);ctx.stroke();
      drawN(node.left,x-sp,y+65,sp*0.5);
    }
    if(node.right){
      const isE=hlPath.includes(node.val)&&hlPath.includes(node.right.val);
      ctx.strokeStyle=isE?'#f59e0b':'#475569';ctx.lineWidth=isE?3:2;
      ctx.beginPath();ctx.moveTo(x,y+16);ctx.lineTo(x+sp,y+65-16);ctx.stroke();
      drawN(node.right,x+sp,y+65,sp*0.5);
    }
    const isF=hlFound===node.val;
    const isP=hlPath.includes(node.val);
    ctx.fillStyle=isF?'#22c55e':isP?'#f59e0b':'#6366f1';
    ctx.strokeStyle=isF?'#4ade80':isP?'#fbbf24':'#818cf8';ctx.lineWidth=(isF||isP)?3:2;
    ctx.beginPath();ctx.arc(x,y,16,0,Math.PI*2);ctx.fill();ctx.stroke();
    ctx.fillStyle='#fff';ctx.font='bold 12px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
    ctx.fillText(node.val,x,y);
    // direction arrows
    if(isP&&!isF){
      const next=hlPath[hlPath.indexOf(node.val)+1];
      if(next!==undefined){
        const dir=next<node.val?'←L':'R→';
        ctx.fillStyle='#f59e0b';ctx.font='bold 10px monospace';
        ctx.fillText(dir,next<node.val?x-30:x+30,y);
      }
    }
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(!root)return;
    drawN(root,canvas.width/2,35,125);
  }

  function log(m){document.getElementById('s15Log').innerHTML+='<div>'+m+'</div>';document.getElementById('s15Log').scrollTop=9999;}
  function hlLine(id){['s15L1','s15L2','s15L3','s15L4','s15L5','s15L6','s15L7','s15L8','s15L9'].forEach(x=>document.getElementById(x).classList.remove('active'));if(id)document.getElementById(id).classList.add('active');}

  window.s15Search = function(){
    const key=parseInt(document.getElementById('s15input').value);
    if(isNaN(key))return;
    if(timer){clearInterval(timer);timer=null;}
    hlPath=[];hlFound=null;stepIdx=0;
    // precompute steps
    searchSteps=[];
    let cur=root;
    while(cur){
      if(key===cur.val){searchSteps.push({node:cur.val,line:'s15L5',msg:'key == '+cur.val+' → FOUND!',found:true});break;}
      else if(key<cur.val){searchSteps.push({node:cur.val,line:'s15L7',msg:key+' < '+cur.val+' → go LEFT'});cur=cur.left;}
      else{searchSteps.push({node:cur.val,line:'s15L9',msg:key+' > '+cur.val+' → go RIGHT'});cur=cur.right;}
    }
    if(!cur) searchSteps.push({node:null,line:'s15L3',msg:'null → NOT FOUND',found:false});
    document.getElementById('s15Log').innerHTML='';
    timer=setInterval(()=>{
      if(stepIdx>=searchSteps.length){clearInterval(timer);timer=null;return;}
      const s=searchSteps[stepIdx];
      hlLine(s.line);
      if(s.node!==null) hlPath.push(s.node);
      if(s.found===true) hlFound=s.node;
      log('Step '+(stepIdx+1)+': '+s.msg);
      draw();
      if(s.found===true) document.getElementById('s15Status').innerHTML='<span style="color:#22c55e">✓ Found '+key+'! ('+hlPath.length+' comparisons)</span>';
      else if(s.found===false) document.getElementById('s15Status').innerHTML='<span style="color:#ef4444">✗ '+key+' not found ('+hlPath.length+' comparisons)</span>';
      stepIdx++;
    },800);
  };

  window.s15Reset = function(){
    if(timer){clearInterval(timer);timer=null;}
    build();hlPath=[];hlFound=null;stepIdx=0;hlLine(null);
    document.getElementById('s15Log').innerHTML='';
    document.getElementById('s15Status').innerHTML='Enter a key and click Search';
    draw();
  };

  const obs=new MutationObserver(()=>{
    if(document.getElementById('s15').classList.contains('active')) s15Reset();
    else{if(timer){clearInterval(timer);timer=null;}}
  });
  obs.observe(document.getElementById('s15'),{attributes:true,attributeFilter:['class']});
  build();draw();
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 16: BST Insert -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s16">
  <h2>BST Insert</h2>
  <p>Search for the key. When you reach <code>null</code>, that's where the new node goes.</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cS16" width="520" height="320" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
      <div style="display:flex;gap:0.5rem;flex-wrap:wrap;margin-top:0.5rem;">
        <input type="number" id="s16input" placeholder="key" style="width:60px;padding:0.4rem 0.6rem;background:#1e293b;border:1px solid #475569;border-radius:6px;color:#e2e8f0;font-family:monospace;">
        <button class="btn btn-sm" onclick="s16Insert()">Insert</button>
        <button class="btn btn-sm btn-secondary" onclick="s16Reset()">Reset</button>
      </div>
      <div id="s16Log" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.5rem;font-family:monospace;font-size:0.75rem;max-height:80px;overflow-y:auto;margin-top:0.5rem;color:#94a3b8;"></div>
    </div>
    <div>
      <div class="code-block" style="font-size:0.82rem;">
        <div class="code-content">
          <div class="line">insert(node, key):</div>
          <div class="line">  if node == null:</div>
          <div class="line">    return new Node(key)  // leaf</div>
          <div class="line">  if key &lt; node.key:</div>
          <div class="line">    node.left = insert(node.left, key)</div>
          <div class="line">  else if key &gt; node.key:</div>
          <div class="line">    node.right = insert(node.right, key)</div>
          <div class="line">  return node</div>
        </div>
      </div>
      <div class="key-idea" style="margin-top:0.75rem;">
        <h3>New nodes are always leaves!</h3>
        <p>Insert never modifies existing nodes — just creates a new leaf at the correct position.</p>
      </div>
      <div class="warning" style="margin-top:0.75rem;">
        <h3>Insertion Order Matters</h3>
        <p>Inserting 1,2,3,4,5 in order creates a <strong>skewed tree</strong> (linked list!). Different orders → different shapes.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS16');
  const ctx=canvas.getContext('2d');
  let root=null,hlPath=[],hlNew=null;
  function mkN(v){return{val:v,left:null,right:null};}
  function ins(n,v){if(!n)return mkN(v);if(v<n.val)n.left=ins(n.left,v);else if(v>n.val)n.right=ins(n.right,v);return n;}

  function drawN(node,x,y,sp){
    if(!node)return;
    if(node.left){ctx.strokeStyle=hlPath.includes(node.val)&&hlPath.includes(node.left.val)?'#f59e0b':'#475569';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(x,y+16);ctx.lineTo(x-sp,y+60-16);ctx.stroke();drawN(node.left,x-sp,y+60,sp*0.48);}
    if(node.right){ctx.strokeStyle=hlPath.includes(node.val)&&hlPath.includes(node.right.val)?'#f59e0b':'#475569';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(x,y+16);ctx.lineTo(x+sp,y+60-16);ctx.stroke();drawN(node.right,x+sp,y+60,sp*0.48);}
    const isNew=hlNew===node.val;const isP=hlPath.includes(node.val);
    ctx.fillStyle=isNew?'#22c55e':isP?'#f59e0b':'#6366f1';
    ctx.strokeStyle=isNew?'#4ade80':isP?'#fbbf24':'#818cf8';ctx.lineWidth=(isNew||isP)?3:2;
    ctx.beginPath();ctx.arc(x,y,15,0,Math.PI*2);ctx.fill();ctx.stroke();
    ctx.fillStyle='#fff';ctx.font='bold 11px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
    ctx.fillText(node.val,x,y);
    if(isNew){ctx.fillStyle='#22c55e';ctx.font='bold 10px monospace';ctx.fillText('NEW!',x,y+26);}
  }

  function draw(){ctx.clearRect(0,0,canvas.width,canvas.height);if(!root){ctx.fillStyle='#64748b';ctx.font='13px monospace';ctx.textAlign='center';ctx.fillText('Insert keys to build BST',canvas.width/2,canvas.height/2);return;}drawN(root,canvas.width/2,30,125);}
  function log(m){document.getElementById('s16Log').innerHTML+='<div>'+m+'</div>';document.getElementById('s16Log').scrollTop=9999;}

  window.s16Insert = function(){
    const v=parseInt(document.getElementById('s16input').value);
    if(isNaN(v))return;
    hlPath=[];hlNew=null;
    let cur=root;
    while(cur){hlPath.push(cur.val);if(v<cur.val)cur=cur.left;else if(v>cur.val)cur=cur.right;else break;}
    root=ins(root,v);hlNew=v;hlPath.push(v);
    log('insert('+v+'): path '+hlPath.join(' → ')+' → new leaf');
    draw();document.getElementById('s16input').value='';
    setTimeout(()=>{hlPath=[];hlNew=null;draw();},1800);
  };

  window.s16Reset = function(){
    root=null;hlPath=[];hlNew=null;
    [15,8,22,4,12].forEach(v=>root=ins(root,v));
    document.getElementById('s16Log').innerHTML='';draw();
  };

  const obs=new MutationObserver(()=>{if(document.getElementById('s16').classList.contains('active'))s16Reset();});
  obs.observe(document.getElementById('s16'),{attributes:true,attributeFilter:['class']});
  s16Reset();
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 17: BST Delete Overview -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s17">
  <h2>BST Delete: Three Cases</h2>
  <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:1rem;margin-top:1rem;">
    <div style="background:rgba(0,0,0,0.2);border-radius:10px;padding:1rem;text-align:center;">
      <h3 style="color:#22c55e;font-size:0.85rem;">Case 1: Leaf</h3>
      <p style="font-size:0.78rem;color:#94a3b8;">Just remove it</p>
      <canvas id="cS17a" width="200" height="160" style="background:rgba(0,0,0,0.15);border-radius:8px;margin:0.5rem auto;display:block;"></canvas>
      <button class="btn btn-sm" onclick="s17Demo('leaf')" style="font-size:0.75rem;">Delete 4</button>
    </div>
    <div style="background:rgba(0,0,0,0.2);border-radius:10px;padding:1rem;text-align:center;">
      <h3 style="color:#f59e0b;font-size:0.85rem;">Case 2: One Child</h3>
      <p style="font-size:0.78rem;color:#94a3b8;">Replace with child</p>
      <canvas id="cS17b" width="200" height="160" style="background:rgba(0,0,0,0.15);border-radius:8px;margin:0.5rem auto;display:block;"></canvas>
      <button class="btn btn-sm" onclick="s17Demo('one')" style="font-size:0.75rem;">Delete 22</button>
    </div>
    <div style="background:rgba(0,0,0,0.2);border-radius:10px;padding:1rem;text-align:center;">
      <h3 style="color:#ef4444;font-size:0.85rem;">Case 3: Two Children</h3>
      <p style="font-size:0.78rem;color:#94a3b8;">Find inorder successor</p>
      <canvas id="cS17c" width="200" height="160" style="background:rgba(0,0,0,0.15);border-radius:8px;margin:0.5rem auto;display:block;"></canvas>
      <button class="btn btn-sm" onclick="s17Demo('two')" style="font-size:0.75rem;">Delete 8</button>
    </div>
  </div>
  <div class="key-idea" style="margin-top:1rem;">
    <h3>Difficulty increases: Case 1 (trivial) → Case 2 (bypass) → Case 3 (find successor, copy, delete) — next slide!</h3>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  function drawMini(cid,nodes,edges,hl,removed){
    const c=document.getElementById(cid);const ctx=c.getContext('2d');
    ctx.clearRect(0,0,c.width,c.height);
    for(const[a,b] of edges){
      if(removed&&(removed.includes(a.id)||removed.includes(b.id)))continue;
      ctx.strokeStyle='#475569';ctx.lineWidth=1.5;
      ctx.beginPath();ctx.moveTo(a.x,a.y+11);ctx.lineTo(b.x,b.y-11);ctx.stroke();
    }
    for(const n of nodes){
      if(removed&&removed.includes(n.id)){
        ctx.strokeStyle='#ef4444';ctx.lineWidth=1;ctx.setLineDash([3,3]);
        ctx.beginPath();ctx.arc(n.x,n.y,11,0,Math.PI*2);ctx.stroke();ctx.setLineDash([]);
        ctx.fillStyle='#ef4444';ctx.font='8px monospace';ctx.textAlign='center';ctx.fillText('×',n.x,n.y+3);
        continue;
      }
      const isHL=hl&&hl.includes(n.id);
      ctx.fillStyle=isHL?'#f59e0b':'#6366f1';ctx.strokeStyle=isHL?'#fbbf24':'#818cf8';ctx.lineWidth=1.5;
      ctx.beginPath();ctx.arc(n.x,n.y,11,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 10px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(n.v,n.x,n.y);
    }
  }
  const N15={id:'15',v:15,x:100,y:20},N8={id:'8',v:8,x:55,y:60},N22={id:'22',v:22,x:145,y:60},
    N4={id:'4',v:4,x:30,y:105},N12={id:'12',v:12,x:80,y:105},N25={id:'25',v:25,x:160,y:105},
    N10={id:'10',v:10,x:65,y:145};
  const allN=[N15,N8,N22,N4,N12,N25,N10];
  const allE=[[N15,N8],[N15,N22],[N8,N4],[N8,N12],[N22,N25],[N12,N10]];

  let states={leaf:null,one:null,two:null};

  function drawAll(){
    drawMini('cS17a',allN,allE,null,states.leaf);
    drawMini('cS17b',allN,allE,null,states.one);
    drawMini('cS17c',allN,allE,states.two==='done'?['10']:null,states.two==='done'?['8']:null);
  }

  window.s17Demo = function(type){
    if(type==='leaf'){states.leaf=states.leaf?null:['4'];drawAll();}
    else if(type==='one'){states.one=states.one?null:['22'];drawAll();}
    else{states.two=states.two?null:'done';drawAll();}
  };

  const obs=new MutationObserver(()=>{if(document.getElementById('s17').classList.contains('active')){states={leaf:null,one:null,two:null};drawAll();}});
  obs.observe(document.getElementById('s17'),{attributes:true,attributeFilter:['class']});
  drawAll();
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 18: BST Delete Two Children Detail -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s18">
  <h2>BST Delete: Two Children (Detail)</h2>
  <p>Delete <strong>8</strong>: has two children, so find the <strong>inorder successor</strong>.</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cS18" width="520" height="320" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
      <div style="display:flex;gap:0.5rem;margin-top:0.5rem;">
        <button class="btn btn-sm" onclick="s18Step()">Step</button>
        <button class="btn btn-sm" onclick="s18Auto()">Auto Play</button>
        <button class="btn btn-sm btn-secondary" onclick="s18Reset()">Reset</button>
      </div>
      <div id="s18Status" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.5rem;font-family:monospace;font-size:0.82rem;margin-top:0.5rem;color:#cbd5e1;text-align:center;"></div>
    </div>
    <div>
      <div id="s18Log" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.6rem;font-family:monospace;font-size:0.78rem;max-height:160px;overflow-y:auto;color:#94a3b8;"></div>
      <div class="warning" style="margin-top:0.75rem;">
        <h3>Why Inorder Successor?</h3>
        <p>The <strong>smallest value larger than</strong> the deleted node. It always has <strong>at most one child</strong> (right only), so deleting it is Case 1 or 2.</p>
      </div>
      <div class="key-idea" style="margin-top:0.75rem;">
        <h3>Alternative: Inorder Predecessor</h3>
        <p>Could also use the <strong>largest in the left subtree</strong>. Both work!</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS18');
  const ctx=canvas.getContext('2d');
  // Fixed tree: 15(8(4,12(10,_)),22)
  // Steps: 1) find 8, 2) find successor (go right to 12, left to 10), 3) copy 10 into 8's spot, 4) delete old 10
  const initNodes=[
    {id:15,x:260,y:35},{id:8,x:130,y:105},{id:22,x:390,y:105},
    {id:4,x:65,y:185},{id:12,x:195,y:185},{id:10,x:155,y:260}
  ];
  const initEdges=[[15,8],[15,22],[8,4],[8,12],[12,10]];

  let nodes,edges,step,timer,hlNodes,hlEdges,labels;

  function init(){
    nodes=JSON.parse(JSON.stringify(initNodes));
    edges=initEdges.map(e=>[...e]);
    step=0;hlNodes=[];hlEdges=[];labels={};
    if(timer)clearInterval(timer);timer=null;
    document.getElementById('s18Log').innerHTML='';
    document.getElementById('s18Status').innerHTML='Delete node 8 (has two children)';
    draw();
  }

  function findPos(id){return nodes.find(n=>n.id===id);}

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(const[a,b] of edges){
      const pa=findPos(a),pb=findPos(b);
      if(!pa||!pb)continue;
      const isHL=hlEdges.some(e=>(e[0]===a&&e[1]===b)||(e[0]===b&&e[1]===a));
      ctx.strokeStyle=isHL?'#f59e0b':'#475569';ctx.lineWidth=isHL?3:2;
      ctx.beginPath();ctx.moveTo(pa.x,pa.y+16);ctx.lineTo(pb.x,pb.y-16);ctx.stroke();
    }
    for(const n of nodes){
      const isHL=hlNodes.includes(n.id);
      const isDelete=labels[n.id]==='delete';
      const isSuccessor=labels[n.id]==='successor';
      const isNew=labels[n.id]==='new';
      ctx.fillStyle=isDelete?'#ef4444':isSuccessor?'#f59e0b':isNew?'#22c55e':isHL?'#a78bfa':'#6366f1';
      ctx.strokeStyle=isDelete?'#f87171':isSuccessor?'#fbbf24':isNew?'#4ade80':isHL?'#c4b5fd':'#818cf8';
      ctx.lineWidth=(isDelete||isSuccessor||isNew)?3:2;
      ctx.beginPath();ctx.arc(n.x,n.y,16,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 12px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(n.id,n.x,n.y);
      // label below
      if(isDelete){ctx.fillStyle='#ef4444';ctx.font='bold 10px monospace';ctx.fillText('DELETE',n.x,n.y+28);}
      if(isSuccessor){ctx.fillStyle='#f59e0b';ctx.font='bold 10px monospace';ctx.fillText('SUCCESSOR',n.x,n.y+28);}
      if(isNew){ctx.fillStyle='#22c55e';ctx.font='bold 10px monospace';ctx.fillText('REPLACED',n.x,n.y+28);}
    }
  }

  function log(m){document.getElementById('s18Log').innerHTML+='<div>'+m+'</div>';document.getElementById('s18Log').scrollTop=9999;}

  const stepFns=[
    ()=>{labels[8]='delete';hlNodes=[8];log('Step 1: Find node 8 — it has TWO children (4 and 12)');document.getElementById('s18Status').innerHTML='Node 8 has two children → need inorder successor';},
    ()=>{hlEdges=[[8,12]];hlNodes=[12];log('Step 2: Go RIGHT to 12 (right subtree)');document.getElementById('s18Status').innerHTML='Finding inorder successor: go right, then left as far as possible';},
    ()=>{hlEdges=[[8,12],[12,10]];hlNodes=[10];labels[10]='successor';log('Step 3: Go LEFT to 10 — no more left → 10 is the inorder successor!');document.getElementById('s18Status').innerHTML='Successor found: 10 (smallest in right subtree)';},
    ()=>{
      // copy 10 into 8's position
      const n8=findPos(8);n8.id=10;labels={};labels[10]='new';hlNodes=[];hlEdges=[];
      // remove old 10 node
      nodes=nodes.filter(n=>!(n.y===260));
      edges=edges.filter(e=>!(e[0]===12&&e[1]===10)&&!(e[0]===10&&e[1]===12));
      // fix edges: old 8 edges now point to 10
      edges=edges.map(e=>{if(e[0]===8)return[10,e[1]];if(e[1]===8)return[e[0],10];return e;});
      log('Step 4: Copy 10 into 8\'s position, delete old 10 (it was a leaf → Case 1)');
      document.getElementById('s18Status').innerHTML='<span style="color:#22c55e">✓ Done! BST property intact: 4 < 10 < 12 < 15</span>';
    }
  ];

  window.s18Step = function(){if(step>=stepFns.length)return;stepFns[step]();draw();step++;};
  window.s18Auto = function(){if(timer)return;timer=setInterval(()=>{if(step>=stepFns.length){clearInterval(timer);timer=null;return;}s18Step();},1200);};
  window.s18Reset = function(){init();};

  const obs=new MutationObserver(()=>{
    if(document.getElementById('s18').classList.contains('active'))init();
    else{if(timer){clearInterval(timer);timer=null;}}
  });
  obs.observe(document.getElementById('s18'),{attributes:true,attributeFilter:['class']});
  init();
})();
</script>

<!-- ============================================================ -->
<!-- CHALLENGE A: Predict Traversal Output -->
<!-- ============================================================ -->
<div class="slide fade-in" id="sCA">
  <h2>Challenge: Predict the Traversal</h2>
  <p>Given this tree, predict the output of each traversal.</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cCA" width="520" height="250" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
    </div>
    <div>
      <div style="display:grid;gap:0.75rem;">
        <div>
          <label style="color:#38bdf8;font-size:0.85rem;font-weight:bold;">Preorder (NLR):</label>
          <input type="text" id="sCAa1" placeholder="e.g. A B D ..." style="width:100%;padding:0.4rem;background:#1e293b;border:1px solid #475569;border-radius:6px;color:#e2e8f0;font-family:monospace;font-size:0.85rem;margin-top:0.3rem;">
        </div>
        <div>
          <label style="color:#f59e0b;font-size:0.85rem;font-weight:bold;">Inorder (LNR):</label>
          <input type="text" id="sCAa2" placeholder="e.g. D B ..." style="width:100%;padding:0.4rem;background:#1e293b;border:1px solid #475569;border-radius:6px;color:#e2e8f0;font-family:monospace;font-size:0.85rem;margin-top:0.3rem;">
        </div>
        <div>
          <label style="color:#a78bfa;font-size:0.85rem;font-weight:bold;">Postorder (LRN):</label>
          <input type="text" id="sCAa3" placeholder="e.g. D E ..." style="width:100%;padding:0.4rem;background:#1e293b;border:1px solid #475569;border-radius:6px;color:#e2e8f0;font-family:monospace;font-size:0.85rem;margin-top:0.3rem;">
        </div>
      </div>
      <div style="display:flex;gap:0.5rem;margin-top:0.75rem;">
        <button class="btn btn-sm" onclick="sCACheck()">Check Answers</button>
        <button class="btn btn-sm btn-secondary" onclick="sCAReveal()">Show Answers</button>
      </div>
      <div id="sCAResult" style="margin-top:0.5rem;font-size:0.85rem;"></div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cCA');
  const ctx=canvas.getContext('2d');
  // Tree: 20(10(5,15),30(_,35))
  const nodes=[{v:20,x:260,y:35},{v:10,x:140,y:110},{v:30,x:380,y:110},{v:5,x:75,y:190},{v:15,x:205,y:190},{v:35,x:430,y:190}];
  const edges=[[0,1],[0,2],[1,3],[1,4],[2,5]];
  const answers={pre:'20 10 5 15 30 35',in:'5 10 15 20 30 35',post:'5 15 10 35 30 20'};

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(const[a,b] of edges){
      ctx.strokeStyle='#475569';ctx.lineWidth=2;
      ctx.beginPath();ctx.moveTo(nodes[a].x,nodes[a].y+16);ctx.lineTo(nodes[b].x,nodes[b].y-16);ctx.stroke();
    }
    for(const n of nodes){
      const leaf=!edges.some(e=>e[0]===nodes.indexOf(n)&&nodes[e[1]]);
      // check if it's actually a leaf
      const idx=nodes.indexOf(n);
      const isLeaf=!edges.some(e=>e[0]===idx);
      ctx.fillStyle=isLeaf?'#22c55e':'#6366f1';
      ctx.strokeStyle=isLeaf?'#4ade80':'#818cf8';ctx.lineWidth=2;
      ctx.beginPath();ctx.arc(n.x,n.y,16,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 13px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(n.v,n.x,n.y);
    }
    // L/R labels
    ctx.fillStyle='#64748b';ctx.font='9px monospace';ctx.textAlign='center';
    ctx.fillText('L',nodes[1].x,nodes[1].y+26);ctx.fillText('R',nodes[2].x,nodes[2].y+26);
  }

  function normalize(s){return s.trim().replace(/[,→\->/]+/g,' ').replace(/\s+/g,' ').trim();}

  window.sCACheck = function(){
    const a1=normalize(document.getElementById('sCAa1').value);
    const a2=normalize(document.getElementById('sCAa2').value);
    const a3=normalize(document.getElementById('sCAa3').value);
    let score=0;
    if(a1===answers.pre){document.getElementById('sCAa1').style.borderColor='#22c55e';score++;}else document.getElementById('sCAa1').style.borderColor='#ef4444';
    if(a2===answers.in){document.getElementById('sCAa2').style.borderColor='#22c55e';score++;}else document.getElementById('sCAa2').style.borderColor='#ef4444';
    if(a3===answers.post){document.getElementById('sCAa3').style.borderColor='#22c55e';score++;}else document.getElementById('sCAa3').style.borderColor='#ef4444';
    document.getElementById('sCAResult').innerHTML=score===3?'<span style="color:#22c55e">✓ All correct!</span>':'<span style="color:#f59e0b">'+score+'/3 correct</span>';
  };
  window.sCAReveal = function(){
    document.getElementById('sCAa1').value=answers.pre;document.getElementById('sCAa1').style.borderColor='#22c55e';
    document.getElementById('sCAa2').value=answers.in;document.getElementById('sCAa2').style.borderColor='#22c55e';
    document.getElementById('sCAa3').value=answers.post;document.getElementById('sCAa3').style.borderColor='#22c55e';
    document.getElementById('sCAResult').innerHTML='<span style="color:#22c55e">Answers revealed above</span>';
  };

  const obs=new MutationObserver(()=>{if(document.getElementById('sCA').classList.contains('active'))draw();});
  obs.observe(document.getElementById('sCA'),{attributes:true,attributeFilter:['class']});
  draw();
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 19: BST Performance -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s19">
  <h2>BST Performance</h2>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div style="text-align:center;">
      <h3 style="color:#22c55e;font-size:0.9rem;">Balanced: O(log n)</h3>
      <canvas id="cS19a" width="260" height="200" style="background:rgba(0,0,0,0.2);border-radius:10px;display:inline-block;"></canvas>
      <p style="font-size:0.78rem;color:#94a3b8;margin-top:0.4rem;">Insert: 8, 4, 12, 2, 6, 10, 14<br>height = 2 ≈ log₂(7)</p>
    </div>
    <div style="text-align:center;">
      <h3 style="color:#ef4444;font-size:0.9rem;">Skewed: O(n)</h3>
      <canvas id="cS19b" width="260" height="200" style="background:rgba(0,0,0,0.2);border-radius:10px;display:inline-block;"></canvas>
      <p style="font-size:0.78rem;color:#94a3b8;margin-top:0.4rem;">Insert: 2, 4, 6, 8, 10, 12, 14<br>height = 6 = n − 1 (linked list!)</p>
    </div>
  </div>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <div style="margin-top:0.5rem;">
        <h3 style="color:#38bdf8;font-size:0.85rem;">Try it: enter insertion order</h3>
        <input type="text" id="s19input" value="8,4,12,2,6,10,14" placeholder="e.g. 8,4,12,2,6" style="width:100%;padding:0.4rem;background:#1e293b;border:1px solid #475569;border-radius:6px;color:#e2e8f0;font-family:monospace;font-size:0.85rem;">
        <button class="btn btn-sm" onclick="s19Build()" style="margin-top:0.4rem;">Build Tree</button>
      </div>
    </div>
    <div>
      <table style="font-size:0.82rem;width:100%;">
        <tr><th>BST Type</th><th>Height</th><th>Operations</th></tr>
        <tr style="background:rgba(34,197,94,0.1);"><td>Balanced</td><td>O(log n)</td><td style="color:#22c55e;">O(log n)</td></tr>
        <tr style="background:rgba(239,68,68,0.1);"><td>Skewed</td><td>O(n)</td><td style="color:#ef4444;">O(n)</td></tr>
      </table>
      <div class="warning" style="margin-top:0.5rem;">
        <h3>Sorted input = worst case!</h3>
        <p>Self-balancing trees (AVL, Red-Black) prevent this.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  function mkN(v){return{val:v,left:null,right:null};}
  function ins(n,v){if(!n)return mkN(v);if(v<n.val)n.left=ins(n.left,v);else if(v>n.val)n.right=ins(n.right,v);return n;}
  function getH(n){if(!n)return -1;return 1+Math.max(getH(n.left),getH(n.right));}
  function countN(n){if(!n)return 0;return 1+countN(n.left)+countN(n.right);}

  function drawTree(canvasId,root){
    const c=document.getElementById(canvasId);const ctx=c.getContext('2d');
    ctx.clearRect(0,0,c.width,c.height);
    if(!root)return;
    const h=getH(root);
    function drawN(node,x,y,sp){
      if(!node)return;
      if(node.left){ctx.strokeStyle='#475569';ctx.lineWidth=1.5;ctx.beginPath();ctx.moveTo(x,y+10);ctx.lineTo(x-sp,y+Math.min(30,150/h)-10);ctx.stroke();drawN(node.left,x-sp,y+Math.min(30,150/h),sp*0.5);}
      if(node.right){ctx.strokeStyle='#475569';ctx.lineWidth=1.5;ctx.beginPath();ctx.moveTo(x,y+10);ctx.lineTo(x+sp,y+Math.min(30,150/h)-10);ctx.stroke();drawN(node.right,x+sp,y+Math.min(30,150/h),sp*0.5);}
      const leaf=!node.left&&!node.right;
      ctx.fillStyle=leaf?'#22c55e':'#6366f1';ctx.strokeStyle=leaf?'#4ade80':'#818cf8';ctx.lineWidth=1.5;
      ctx.beginPath();ctx.arc(x,y,10,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 9px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(node.val,x,y);
    }
    drawN(root,c.width/2,20,c.width*0.22);
    const n=countN(root);
    ctx.fillStyle='#94a3b8';ctx.font='10px monospace';ctx.textAlign='center';
    ctx.fillText('n='+n+', h='+h,c.width/2,c.height-8);
  }

  // draw defaults
  function drawDefaults(){
    let r1=null;[8,4,12,2,6,10,14].forEach(v=>r1=ins(r1,v));drawTree('cS19a',r1);
    let r2=null;[2,4,6,8,10,12,14].forEach(v=>r2=ins(r2,v));drawTree('cS19b',r2);
  }

  window.s19Build = function(){
    const vals=document.getElementById('s19input').value.split(',').map(s=>parseInt(s.trim())).filter(v=>!isNaN(v));
    if(!vals.length)return;
    let r=null;vals.forEach(v=>r=ins(r,v));
    drawTree('cS19a',r);
  };

  const obs=new MutationObserver(()=>{if(document.getElementById('s19').classList.contains('active'))drawDefaults();});
  obs.observe(document.getElementById('s19'),{attributes:true,attributeFilter:['class']});
  drawDefaults();
})();
</script>

<!-- ============================================================ -->
<!-- CHALLENGE B: Fix the Bug -->
<!-- ============================================================ -->
<div class="slide fade-in" id="sCB">
  <h2>Challenge: Fix the Bug</h2>
  <p>This BST insert function has a bug. Can you spot it?</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <div class="code-block" style="font-size:0.82rem;">
        <div class="code-content">
          <div class="line">void insert(Node node, int key) {</div>
          <div class="line">  if (node == null) {</div>
          <div class="line" style="background:rgba(239,68,68,0.15);border-left:3px solid #ef4444;">    node = new Node(key);</div>
          <div class="line">    return;</div>
          <div class="line">  }</div>
          <div class="line">  if (key &lt; node.key)</div>
          <div class="line">    insert(node.left, key);</div>
          <div class="line">  else if (key &gt; node.key)</div>
          <div class="line">    insert(node.right, key);</div>
          <div class="line">}</div>
        </div>
      </div>
      <div style="margin-top:1rem;">
        <select id="sCBsel" style="width:100%;padding:0.5rem;background:#1e293b;border:1px solid #475569;border-radius:6px;color:#e2e8f0;font-size:0.85rem;">
          <option value="">Select the bug…</option>
          <option value="a">A. Missing else clause for duplicate keys</option>
          <option value="b">B. node = new Node(key) doesn't link to parent</option>
          <option value="c">C. Should use iteration, not recursion</option>
          <option value="d">D. Missing null check before comparing keys</option>
        </select>
        <button class="btn btn-sm" style="margin-top:0.5rem;" onclick="sCBCheck()">Check Answer</button>
        <div id="sCBResult" style="margin-top:0.5rem;font-size:0.85rem;"></div>
      </div>
    </div>
    <div>
      <canvas id="cCB" width="520" height="340" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cCB');
  const ctx=canvas.getContext('2d');

  function draw(showExplain){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(!showExplain){
      ctx.fillStyle='#94a3b8';ctx.font='13px monospace';ctx.textAlign='center';
      ctx.fillText('Select your answer and click Check',canvas.width/2,canvas.height/2);
      return;
    }
    ctx.fillStyle='#e2e8f0';ctx.font='bold 12px monospace';ctx.textAlign='left';
    ctx.fillText('The Problem:',15,25);
    ctx.fillStyle='#cbd5e1';ctx.font='11px monospace';
    ctx.fillText('Java passes references by VALUE.',15,48);
    ctx.fillText('node = new Node(key) creates a local variable',15,66);
    ctx.fillText('but the PARENT\'s .left/.right still points to null!',15,84);

    ctx.fillStyle='#ef4444';ctx.font='bold 12px monospace';
    ctx.fillText('Buggy: parent.left is still null!',15,115);
    // draw parent → null
    ctx.fillStyle='#6366f1';ctx.beginPath();ctx.arc(100,155,16,0,Math.PI*2);ctx.fill();
    ctx.fillStyle='#fff';ctx.font='bold 12px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
    ctx.fillText('15',100,155);
    ctx.fillStyle='#64748b';ctx.font='11px monospace';ctx.textAlign='left';
    ctx.fillText('.left = null  (unchanged!)',130,158);
    // orphan node
    ctx.strokeStyle='#ef4444';ctx.lineWidth=1;ctx.setLineDash([3,3]);
    ctx.beginPath();ctx.arc(100,220,14,0,Math.PI*2);ctx.stroke();ctx.setLineDash([]);
    ctx.fillStyle='#ef4444';ctx.font='10px monospace';ctx.textAlign='center';
    ctx.fillText('10 (orphan!)',100,250);

    ctx.fillStyle='#22c55e';ctx.font='bold 12px monospace';ctx.textAlign='left';
    ctx.fillText('Fix: return the new node and assign it:',15,285);
    ctx.fillStyle='#cbd5e1';ctx.font='11px monospace';
    ctx.fillText('Node insert(Node node, int key) {',15,308);
    ctx.fillText('  if (node == null) return new Node(key);',15,324);
    ctx.fillText('  ...  node.left = insert(node.left, key);',15,340);
  }

  window.sCBCheck = function(){
    const sel=document.getElementById('sCBsel').value;
    const res=document.getElementById('sCBResult');
    if(!sel){res.innerHTML='<span style="color:#f59e0b;">Please select an answer.</span>';return;}
    if(sel==='b'){
      res.innerHTML='<span style="color:#22c55e;">✓ Correct!</span> Setting a local parameter doesn\'t update the parent\'s pointer. Must return the node and assign.';
      draw(true);
    } else {
      const exp={a:'Duplicate handling is optional, not the bug here.',c:'Recursion is fine — the issue is how the new node is linked.',d:'The null check is there (line 2), that\'s not the problem.'};
      res.innerHTML='<span style="color:#ef4444;">✗ Not quite.</span> '+exp[sel];
      draw(false);
    }
  };

  const obs=new MutationObserver(()=>{if(document.getElementById('sCB').classList.contains('active'))draw(false);});
  obs.observe(document.getElementById('sCB'),{attributes:true,attributeFilter:['class']});
  draw(false);
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 20: Balanced BSTs Preview -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s20">
  <h2>Balanced BSTs (Preview)</h2>
  <p>Self-balancing trees <strong>guarantee</strong> O(log n) performance.</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <h3 style="color:#38bdf8;font-size:0.9rem;">AVL Trees</h3>
      <canvas id="cS20a" width="260" height="200" style="background:rgba(0,0,0,0.2);border-radius:10px;width:100%;"></canvas>
      <p style="font-size:0.78rem;color:#94a3b8;margin-top:0.4rem;">Balance Factor = height(left) − height(right) must be in {−1, 0, +1}. When violated → <strong>rotate</strong>.</p>
    </div>
    <div>
      <h3 style="color:#ef4444;font-size:0.9rem;">Red-Black Trees</h3>
      <canvas id="cS20b" width="260" height="200" style="background:rgba(0,0,0,0.2);border-radius:10px;width:100%;"></canvas>
      <p style="font-size:0.78rem;color:#94a3b8;margin-top:0.4rem;">Nodes are red or black. Rules ensure no path is more than 2× longer than any other.</p>
    </div>
  </div>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:0.75rem;">
    <div class="key-idea">
      <h3>AVL: Strictly balanced</h3>
      <p>Faster lookups, more rotations on insert/delete.</p>
    </div>
    <div class="key-idea">
      <h3>Red-Black: Loosely balanced</h3>
      <p>Fewer rotations, used by Java's <code>TreeMap</code>.</p>
    </div>
  </div>
  <div class="analogy" style="margin-top:0.5rem;">
    <h3>Coming Attraction</h3>
    <p>These will be covered in detail later. For now, know they exist and <strong>why</strong>: to prevent O(n) worst case.</p>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  // AVL tree
  function drawAVL(){
    const c=document.getElementById('cS20a');const ctx=c.getContext('2d');
    ctx.clearRect(0,0,c.width,c.height);
    const nodes=[{v:8,x:130,y:25,bf:0},{v:4,x:65,y:75,bf:-1},{v:12,x:195,y:75,bf:0},{v:2,x:35,y:130,bf:0},{v:10,x:165,y:130,bf:0},{v:14,x:225,y:130,bf:0}];
    const edges=[[0,1],[0,2],[1,3],[2,4],[2,5]];
    for(const[a,b] of edges){
      ctx.strokeStyle='#475569';ctx.lineWidth=1.5;
      ctx.beginPath();ctx.moveTo(nodes[a].x,nodes[a].y+12);ctx.lineTo(nodes[b].x,nodes[b].y-12);ctx.stroke();
    }
    for(const n of nodes){
      ctx.fillStyle='#6366f1';ctx.strokeStyle='#818cf8';ctx.lineWidth=1.5;
      ctx.beginPath();ctx.arc(n.x,n.y,12,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 10px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(n.v,n.x,n.y);
      // BF label
      ctx.fillStyle='#38bdf8';ctx.font='9px monospace';ctx.fillText('bf='+n.bf,n.x,n.y+22);
    }
    ctx.fillStyle='#38bdf8';ctx.font='bold 10px monospace';ctx.textAlign='center';
    ctx.fillText('All |BF| ≤ 1 ✓',c.width/2,c.height-10);
  }

  // Red-Black tree
  function drawRB(){
    const c=document.getElementById('cS20b');const ctx=c.getContext('2d');
    ctx.clearRect(0,0,c.width,c.height);
    const nodes=[{v:8,x:130,y:25,red:false},{v:4,x:65,y:75,red:true},{v:12,x:195,y:75,red:true},{v:2,x:35,y:130,red:false},{v:6,x:95,y:130,red:false},{v:10,x:165,y:130,red:false},{v:14,x:225,y:130,red:false}];
    const edges=[[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]];
    for(const[a,b] of edges){
      ctx.strokeStyle='#475569';ctx.lineWidth=1.5;
      ctx.beginPath();ctx.moveTo(nodes[a].x,nodes[a].y+12);ctx.lineTo(nodes[b].x,nodes[b].y-12);ctx.stroke();
    }
    for(const n of nodes){
      ctx.fillStyle=n.red?'#ef4444':'#334155';
      ctx.strokeStyle=n.red?'#f87171':'#818cf8';ctx.lineWidth=1.5;
      ctx.beginPath();ctx.arc(n.x,n.y,12,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 10px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(n.v,n.x,n.y);
    }
    // legend
    ctx.fillStyle='#ef4444';ctx.beginPath();ctx.arc(50,c.height-14,5,0,Math.PI*2);ctx.fill();
    ctx.fillStyle='#e2e8f0';ctx.font='9px monospace';ctx.textAlign='left';ctx.fillText('Red',60,c.height-10);
    ctx.fillStyle='#334155';ctx.beginPath();ctx.arc(110,c.height-14,5,0,Math.PI*2);ctx.fill();
    ctx.strokeStyle='#818cf8';ctx.lineWidth=1;ctx.stroke();
    ctx.fillStyle='#e2e8f0';ctx.fillText('Black',120,c.height-10);
  }

  const obs=new MutationObserver(()=>{if(document.getElementById('s20').classList.contains('active')){drawAVL();drawRB();}});
  obs.observe(document.getElementById('s20'),{attributes:true,attributeFilter:['class']});
  drawAVL();drawRB();
})();
</script>

<!-- ============================================================ -->
<!-- CHALLENGE C: Pick the Right Structure -->
<!-- ============================================================ -->
<div class="slide fade-in" id="sCC">
  <h2>Challenge: Pick the Right Structure</h2>
  <p>For each scenario, choose the best data structure.</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem;margin-top:1rem;">
    <div style="background:rgba(0,0,0,0.2);border-radius:10px;padding:1rem;" id="sCCq1box">
      <h3 style="color:#38bdf8;font-size:0.85rem;">1. Need O(1) average lookup by key</h3>
      <p style="font-size:0.78rem;color:#94a3b8;">No ordering needed, just fast access.</p>
      <select id="sCCq1" style="width:100%;padding:0.4rem;background:#1e293b;border:1px solid #475569;border-radius:6px;color:#e2e8f0;font-size:0.82rem;margin-top:0.4rem;">
        <option value="">Choose…</option><option value="bst">BST</option><option value="hash">Hash Table</option><option value="arr">Sorted Array</option>
      </select>
    </div>
    <div style="background:rgba(0,0,0,0.2);border-radius:10px;padding:1rem;" id="sCCq2box">
      <h3 style="color:#38bdf8;font-size:0.85rem;">2. Need range queries (all keys between 10–50)</h3>
      <p style="font-size:0.78rem;color:#94a3b8;">Must support ordered iteration.</p>
      <select id="sCCq2" style="width:100%;padding:0.4rem;background:#1e293b;border:1px solid #475569;border-radius:6px;color:#e2e8f0;font-size:0.82rem;margin-top:0.4rem;">
        <option value="">Choose…</option><option value="bst">BST</option><option value="hash">Hash Table</option><option value="arr">Sorted Array</option>
      </select>
    </div>
    <div style="background:rgba(0,0,0,0.2);border-radius:10px;padding:1rem;" id="sCCq3box">
      <h3 style="color:#38bdf8;font-size:0.85rem;">3. Represent HTML document structure</h3>
      <p style="font-size:0.78rem;color:#94a3b8;">Nested elements with parent-child relationships.</p>
      <select id="sCCq3" style="width:100%;padding:0.4rem;background:#1e293b;border:1px solid #475569;border-radius:6px;color:#e2e8f0;font-size:0.82rem;margin-top:0.4rem;">
        <option value="">Choose…</option><option value="tree">General Tree</option><option value="hash">Hash Table</option><option value="list">Linked List</option>
      </select>
    </div>
    <div style="background:rgba(0,0,0,0.2);border-radius:10px;padding:1rem;" id="sCCq4box">
      <h3 style="color:#38bdf8;font-size:0.85rem;">4. Evaluate (3 + 4) * 2</h3>
      <p style="font-size:0.78rem;color:#94a3b8;">Arithmetic with operator precedence.</p>
      <select id="sCCq4" style="width:100%;padding:0.4rem;background:#1e293b;border:1px solid #475569;border-radius:6px;color:#e2e8f0;font-size:0.82rem;margin-top:0.4rem;">
        <option value="">Choose…</option><option value="expr">Expression Tree</option><option value="bst">BST</option><option value="stack">Stack</option>
      </select>
    </div>
  </div>
  <div style="display:flex;gap:0.5rem;margin-top:1rem;">
    <button class="btn btn-sm" onclick="sCCCheck()">Check All</button>
  </div>
  <div id="sCCExplain" style="display:none;margin-top:0.75rem;background:rgba(0,0,0,0.2);border-radius:8px;padding:0.75rem;font-size:0.82rem;color:#cbd5e1;line-height:1.7;"></div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const answers={sCCq1:'hash',sCCq2:'bst',sCCq3:'tree',sCCq4:'expr'};
  const explanations={
    sCCq1:'<strong>Hash Table</strong> — O(1) average for lookup. BST is O(log n), sorted array needs binary search.',
    sCCq2:'<strong>BST</strong> — Inorder traversal gives sorted order. Hash tables have no ordering. BSTs excel at range queries.',
    sCCq3:'<strong>General Tree</strong> — HTML\'s DOM is a tree! Each element has children. Not binary (divs can have many children).',
    sCCq4:'<strong>Expression Tree</strong> — Operators as internal nodes, operands as leaves. Postorder evaluation handles precedence naturally. (Stack also works for evaluation, but tree represents the structure.)'
  };
  window.sCCCheck = function(){
    let score=0;
    for(const[id,ans] of Object.entries(answers)){
      const sel=document.getElementById(id).value;
      const box=document.getElementById(id+'box');
      if(sel===ans){box.style.borderLeft='3px solid #22c55e';score++;}
      else if(sel){box.style.borderLeft='3px solid #ef4444';}
      else{box.style.borderLeft='3px solid #f59e0b';}
    }
    const el=document.getElementById('sCCExplain');el.style.display='block';
    el.innerHTML='<strong>Score: '+score+'/4</strong><br><br>'+Object.values(explanations).join('<br><br>');
  };
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 21: Expression Trees -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s21">
  <h2>Application: Expression Trees</h2>
  <p>Operators are internal nodes; operands are leaves. Evaluate with <strong>postorder</strong>!</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cS21" width="520" height="280" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
      <div style="display:flex;gap:0.5rem;margin-top:0.5rem;">
        <button class="btn btn-sm" onclick="s21Step()">Evaluate Step</button>
        <button class="btn btn-sm" onclick="s21Auto()">Auto Play</button>
        <button class="btn btn-sm btn-secondary" onclick="s21Reset()">Reset</button>
      </div>
      <div id="s21Stack" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.5rem;font-family:monospace;font-size:0.85rem;margin-top:0.5rem;color:#a78bfa;text-align:center;">Stack: [ ]</div>
    </div>
    <div>
      <h3 style="color:#38bdf8;font-size:0.85rem;">Expression: (3 + 4) × 2 = ?</h3>
      <div id="s21Log" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.6rem;font-family:monospace;font-size:0.78rem;max-height:120px;overflow-y:auto;margin-top:0.5rem;color:#94a3b8;"></div>
      <h3 style="color:#38bdf8;font-size:0.85rem;margin-top:0.75rem;">Three Notations:</h3>
      <table style="font-size:0.8rem;width:100%;">
        <tr><th>Traversal</th><th>Output</th><th>Notation</th></tr>
        <tr><td>Preorder</td><td><code>× + 3 4 2</code></td><td>Prefix (Polish)</td></tr>
        <tr><td>Inorder</td><td><code>3 + 4 × 2</code></td><td>Infix (needs parens!)</td></tr>
        <tr><td>Postorder</td><td><code>3 4 + 2 ×</code></td><td>Postfix (RPN)</td></tr>
      </table>
      <div class="warning" style="margin-top:0.5rem;">
        <h3>Infix is ambiguous without parentheses</h3>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS21');
  const ctx=canvas.getContext('2d');
  const nodes=[
    {v:'×',x:260,y:40,op:true},
    {v:'+',x:140,y:130,op:true},
    {v:'2',x:380,y:130,op:false},
    {v:'3',x:70,y:220,op:false},
    {v:'4',x:210,y:220,op:false}
  ];
  const edges=[[0,1],[0,2],[1,3],[1,4]];
  // Postorder: 3, 4, +, 2, ×
  const steps=[
    {visit:3,msg:'Visit 3 → push 3',stack:[3]},
    {visit:4,msg:'Visit 4 → push 4',stack:[3,4]},
    {visit:1,msg:'Visit + → pop 4,3 → 3+4=7 → push 7',stack:[7],result:7},
    {visit:2,msg:'Visit 2 → push 2',stack:[7,2]},
    {visit:0,msg:'Visit × → pop 2,7 → 7×2=14 → push 14',stack:[14],result:14}
  ];
  let stepIdx=0, visited=[], timer=null, stack=[];

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(const[a,b] of edges){
      ctx.strokeStyle='#475569';ctx.lineWidth=2;
      ctx.beginPath();ctx.moveTo(nodes[a].x,nodes[a].y+18);ctx.lineTo(nodes[b].x,nodes[b].y-18);ctx.stroke();
    }
    for(let i=0;i<nodes.length;i++){
      const n=nodes[i];
      const vi=visited.includes(i);
      const isCurr=visited.length>0&&visited[visited.length-1]===i;
      ctx.fillStyle=isCurr?(n.op?'#f59e0b':'#22c55e'):vi?'rgba(34,197,94,0.5)':(n.op?'#a78bfa':'#6366f1');
      ctx.strokeStyle=isCurr?'#fbbf24':vi?'#4ade80':(n.op?'#c4b5fd':'#818cf8');
      ctx.lineWidth=isCurr?3:2;
      ctx.beginPath();ctx.arc(n.x,n.y,18,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 16px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(n.v,n.x,n.y);
    }
    document.getElementById('s21Stack').innerHTML='Stack: [ '+stack.join(', ')+' ]';
  }

  function log(m){document.getElementById('s21Log').innerHTML+='<div>'+m+'</div>';document.getElementById('s21Log').scrollTop=9999;}

  window.s21Step = function(){
    if(stepIdx>=steps.length){log('<span style="color:#22c55e">✓ Result: 14</span>');return;}
    const s=steps[stepIdx];
    visited.push(s.visit);
    stack=s.stack.slice();
    log('Step '+(stepIdx+1)+': '+s.msg);
    draw();stepIdx++;
  };
  window.s21Auto = function(){if(timer)return;timer=setInterval(()=>{if(stepIdx>=steps.length){clearInterval(timer);timer=null;log('<span style="color:#22c55e">✓ Result: 14</span>');return;}s21Step();},1000);};
  window.s21Reset = function(){if(timer){clearInterval(timer);timer=null;}stepIdx=0;visited=[];stack=[];document.getElementById('s21Log').innerHTML='';draw();};

  const obs=new MutationObserver(()=>{
    if(document.getElementById('s21').classList.contains('active'))s21Reset();
    else{if(timer){clearInterval(timer);timer=null;}}
  });
  obs.observe(document.getElementById('s21'),{attributes:true,attributeFilter:['class']});
  draw();
})();
</script>

<!-- ============================================================ -->
<!-- SLIDE 22: Summary -->
<!-- ============================================================ -->
<div class="slide fade-in" id="s22">
  <h2>Summary & Cheat Sheet</h2>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cS22" width="520" height="370" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
    </div>
    <div>
      <h3 style="color:#38bdf8;font-size:0.9rem;">Traversals</h3>
      <table style="font-size:0.8rem;width:100%;">
        <tr><th>Name</th><th>Order</th><th>Use For</th></tr>
        <tr><td>Preorder</td><td>NLR</td><td>Copy/serialize</td></tr>
        <tr><td>Inorder</td><td>LNR</td><td>Sorted output (BST)</td></tr>
        <tr><td>Postorder</td><td>LRN</td><td>Delete / eval expr</td></tr>
        <tr><td>Level-order</td><td>BFS</td><td>Level-by-level</td></tr>
      </table>
      <h3 style="color:#38bdf8;font-size:0.9rem;margin-top:0.75rem;">BST Complexity</h3>
      <table style="font-size:0.8rem;width:100%;">
        <tr><th>Type</th><th>Height</th><th>Ops</th></tr>
        <tr style="background:rgba(34,197,94,0.1);"><td>Balanced</td><td>O(log n)</td><td style="color:#22c55e;">O(log n)</td></tr>
        <tr style="background:rgba(239,68,68,0.1);"><td>Skewed</td><td>O(n)</td><td style="color:#ef4444;">O(n)</td></tr>
      </table>
      <div class="key-idea" style="margin-top:0.75rem;">
        <h3>Key Takeaway</h3>
        <p style="font-size:0.88rem;">Trees organize data <strong>hierarchically</strong>. BSTs give O(log n) search/insert/delete — but only when <strong>balanced</strong>.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS22');
  const ctx=canvas.getContext('2d');

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const sx=15;
    // Tree fundamentals
    ctx.fillStyle='#e2e8f0';ctx.font='bold 13px monospace';ctx.textAlign='left';
    ctx.fillText('TREE FUNDAMENTALS',sx,20);
    ctx.fillStyle='#cbd5e1';ctx.font='11px monospace';
    ctx.fillText('Tree: hierarchical, n nodes, n-1 edges',sx,40);
    ctx.fillText('Binary Tree: at most 2 children per node',sx,56);
    ctx.fillText('BST: left < node < right (all subtrees!)',sx,72);

    // Types
    ctx.fillStyle='#e2e8f0';ctx.font='bold 12px monospace';
    ctx.fillText('BINARY TREE TYPES',sx,100);
    const types=[['Full','0 or 2 children','#38bdf8'],['Complete','Levels filled L→R','#f59e0b'],['Perfect','All leaves same depth','#22c55e']];
    for(let i=0;i<3;i++){
      const x=sx+i*170,y=112;
      ctx.fillStyle=types[i][2]+'22';ctx.strokeStyle=types[i][2];ctx.lineWidth=1.5;
      ctx.beginPath();ctx.roundRect(x,y,158,40,6);ctx.fill();ctx.stroke();
      ctx.fillStyle=types[i][2];ctx.font='bold 11px monospace';ctx.textAlign='center';
      ctx.fillText(types[i][0],x+79,y+16);
      ctx.fillStyle='#94a3b8';ctx.font='9px monospace';
      ctx.fillText(types[i][1],x+79,y+32);
    }

    // BST Operations
    ctx.textAlign='left';
    ctx.fillStyle='#e2e8f0';ctx.font='bold 12px monospace';
    ctx.fillText('BST OPERATIONS',sx,175);
    ctx.fillStyle='#cbd5e1';ctx.font='11px monospace';
    ctx.fillText('Search: compare, go left/right → O(h)',sx,195);
    ctx.fillText('Insert: search + add leaf       → O(h)',sx,211);
    ctx.fillText('Delete: 3 cases:',sx,227);
    ctx.fillStyle='#22c55e';ctx.fillText('  Leaf → remove',sx,243);
    ctx.fillStyle='#f59e0b';ctx.fillText('  One child → bypass',sx+160,243);
    ctx.fillStyle='#ef4444';ctx.fillText('  Two children → inorder successor',sx,259);

    // Properties
    ctx.fillStyle='#e2e8f0';ctx.font='bold 12px monospace';
    ctx.fillText('PROPERTIES',sx,290);
    const props=[['Max nodes at depth d','2^d'],['Max total nodes (h)','2^(h+1) - 1'],['Min height (n nodes)','⌊log₂ n⌋'],['Edges','n - 1']];
    for(let i=0;i<props.length;i++){
      const y=305+i*20;
      ctx.fillStyle='#94a3b8';ctx.font='11px monospace';ctx.textAlign='left';
      ctx.fillText(props[i][0],sx,y);
      ctx.fillStyle='#f59e0b';ctx.textAlign='right';
      ctx.fillText(props[i][1],canvas.width-20,y);
    }
  }

  const obs=new MutationObserver(()=>{if(document.getElementById('s22').classList.contains('active'))draw();});
  obs.observe(document.getElementById('s22'),{attributes:true,attributeFilter:['class']});
  draw();
})();
</script>

<!-- ============================================================ -->
<!-- QUIZ 1: Multi-Question Quiz -->
<!-- ============================================================ -->
<div class="slide fade-in" id="sQ1">
  <h2>Quiz: Tree Fundamentals</h2>
  <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:1rem;margin-top:1rem;">
    <div style="background:rgba(0,0,0,0.2);border-radius:10px;padding:1rem;">
      <h3 style="color:#38bdf8;font-size:0.85rem;">Q1: Node Count</h3>
      <p style="font-size:0.82rem;color:#94a3b8;">A perfect binary tree of height 3 has how many nodes?</p>
      <div style="margin-top:0.5rem;">
        <label style="display:block;padding:0.3rem;cursor:pointer;font-size:0.82rem;color:#cbd5e1;"><input type="radio" name="sQ1q1" value="a"> 7</label>
        <label style="display:block;padding:0.3rem;cursor:pointer;font-size:0.82rem;color:#cbd5e1;"><input type="radio" name="sQ1q1" value="b"> 8</label>
        <label style="display:block;padding:0.3rem;cursor:pointer;font-size:0.82rem;color:#cbd5e1;"><input type="radio" name="sQ1q1" value="c"> 15</label>
        <label style="display:block;padding:0.3rem;cursor:pointer;font-size:0.82rem;color:#cbd5e1;"><input type="radio" name="sQ1q1" value="d"> 16</label>
      </div>
      <div id="sQ1f1" style="font-size:0.78rem;margin-top:0.3rem;"></div>
    </div>
    <div style="background:rgba(0,0,0,0.2);border-radius:10px;padding:1rem;">
      <h3 style="color:#38bdf8;font-size:0.85rem;">Q2: Traversal</h3>
      <p style="font-size:0.82rem;color:#94a3b8;">Which traversal gives sorted output from a BST?</p>
      <div style="margin-top:0.5rem;">
        <label style="display:block;padding:0.3rem;cursor:pointer;font-size:0.82rem;color:#cbd5e1;"><input type="radio" name="sQ1q2" value="a"> Preorder</label>
        <label style="display:block;padding:0.3rem;cursor:pointer;font-size:0.82rem;color:#cbd5e1;"><input type="radio" name="sQ1q2" value="b"> Inorder</label>
        <label style="display:block;padding:0.3rem;cursor:pointer;font-size:0.82rem;color:#cbd5e1;"><input type="radio" name="sQ1q2" value="c"> Postorder</label>
        <label style="display:block;padding:0.3rem;cursor:pointer;font-size:0.82rem;color:#cbd5e1;"><input type="radio" name="sQ1q2" value="d"> Level-order</label>
      </div>
      <div id="sQ1f2" style="font-size:0.78rem;margin-top:0.3rem;"></div>
    </div>
    <div style="background:rgba(0,0,0,0.2);border-radius:10px;padding:1rem;">
      <h3 style="color:#38bdf8;font-size:0.85rem;">Q3: BST Delete</h3>
      <p style="font-size:0.82rem;color:#94a3b8;">Deleting a node with two children requires finding the:</p>
      <div style="margin-top:0.5rem;">
        <label style="display:block;padding:0.3rem;cursor:pointer;font-size:0.82rem;color:#cbd5e1;"><input type="radio" name="sQ1q3" value="a"> Parent node</label>
        <label style="display:block;padding:0.3rem;cursor:pointer;font-size:0.82rem;color:#cbd5e1;"><input type="radio" name="sQ1q3" value="b"> Inorder successor</label>
        <label style="display:block;padding:0.3rem;cursor:pointer;font-size:0.82rem;color:#cbd5e1;"><input type="radio" name="sQ1q3" value="c"> Deepest leaf</label>
        <label style="display:block;padding:0.3rem;cursor:pointer;font-size:0.82rem;color:#cbd5e1;"><input type="radio" name="sQ1q3" value="d"> Root node</label>
      </div>
      <div id="sQ1f3" style="font-size:0.78rem;margin-top:0.3rem;"></div>
    </div>
  </div>
  <div style="margin-top:1rem;text-align:center;">
    <button class="btn" onclick="sQ1Check()">Check Answers</button>
    <span id="sQ1Score" style="margin-left:1rem;font-size:1rem;"></span>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const answers={sQ1q1:'c',sQ1q2:'b',sQ1q3:'b'};
  const feedback={
    sQ1q1:{c:'✓ 2^(3+1) − 1 = 15 nodes.',wrong:'✗ Perfect tree: 2^(h+1) − 1 = 2^4 − 1 = 15.'},
    sQ1q2:{b:'✓ Inorder (LNR) visits BST nodes in sorted order.',wrong:'✗ Inorder traversal gives sorted output from a BST.'},
    sQ1q3:{b:'✓ Find the inorder successor (or predecessor), copy, then delete it.',wrong:'✗ Two-children delete uses the inorder successor (smallest in right subtree).'}
  };
  window.sQ1Check = function(){
    let score=0;
    for(const[name,ans] of Object.entries(answers)){
      const sel=document.querySelector('input[name="'+name+'"]:checked');
      const fb=document.getElementById(name.replace('q','f'));
      if(sel&&sel.value===ans){fb.innerHTML='<span style="color:#22c55e;">'+feedback[name][ans]+'</span>';score++;}
      else{fb.innerHTML='<span style="color:#ef4444;">'+feedback[name].wrong+'</span>';}
    }
    document.getElementById('sQ1Score').innerHTML=score===3?'<span style="color:#22c55e;">★ '+score+'/3 Perfect!</span>':'<span style="color:#f59e0b;">'+score+'/3</span>';
  };
})();
</script>

<!-- ============================================================ -->
<!-- QUIZ 2: Trace BST Insert Sequence -->
<!-- ============================================================ -->
<div class="slide fade-in" id="sQ2">
  <h2>Quiz: Build a BST</h2>
  <p>Insert these keys in order: <strong style="color:#f59e0b;">5, 3, 8, 1, 4, 7, 9</strong>. What is the tree's height?</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <canvas id="cQ2" width="520" height="280" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
      <div style="margin-top:0.75rem;">
        <label style="color:#94a3b8;font-size:0.85rem;">Height of the resulting tree:</label>
        <input type="number" id="sQ2ans" placeholder="?" style="width:60px;padding:0.4rem;background:#1e293b;border:1px solid #475569;border-radius:6px;color:#e2e8f0;font-family:monospace;margin-left:0.5rem;">
        <button class="btn btn-sm" onclick="sQ2Check()" style="margin-left:0.5rem;">Check</button>
        <button class="btn btn-sm btn-secondary" onclick="sQ2Build()" style="margin-left:0.5rem;">Show Tree</button>
      </div>
      <div id="sQ2Result" style="margin-top:0.5rem;font-size:0.85rem;"></div>
    </div>
    <div>
      <div style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.75rem;font-family:monospace;font-size:0.85rem;color:#94a3b8;line-height:2;">
        Insert 5: root<br>
        Insert 3: 3 &lt; 5 → left of 5<br>
        Insert 8: 8 &gt; 5 → right of 5<br>
        Insert 1: 1 &lt; 5 → 1 &lt; 3 → left of 3<br>
        Insert 4: 4 &lt; 5 → 4 &gt; 3 → right of 3<br>
        Insert 7: 7 &gt; 5 → 7 &lt; 8 → left of 8<br>
        Insert 9: 9 &gt; 5 → 9 &gt; 8 → right of 8
      </div>
      <div id="sQ2explain" style="display:none;margin-top:0.5rem;background:rgba(0,0,0,0.2);border-radius:8px;padding:0.5rem;font-size:0.82rem;color:#22c55e;"></div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cQ2');
  const ctx=canvas.getContext('2d');
  let root=null,built=false;
  function mkN(v){return{val:v,left:null,right:null};}
  function ins(n,v){if(!n)return mkN(v);if(v<n.val)n.left=ins(n.left,v);else if(v>n.val)n.right=ins(n.right,v);return n;}
  function getH(n){if(!n)return -1;return 1+Math.max(getH(n.left),getH(n.right));}

  function drawN(node,x,y,sp){
    if(!node)return;
    if(node.left){ctx.strokeStyle='#475569';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(x,y+14);ctx.lineTo(x-sp,y+60-14);ctx.stroke();drawN(node.left,x-sp,y+60,sp*0.48);}
    if(node.right){ctx.strokeStyle='#475569';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(x,y+14);ctx.lineTo(x+sp,y+60-14);ctx.stroke();drawN(node.right,x+sp,y+60,sp*0.48);}
    const leaf=!node.left&&!node.right;
    ctx.fillStyle=leaf?'#22c55e':'#6366f1';ctx.strokeStyle=leaf?'#4ade80':'#818cf8';ctx.lineWidth=2;
    ctx.beginPath();ctx.arc(x,y,14,0,Math.PI*2);ctx.fill();ctx.stroke();
    ctx.fillStyle='#fff';ctx.font='bold 12px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
    ctx.fillText(node.val,x,y);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(!built){ctx.fillStyle='#64748b';ctx.font='13px monospace';ctx.textAlign='center';ctx.fillText('Predict the height, then click Show Tree',canvas.width/2,canvas.height/2);return;}
    drawN(root,canvas.width/2,30,120);
    ctx.fillStyle='#94a3b8';ctx.font='11px monospace';ctx.textAlign='center';
    ctx.fillText('height = '+getH(root),canvas.width/2,canvas.height-12);
  }

  window.sQ2Check = function(){
    const ans=parseInt(document.getElementById('sQ2ans').value);
    if(ans===2){
      document.getElementById('sQ2Result').innerHTML='<span style="color:#22c55e;">✓ Correct! Height = 2 (balanced!)</span>';
      s19BuildInternal();
    } else {
      document.getElementById('sQ2Result').innerHTML='<span style="color:#ef4444;">✗ Try building the tree step by step.</span>';
    }
  };

  function s19BuildInternal(){
    root=null;[5,3,8,1,4,7,9].forEach(v=>root=ins(root,v));built=true;draw();
    document.getElementById('sQ2explain').style.display='block';
    document.getElementById('sQ2explain').innerHTML='Height = 2. This is a perfect binary tree! All 7 nodes, all leaves at depth 2.';
  }

  window.sQ2Build = function(){s19BuildInternal();};

  const obs=new MutationObserver(()=>{if(document.getElementById('sQ2').classList.contains('active')){root=null;built=false;document.getElementById('sQ2Result').innerHTML='';document.getElementById('sQ2explain').style.display='none';draw();}});
  obs.observe(document.getElementById('sQ2'),{attributes:true,attributeFilter:['class']});
  draw();
})();
</script>

<!-- ============================================================ -->
<!-- QUIZ 3: Predict Code Output -->
<!-- ============================================================ -->
<div class="slide fade-in" id="sQ3">
  <h2>Quiz: What Does This Print?</h2>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;margin-top:1rem;">
    <div>
      <div class="code-block" style="font-size:0.82rem;">
        <div class="code-content">
          <div class="line" id="sQ3L1">void mystery(Node n) {</div>
          <div class="line" id="sQ3L2">  if (n == null) return;</div>
          <div class="line" id="sQ3L3">  mystery(n.left);</div>
          <div class="line" id="sQ3L4">  mystery(n.right);</div>
          <div class="line" id="sQ3L5">  System.out.print(n.val + " ");</div>
          <div class="line" id="sQ3L6">}</div>
        </div>
      </div>
      <p style="font-size:0.88rem;color:#cbd5e1;margin-top:0.75rem;">Called on this BST:</p>
      <canvas id="cQ3tree" width="260" height="140" style="background:rgba(0,0,0,0.15);border-radius:8px;display:block;"></canvas>
      <div style="margin-top:0.75rem;">
        <label style="color:#94a3b8;font-size:0.85rem;">Output:</label>
        <input type="text" id="sQ3ans" placeholder="e.g. 1 3 6 ..." style="width:100%;padding:0.4rem;background:#1e293b;border:1px solid #475569;border-radius:6px;color:#e2e8f0;font-family:monospace;font-size:0.85rem;margin-top:0.4rem;">
        <div style="display:flex;gap:0.5rem;margin-top:0.5rem;">
          <button class="btn btn-sm" onclick="sQ3Check()">Check</button>
          <button class="btn btn-sm btn-secondary" onclick="sQ3Trace()">Show Trace</button>
        </div>
        <div id="sQ3Result" style="margin-top:0.5rem;font-size:0.85rem;"></div>
      </div>
    </div>
    <div>
      <canvas id="cQ3" width="520" height="300" style="width:100%;background:rgba(0,0,0,0.2);border-radius:12px;"></canvas>
      <div id="sQ3Log" style="background:rgba(0,0,0,0.25);border-radius:8px;padding:0.6rem;font-family:monospace;font-size:0.75rem;max-height:120px;overflow-y:auto;margin-top:0.5rem;color:#94a3b8;"></div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  // BST: 10(5(2,7),15(12,20))
  const treeCanvas=document.getElementById('cQ3tree');
  const tctx=treeCanvas.getContext('2d');
  const nodes=[{v:10,x:130,y:22},{v:5,x:65,y:70},{v:15,x:195,y:70},{v:2,x:35,y:118},{v:7,x:95,y:118},{v:12,x:165,y:118},{v:20,x:225,y:118}];
  const edges=[[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]];
  function drawSmall(){
    tctx.clearRect(0,0,260,140);
    for(const[a,b] of edges){tctx.strokeStyle='#475569';tctx.lineWidth=1.5;tctx.beginPath();tctx.moveTo(nodes[a].x,nodes[a].y+10);tctx.lineTo(nodes[b].x,nodes[b].y-10);tctx.stroke();}
    for(const n of nodes){tctx.fillStyle='#6366f1';tctx.strokeStyle='#818cf8';tctx.lineWidth=1.5;tctx.beginPath();tctx.arc(n.x,n.y,10,0,Math.PI*2);tctx.fill();tctx.stroke();tctx.fillStyle='#fff';tctx.font='bold 10px monospace';tctx.textAlign='center';tctx.textBaseline='middle';tctx.fillText(n.v,n.x,n.y);}
  }

  const bigCanvas=document.getElementById('cQ3');
  const ctx=bigCanvas.getContext('2d');
  const bigPos=[{v:10,x:260,y:35},{v:5,x:130,y:110},{v:15,x:390,y:110},{v:2,x:65,y:190},{v:7,x:195,y:190},{v:12,x:325,y:190},{v:20,x:455,y:190}];
  const bigEdges=[[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]];
  // mystery is postorder: 2 7 5 12 20 15 10
  const answer='2 7 5 12 20 15 10';
  const traceSteps=[
    {visit:3,msg:'mystery(2): leaf → print 2'},
    {visit:4,msg:'mystery(7): leaf → print 7'},
    {visit:1,msg:'mystery(5): children done → print 5'},
    {visit:5,msg:'mystery(12): leaf → print 12'},
    {visit:6,msg:'mystery(20): leaf → print 20'},
    {visit:2,msg:'mystery(15): children done → print 15'},
    {visit:0,msg:'mystery(10): children done → print 10'}
  ];
  let visited=[],traceIdx=0,timer=null;

  function drawBig(){
    ctx.clearRect(0,0,bigCanvas.width,bigCanvas.height);
    for(const[a,b] of bigEdges){ctx.strokeStyle='#475569';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(bigPos[a].x,bigPos[a].y+16);ctx.lineTo(bigPos[b].x,bigPos[b].y-16);ctx.stroke();}
    for(let i=0;i<bigPos.length;i++){
      const p=bigPos[i];const vi=visited.indexOf(i);const isCurr=vi===visited.length-1&&visited.length>0;
      ctx.fillStyle=isCurr?'#f59e0b':vi>=0?'#22c55e':'#6366f1';
      ctx.strokeStyle=isCurr?'#fbbf24':vi>=0?'#4ade80':'#818cf8';ctx.lineWidth=isCurr?3:2;
      ctx.beginPath();ctx.arc(p.x,p.y,16,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.fillStyle='#fff';ctx.font='bold 13px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(p.v,p.x,p.y);
      if(vi>=0){ctx.fillStyle='#f59e0b';ctx.font='bold 10px monospace';ctx.fillText('⓪①②③④⑤⑥⑦'[vi+1],p.x,p.y+28);}
    }
    // output so far
    const output=visited.map(i=>bigPos[i].v).join(' ');
    if(output){
      ctx.fillStyle='#f59e0b';ctx.font='bold 13px monospace';ctx.textAlign='center';
      ctx.fillText('Output: '+output,bigCanvas.width/2,bigCanvas.height-15);
    }
  }

  function log(m){document.getElementById('sQ3Log').innerHTML+='<div>'+m+'</div>';document.getElementById('sQ3Log').scrollTop=9999;}

  window.sQ3Check = function(){
    const ans=document.getElementById('sQ3ans').value.trim().replace(/[,→\->/]+/g,' ').replace(/\s+/g,' ');
    if(ans===answer){
      document.getElementById('sQ3Result').innerHTML='<span style="color:#22c55e;">✓ Correct! It\'s postorder (LRN).</span>';
    } else {
      document.getElementById('sQ3Result').innerHTML='<span style="color:#ef4444;">✗ Look at the code: left, right, then print. That\'s postorder!</span>';
    }
  };

  window.sQ3Trace = function(){
    if(timer)return;
    visited=[];traceIdx=0;document.getElementById('sQ3Log').innerHTML='';
    timer=setInterval(()=>{
      if(traceIdx>=traceSteps.length){clearInterval(timer);timer=null;log('<span style="color:#22c55e">✓ Postorder: '+answer+'</span>');return;}
      const s=traceSteps[traceIdx];
      visited.push(s.visit);log(s.msg);drawBig();traceIdx++;
    },800);
  };

  const obs=new MutationObserver(()=>{
    if(document.getElementById('sQ3').classList.contains('active')){
      visited=[];traceIdx=0;if(timer){clearInterval(timer);timer=null;}
      document.getElementById('sQ3Log').innerHTML='';document.getElementById('sQ3Result').innerHTML='';
      drawSmall();drawBig();
    } else{if(timer){clearInterval(timer);timer=null;}}
  });
  obs.observe(document.getElementById('sQ3'),{attributes:true,attributeFilter:['class']});
  drawSmall();drawBig();
})();
</script>

<!-- ==================== NAVIGATION ==================== -->
<div class="nav">
  <button id="prevBtn" onclick="navigate(-1)">&larr; Prev</button>
  <button id="nextBtn" onclick="navigate(1)">Next &rarr;</button>
</div>

<!-- ==================== NAVIGATION JS ==================== -->
<script>
const slideOrder = ['s1','s2','s3','s4','s5','s6','s7','s8','s9','s10','s11','s12','s13','s14','s15','s16','s17','s18','sCA','s19','sCB','s20','sCC','s21','s22','sQ1','sQ2','sQ3'];
let currentIdx = 0;

function showSlide(idx) {
  slideOrder.forEach(id => document.getElementById(id).classList.remove('active'));
  const slideEl = document.getElementById(slideOrder[idx]);
  slideEl.classList.add('active');
  slideEl.classList.remove('fade-in');
  void slideEl.offsetWidth;
  slideEl.classList.add('fade-in');
  document.getElementById('prevBtn').disabled = (idx === 0);
  document.getElementById('nextBtn').disabled = (idx === slideOrder.length - 1);
  const pct = slideOrder.length > 1 ? (idx / (slideOrder.length - 1)) * 100 : 0;
  document.getElementById('progress').style.width = pct + '%';
}

function navigate(dir) {
  const next = currentIdx + dir;
  if (next >= 0 && next < slideOrder.length) {
    currentIdx = next;
    showSlide(currentIdx);
  }
}

document.addEventListener('keydown', (e) => {
  const tag = document.activeElement.tagName;
  if (tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA') return;
  if (e.key === 'ArrowRight') navigate(1);
  if (e.key === 'ArrowLeft') navigate(-1);
});

showSlide(0);
</script>
</body>
</html>
