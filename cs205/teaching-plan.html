<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CS205 Data Structures — Teaching Plan</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:'Segoe UI',system-ui,-apple-system,sans-serif;background:#0f172a;color:#e2e8f0;overflow:hidden}
.slide{display:none;min-height:100vh;padding:40px 60px;position:relative;flex-direction:column;justify-content:center}
.slide.active{display:flex}
.fade-in{animation:fadeIn .5s ease}
@keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
#progress-bar{position:fixed;top:0;left:0;width:100%;height:3px;background:rgba(255,255,255,0.08);z-index:200}
#progress{height:100%;width:0;background:linear-gradient(90deg,#6366f1,#8b5cf6,#a78bfa);transition:width .3s}
h1{font-size:2.6em;margin-bottom:16px;background:linear-gradient(135deg,#38bdf8,#818cf8);-webkit-background-clip:text;-webkit-text-fill-color:transparent;line-height:1.2}
h2{font-size:1.9em;margin-bottom:14px;color:#38bdf8}
h3{font-size:1.2em;margin-bottom:8px;color:#a78bfa}
h4{font-size:1em;margin-bottom:6px;color:#f59e0b}
p,li{font-size:1.05em;line-height:1.65;color:#cbd5e1;margin-bottom:6px}
ul{padding-left:20px}
ol{padding-left:20px}
code{background:#1e293b;padding:2px 6px;border-radius:4px;font-family:monospace;color:#a5f3fc;font-size:.9em}
.subtitle{font-size:1.2em;color:#94a3b8;margin-bottom:20px}
.unit-badge{display:inline-block;padding:3px 10px;border-radius:12px;font-size:.75em;font-weight:700;margin-right:6px;vertical-align:middle}
.u1{background:rgba(99,102,241,.2);color:#818cf8;border:1px solid #6366f1}
.u2{background:rgba(34,197,94,.2);color:#4ade80;border:1px solid #22c55e}
.u3{background:rgba(245,158,11,.2);color:#fbbf24;border:1px solid #f59e0b}
.u4{background:rgba(244,114,182,.2);color:#f472b6;border:1px solid #ec4899}
.u5{background:rgba(56,189,248,.2);color:#38bdf8;border:1px solid #0ea5e9}
.u6{background:rgba(167,139,250,.2);color:#a78bfa;border:1px solid #8b5cf6}
.card{background:#1e293b;border:1px solid #334155;border-radius:12px;padding:14px 16px;margin:6px 0}
.card-highlight{border-left:4px solid #6366f1}
.card-warn{border-left:4px solid #f59e0b}
.card-tip{border-left:4px solid #22c55e}
.card-demo{border-left:4px solid #a78bfa}
.tag{display:inline-block;padding:2px 8px;border-radius:6px;font-size:.72em;font-weight:600;margin:2px}
.tag-demo{background:rgba(167,139,250,.2);color:#a78bfa}
.tag-discuss{background:rgba(56,189,248,.2);color:#38bdf8}
.tag-exercise{background:rgba(34,197,94,.2);color:#4ade80}
.tag-time{background:rgba(245,158,11,.2);color:#fbbf24}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:1.2rem;margin-top:.5rem}
.grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:1rem;margin-top:.5rem}
.slide-number{position:absolute;bottom:20px;right:40px;color:#64748b;font-size:14px}
.nav{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);display:flex;gap:12px;z-index:100}
.nav button{background:#334155;border:1px solid #475569;color:#e2e8f0;padding:8px 20px;border-radius:8px;cursor:pointer;font-size:14px;transition:all .2s}
.nav button:hover{background:#475569}
.nav button:disabled{opacity:.3;cursor:not-allowed}
.timeline{position:relative;padding-left:24px;border-left:2px solid #334155}
.timeline-item{position:relative;padding-bottom:12px}
.timeline-item::before{content:'';position:absolute;left:-29px;top:6px;width:10px;height:10px;border-radius:50%;background:#6366f1;border:2px solid #818cf8}
.week-num{display:inline-block;background:#6366f1;color:#fff;font-size:.7em;font-weight:700;padding:2px 8px;border-radius:8px;margin-right:6px}
small{font-size:.82em;color:#94a3b8}
</style>
</head>
<body>
<div id="progress-bar"><div id="progress"></div></div>

<!-- ========== SLIDE 1: Title ========== -->
<div class="slide active" id="s1">
  <div style="text-align:center;">
    <h1>CS205 Data Structures</h1>
    <p class="subtitle">Complete Teaching Plan & Lecture Notes</p>
    <div style="display:flex;flex-wrap:wrap;justify-content:center;gap:10px;margin:24px 0;">
      <span class="unit-badge u1">Unit 1 — Linear Structures</span>
      <span class="unit-badge u2">Unit 2 — Analysis & Recursion</span>
      <span class="unit-badge u3">Unit 3 — Priority Structures</span>
      <span class="unit-badge u4">Unit 4 — Associative Structures</span>
      <span class="unit-badge u5">Unit 5 — Trees</span>
      <span class="unit-badge u6">Unit 6 — Graphs</span>
    </div>
    <div style="background:#1e293b;border-radius:12px;padding:20px;max-width:600px;margin:0 auto;">
      <p style="font-size:1.1em;color:#e2e8f0;"><strong>15 Enhanced Slide Decks</strong> &nbsp;|&nbsp; <strong>370+ Interactive Slides</strong></p>
      <p style="color:#94a3b8;font-size:.9em;margin-top:8px;">Each deck includes Canvas visualizations, step-through animations, playgrounds, and challenge quizzes.</p>
    </div>
    <p style="color:#64748b;font-size:.9em;margin-top:20px;">Use arrow keys or buttons to navigate</p>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ========== SLIDE 2: Semester Overview ========== -->
<div class="slide" id="s2">
  <h2>Semester at a Glance</h2>
  <div class="grid2">
    <div>
      <div class="timeline">
        <div class="timeline-item">
          <span class="week-num">W1-2</span> <strong>Linked Lists</strong> <small>(27 slides)</small>
          <p style="font-size:.85em;">Singly linked list: nodes, traversal, insert/delete, time complexity</p>
        </div>
        <div class="timeline-item">
          <span class="week-num">W3</span> <strong>Algorithm Analysis</strong> <small>(24 slides)</small>
          <p style="font-size:.85em;">Big-O, growth rates, best/worst/average case, empirical analysis</p>
        </div>
        <div class="timeline-item">
          <span class="week-num">W4</span> <strong>Recursion</strong> <small>(24 slides)</small>
          <p style="font-size:.85em;">Base/recursive cases, call stack, tail recursion, divide & conquer</p>
        </div>
        <div class="timeline-item">
          <span class="week-num">W5</span> <strong>Stacks</strong> <small>(23 slides)</small>
          <p style="font-size:.85em;">LIFO, array/linked implementations, parentheses matching, postfix eval</p>
        </div>
        <div class="timeline-item">
          <span class="week-num">W6</span> <strong>Queues</strong> <small>(23 slides)</small>
          <p style="font-size:.85em;">FIFO, circular array, linked implementation, BFS preview, deque</p>
        </div>
        <div class="timeline-item">
          <span class="week-num">W7</span> <strong>ArrayLists / NodeLists</strong> <small>(23 slides)</small>
          <p style="font-size:.85em;">Dynamic arrays, amortized analysis, positional lists, iterators</p>
        </div>
        <div class="timeline-item">
          <span class="week-num">W8</span> <strong style="color:#f59e0b;">Midterm Review</strong>
          <p style="font-size:.85em;">Units 1-2 assessment: linked lists through array lists</p>
        </div>
      </div>
    </div>
    <div>
      <div class="timeline">
        <div class="timeline-item">
          <span class="week-num">W9</span> <strong>Priority Queues</strong> <small>(24 slides)</small>
          <p style="font-size:.85em;">PQ ADT, sorted/unsorted list implementations, comparators</p>
        </div>
        <div class="timeline-item">
          <span class="week-num">W10</span> <strong>Heaps</strong> <small>(26 slides)</small>
          <p style="font-size:.85em;">Binary heap, array representation, upheap/downheap, heapsort</p>
        </div>
        <div class="timeline-item">
          <span class="week-num">W11</span> <strong>Maps & Hash Tables</strong> <small>(22+26 slides)</small>
          <p style="font-size:.85em;">Map ADT, hash functions, collision handling, load factor, rehashing</p>
        </div>
        <div class="timeline-item">
          <span class="week-num">W12</span> <strong>Trees</strong> <small>(28 slides)</small>
          <p style="font-size:.85em;">Binary trees, BST, traversals, balanced trees (AVL preview)</p>
        </div>
        <div class="timeline-item">
          <span class="week-num">W13</span> <strong>Graphs</strong> <small>(26 slides)</small>
          <p style="font-size:.85em;">Graph terminology, representations, adjacency matrix/list</p>
        </div>
        <div class="timeline-item">
          <span class="week-num">W14</span> <strong>BFS & DFS</strong> <small>(24+23 slides)</small>
          <p style="font-size:.85em;">Traversal algorithms, applications, edge classification, topological sort</p>
        </div>
        <div class="timeline-item">
          <span class="week-num">W15</span> <strong>Shortest Path</strong> <small>(24 slides)</small>
          <p style="font-size:.85em;">Dijkstra's, Bellman-Ford, negative cycles, applications</p>
        </div>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ========== SLIDE 3: How to Use the Enhanced Decks ========== -->
<div class="slide" id="s3">
  <h2>How to Use the Enhanced Decks</h2>
  <div class="grid2">
    <div>
      <h3>Lecture Flow Pattern</h3>
      <div class="card card-highlight">
        <h4>1. Concept Introduction (static slides)</h4>
        <p style="font-size:.85em;">Present the concept with text, analogies, and key-idea boxes. Let students read and absorb.</p>
      </div>
      <div class="card card-demo">
        <h4>2. Live Demo (interactive slides)</h4>
        <p style="font-size:.85em;">Step through the algorithm on Canvas. Use "Step" button for manual pace, "Auto Play" to show the full flow. Reset and re-run for emphasis.</p>
      </div>
      <div class="card card-tip">
        <h4>3. Student Challenge (inline quizzes)</h4>
        <p style="font-size:.85em;">Pause at sCA/sCB/sCC slides. Give students 2-3 minutes to predict, then reveal. Great for think-pair-share.</p>
      </div>
      <div class="card card-warn">
        <h4>4. Final Assessment (sQ1-sQ3)</h4>
        <p style="font-size:.85em;">Use as exit ticket or start of next class. sQ1 = quick check, sQ2 = trace, sQ3 = code prediction.</p>
      </div>
    </div>
    <div>
      <h3>Interactive Element Types</h3>
      <div class="card">
        <span class="tag tag-demo">Step-Through</span>
        <p style="font-size:.85em;margin-top:4px;">Algorithm animations with Step / Auto / Reset. Code lines highlight in sync with Canvas.</p>
      </div>
      <div class="card">
        <span class="tag tag-demo">Playground</span>
        <p style="font-size:.85em;margin-top:4px;">Students input values and watch operations animate. Great for "what if" exploration.</p>
      </div>
      <div class="card">
        <span class="tag tag-discuss">Comparison Toggle</span>
        <p style="font-size:.85em;margin-top:4px;">Side-by-side or toggle views (e.g., BFS vs DFS, sorted vs unsorted PQ). Ask "when would you pick each?"</p>
      </div>
      <div class="card">
        <span class="tag tag-exercise">Challenge Slides</span>
        <p style="font-size:.85em;margin-top:4px;">sCA = Predict/Trace, sCB = Fix the Bug, sCC = Decision Scenario. Interleaved after teaching sections.</p>
      </div>
      <h3 style="margin-top:14px;">Keyboard Tips</h3>
      <ul style="font-size:.85em;">
        <li>Arrow keys navigate slides (disabled when input focused)</li>
        <li>All decks are self-contained HTML — open in any browser</li>
        <li>Resize browser for different projector resolutions</li>
      </ul>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ========== SLIDE 4: Unit 1 — Linked Lists ========== -->
<div class="slide" id="s4">
  <h2><span class="unit-badge u1">Unit 1</span> Linked Lists</h2>
  <p><code>linked-list-enhanced.html</code> &nbsp;|&nbsp; 27 slides &nbsp;|&nbsp; <span class="tag tag-time">~75 min</span></p>
  <div class="grid2" style="margin-top:.5rem;">
    <div>
      <h3>Learning Objectives</h3>
      <ol style="font-size:.9em;">
        <li>Understand node-based storage vs contiguous arrays</li>
        <li>Implement insert/delete at head, tail, and middle</li>
        <li>Trace pointer manipulation step-by-step</li>
        <li>Analyze O(1) insert-at-head vs O(n) search</li>
      </ol>
      <h3 style="margin-top:12px;">Key Demos to Run</h3>
      <div class="card card-demo">
        <span class="tag tag-demo">Step-Through</span> <strong>Insert at Head / Tail</strong>
        <p style="font-size:.82em;">Show pointer rewiring. Pause after each step — ask "which pointer changes first and why?"</p>
      </div>
      <div class="card card-demo">
        <span class="tag tag-demo">Playground</span> <strong>Interactive Insert/Delete/Search</strong>
        <p style="font-size:.82em;">Let students call out values to insert. Then ask them to predict what happens on delete.</p>
      </div>
    </div>
    <div>
      <h3>Common Misconceptions</h3>
      <div class="card card-warn">
        <h4>Order of pointer updates matters!</h4>
        <p style="font-size:.82em;">If you update <code>head = newNode</code> before <code>newNode.next = head</code>, you lose the list. Demo this with the step-through to make it visceral.</p>
      </div>
      <div class="card card-warn">
        <h4>Linked list ≠ faster than array</h4>
        <p style="font-size:.82em;">Students assume linked lists are "better." Emphasize: O(n) search, no random access, extra memory per node. Arrays win on cache locality.</p>
      </div>
      <h3 style="margin-top:12px;">Discussion Questions</h3>
      <ul style="font-size:.85em;">
        <li>"When would you choose a linked list over an array?"</li>
        <li>"Why does Java's LinkedList implement both List and Deque?"</li>
        <li>"What happens if you forget to update the tail pointer on delete-last?"</li>
      </ul>
      <h3 style="margin-top:12px;">Challenge Slides</h3>
      <p style="font-size:.85em;"><span class="tag tag-exercise">sCA</span> Predict final list after operations &nbsp; <span class="tag tag-exercise">sCB</span> Find the null-pointer bug &nbsp; <span class="tag tag-exercise">sCC</span> Array vs Linked List scenarios</p>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ========== SLIDE 5: Unit 2A — Algorithm Analysis ========== -->
<div class="slide" id="s5">
  <h2><span class="unit-badge u2">Unit 2</span> Algorithm Analysis</h2>
  <p><code>algorithm-analysis-enhanced.html</code> &nbsp;|&nbsp; 24 slides &nbsp;|&nbsp; <span class="tag tag-time">~65 min</span></p>
  <div class="grid2" style="margin-top:.5rem;">
    <div>
      <h3>Learning Objectives</h3>
      <ol style="font-size:.9em;">
        <li>Distinguish O, Ω, Θ notations with formal definitions</li>
        <li>Rank common growth rates: O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ)</li>
        <li>Analyze loops to derive Big-O</li>
        <li>Understand best/worst/average case</li>
      </ol>
      <h3 style="margin-top:12px;">Key Demos to Run</h3>
      <div class="card card-demo">
        <span class="tag tag-demo">Growth Rate Race</span>
        <p style="font-size:.82em;">Animated bar chart showing how functions grow as n increases. Students are always shocked how fast 2ⁿ explodes.</p>
      </div>
      <div class="card card-demo">
        <span class="tag tag-demo">Loop Counter</span>
        <p style="font-size:.82em;">Step through nested loops, watch the operation counter. Ask "what happens if we double n?"</p>
      </div>
    </div>
    <div>
      <h3>Common Misconceptions</h3>
      <div class="card card-warn">
        <h4>O(n) means "exactly n operations"</h4>
        <p style="font-size:.82em;">Emphasize: Big-O is an upper bound on growth <em>rate</em>, not exact count. 3n+5 is still O(n).</p>
      </div>
      <div class="card card-warn">
        <h4>Confusing O, Ω, and Θ</h4>
        <p style="font-size:.82em;">Use the sandwich analogy: Θ = tight fit, O = ceiling, Ω = floor. The interactive slide lets students toggle between them.</p>
      </div>
      <h3 style="margin-top:12px;">Teaching Tips</h3>
      <ul style="font-size:.85em;">
        <li>Start with concrete examples before formal definitions</li>
        <li>Use the "doubling test": if n doubles, how does time change?</li>
        <li>Have students guess complexity before revealing — builds intuition</li>
        <li>Relate back to linked list: "now we can formally say insert-at-head is O(1)"</li>
      </ul>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ========== SLIDE 6: Unit 2B — Recursion ========== -->
<div class="slide" id="s6">
  <h2><span class="unit-badge u2">Unit 2</span> Recursion</h2>
  <p><code>recursion-enhanced.html</code> &nbsp;|&nbsp; 24 slides &nbsp;|&nbsp; <span class="tag tag-time">~70 min</span></p>
  <div class="grid2" style="margin-top:.5rem;">
    <div>
      <h3>Learning Objectives</h3>
      <ol style="font-size:.9em;">
        <li>Identify base case and recursive case</li>
        <li>Trace the call stack for factorial, Fibonacci, etc.</li>
        <li>Understand stack overflow and tail recursion</li>
        <li>Apply recursion to divide-and-conquer problems</li>
      </ol>
      <h3 style="margin-top:12px;">Key Demos to Run</h3>
      <div class="card card-demo">
        <span class="tag tag-demo">Call Stack Visualizer</span>
        <p style="font-size:.82em;">Step through factorial(5) watching frames push/pop. Code lines highlight in sync. This is the "aha moment" slide.</p>
      </div>
      <div class="card card-demo">
        <span class="tag tag-demo">Fibonacci Tree</span>
        <p style="font-size:.82em;">Watch the recursion tree grow exponentially. Visually devastating — perfect for motivating memoization later.</p>
      </div>
    </div>
    <div>
      <h3>Common Misconceptions</h3>
      <div class="card card-warn">
        <h4>"Recursion is just a loop"</h4>
        <p style="font-size:.82em;">Show the call stack — each call has its OWN variables. The stack visualizer makes this click. Then show problems that are natural for recursion but awkward with loops (tree traversal).</p>
      </div>
      <div class="card card-warn">
        <h4>Forgetting the base case</h4>
        <p style="font-size:.82em;">Demo what happens without a base case — stack overflow. Use the "Fix the Bug" challenge slide.</p>
      </div>
      <h3 style="margin-top:12px;">Teaching Sequence</h3>
      <ol style="font-size:.85em;">
        <li>Start with factorial — simplest recursive structure</li>
        <li>Show call stack animation — build mental model</li>
        <li>Move to Fibonacci — introduce overlapping subproblems</li>
        <li>Tower of Hanoi — recursion as problem decomposition</li>
        <li>Binary search — connect to real algorithm</li>
      </ol>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ========== SLIDE 7: Unit 1B — Stacks ========== -->
<div class="slide" id="s7">
  <h2><span class="unit-badge u1">Unit 1</span> Stacks</h2>
  <p><code>stacks-enhanced.html</code> &nbsp;|&nbsp; 23 slides &nbsp;|&nbsp; <span class="tag tag-time">~55 min</span></p>
  <div class="grid2" style="margin-top:.5rem;">
    <div>
      <h3>Learning Objectives</h3>
      <ol style="font-size:.9em;">
        <li>Understand LIFO principle and ADT operations</li>
        <li>Implement with array and linked list</li>
        <li>Apply to parentheses matching and postfix evaluation</li>
        <li>Connect to recursion (call stack is a stack!)</li>
      </ol>
      <h3 style="margin-top:12px;">Key Demos</h3>
      <div class="card card-demo">
        <span class="tag tag-demo">Parentheses Matcher</span>
        <p style="font-size:.82em;">Type an expression — watch stack push on '(' and pop on ')'. Try unbalanced cases. Students love seeing it fail on "{[}]".</p>
      </div>
      <div class="card card-demo">
        <span class="tag tag-demo">Postfix Evaluator</span>
        <p style="font-size:.82em;">Step through "3 4 + 2 *" — watch operands push and operators pop two + push result. Great for "trace the stack" exercises.</p>
      </div>
    </div>
    <div>
      <h3>Teaching Connection</h3>
      <div class="card card-tip">
        <h4>Bridge from Recursion</h4>
        <p style="font-size:.82em;">"Remember the call stack from last week? That IS a stack. Now we're building the data structure explicitly." This callback makes stacks feel motivated rather than arbitrary.</p>
      </div>
      <h3 style="margin-top:12px;">Discussion Questions</h3>
      <ul style="font-size:.85em;">
        <li>"Your browser's back button — stack or queue?"</li>
        <li>"Undo/redo uses two stacks. How?"</li>
        <li>"Why is array-based stack typically preferred over linked list?"</li>
      </ul>
      <h3 style="margin-top:12px;">Common Pitfalls</h3>
      <div class="card card-warn">
        <h4>Stack underflow</h4>
        <p style="font-size:.82em;">Students forget to check isEmpty() before pop(). Use the challenge slide to show this bug.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ========== SLIDE 8: Unit 1C — Queues ========== -->
<div class="slide" id="s8">
  <h2><span class="unit-badge u1">Unit 1</span> Queues</h2>
  <p><code>queues-enhanced.html</code> &nbsp;|&nbsp; 23 slides &nbsp;|&nbsp; <span class="tag tag-time">~55 min</span></p>
  <div class="grid2" style="margin-top:.5rem;">
    <div>
      <h3>Learning Objectives</h3>
      <ol style="font-size:.9em;">
        <li>Understand FIFO principle and ADT operations</li>
        <li>Implement circular array queue (wrap-around)</li>
        <li>Contrast with stack applications</li>
        <li>Preview BFS as a queue-based algorithm</li>
      </ol>
      <h3 style="margin-top:12px;">Key Demos</h3>
      <div class="card card-demo">
        <span class="tag tag-demo">Circular Array</span>
        <p style="font-size:.82em;">Watch front/rear pointers wrap around. Enqueue until full, then dequeue — the "circular" nature becomes obvious visually.</p>
      </div>
      <div class="card card-demo">
        <span class="tag tag-demo">Stack vs Queue Race</span>
        <p style="font-size:.82em;">Same input, different order. Students see LIFO vs FIFO side-by-side. Ask "which is better for a printer queue?"</p>
      </div>
    </div>
    <div>
      <h3>Teaching Connection</h3>
      <div class="card card-tip">
        <h4>Stack vs Queue Comparison</h4>
        <p style="font-size:.82em;">Teach queues immediately after stacks. The comparison toggle slide is powerful — same operations, opposite behavior. Students remember the contrast better than either in isolation.</p>
      </div>
      <h3 style="margin-top:12px;">Common Misconceptions</h3>
      <div class="card card-warn">
        <h4>Circular array: "full" vs "empty"</h4>
        <p style="font-size:.82em;">Both look like front==rear! Solutions: waste one slot, or use a count variable. Demo both approaches — ask which is better.</p>
      </div>
      <h3 style="margin-top:12px;">Foreshadowing</h3>
      <ul style="font-size:.85em;">
        <li>"We'll see queues again in BFS — the queue determines the traversal order"</li>
        <li>"Priority queues are coming — what if the queue doesn't serve FIFO?"</li>
      </ul>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ========== SLIDE 9: Unit 1D — ArrayLists ========== -->
<div class="slide" id="s9">
  <h2><span class="unit-badge u1">Unit 1</span> ArrayLists / NodeLists</h2>
  <p><code>arraylists-enhanced.html</code> &nbsp;|&nbsp; 23 slides &nbsp;|&nbsp; <span class="tag tag-time">~60 min</span></p>
  <div class="grid2" style="margin-top:.5rem;">
    <div>
      <h3>Learning Objectives</h3>
      <ol style="font-size:.9em;">
        <li>Understand dynamic array resizing strategy</li>
        <li>Analyze amortized O(1) for add-last</li>
        <li>Compare array list vs linked list tradeoffs</li>
        <li>Understand positional lists and iterators</li>
      </ol>
      <h3 style="margin-top:12px;">Key Demos</h3>
      <div class="card card-demo">
        <span class="tag tag-demo">Dynamic Resizing</span>
        <p style="font-size:.82em;">Watch array double when full. The cost counter shows expensive copies happen rarely — perfect for introducing amortized analysis.</p>
      </div>
      <div class="card card-demo">
        <span class="tag tag-demo">Shift Animation</span>
        <p style="font-size:.82em;">Insert at index 0 — watch ALL elements shift right. Makes O(n) insert-at-front viscerally obvious.</p>
      </div>
    </div>
    <div>
      <h3>Key Concept: Amortized Analysis</h3>
      <div class="card card-highlight">
        <p style="font-size:.85em;">This is many students' first encounter with amortized reasoning. Use the "banker's method" analogy: each cheap insert "saves up" credit for the occasional expensive resize.</p>
        <p style="font-size:.85em;margin-top:6px;color:#22c55e;">The resize counter demo is the killer slide here — show n insertions, count total copies, verify it's O(n) total → O(1) amortized.</p>
      </div>
      <h3 style="margin-top:12px;">Unit 1 Wrap-Up Connection</h3>
      <div class="card card-tip">
        <h4>The Full Picture</h4>
        <p style="font-size:.82em;">After this lecture, students have seen 4 linear structures. Draw a comparison table on the board: Linked List vs Array vs Stack vs Queue — operations, time complexity, use cases. This is great midterm review material.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ========== SLIDE 10: Unit 3A — Priority Queues ========== -->
<div class="slide" id="s10">
  <h2><span class="unit-badge u3">Unit 3</span> Priority Queues</h2>
  <p><code>priority-queues-enhanced.html</code> &nbsp;|&nbsp; 24 slides &nbsp;|&nbsp; <span class="tag tag-time">~60 min</span></p>
  <div class="grid2" style="margin-top:.5rem;">
    <div>
      <h3>Learning Objectives</h3>
      <ol style="font-size:.9em;">
        <li>Define PQ ADT: insert with priority, removeMin</li>
        <li>Compare sorted vs unsorted list implementations</li>
        <li>Understand why both are O(n) for one operation</li>
        <li>Motivate the need for heaps</li>
      </ol>
      <h3 style="margin-top:12px;">Key Demos</h3>
      <div class="card card-demo">
        <span class="tag tag-demo">Sorted vs Unsorted Toggle</span>
        <p style="font-size:.82em;">Same sequence of inserts — sorted list keeps order (O(n) insert, O(1) removeMin) vs unsorted list (O(1) insert, O(n) removeMin). The visual comparison is eye-opening.</p>
      </div>
    </div>
    <div>
      <h3>Teaching Strategy</h3>
      <div class="card card-tip">
        <h4>Motivate Before Defining</h4>
        <p style="font-size:.82em;">Start with: "Emergency room triage — who gets treated first?" Not FIFO (that's a regular queue). The person with highest priority. NOW define PQ.</p>
      </div>
      <div class="card card-highlight">
        <h4>The Tradeoff Slide is Key</h4>
        <p style="font-size:.82em;">Both implementations have one O(n) operation. "Can we get BOTH in O(log n)?" → This is the perfect cliffhanger for introducing heaps next class.</p>
      </div>
      <h3 style="margin-top:12px;">Foreshadowing</h3>
      <ul style="font-size:.85em;">
        <li>"Next class: heaps give us O(log n) for both operations"</li>
        <li>"Dijkstra's algorithm (Week 15) uses a PQ — the choice of PQ implementation affects the algorithm's speed"</li>
      </ul>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ========== SLIDE 11: Unit 3B — Heaps ========== -->
<div class="slide" id="s11">
  <h2><span class="unit-badge u3">Unit 3</span> Heaps</h2>
  <p><code>heap-enhanced.html</code> &nbsp;|&nbsp; 26 slides &nbsp;|&nbsp; <span class="tag tag-time">~75 min</span></p>
  <div class="grid2" style="margin-top:.5rem;">
    <div>
      <h3>Learning Objectives</h3>
      <ol style="font-size:.9em;">
        <li>Understand heap-order property and complete tree shape</li>
        <li>Map between tree and array representations</li>
        <li>Implement upheap (insert) and downheap (removeMin)</li>
        <li>Understand bottom-up heap construction O(n)</li>
        <li>Apply to heapsort</li>
      </ol>
      <h3 style="margin-top:12px;">Key Demos</h3>
      <div class="card card-demo">
        <span class="tag tag-demo">Upheap / Downheap Animation</span>
        <p style="font-size:.82em;">The tree + array dual view is the signature slide. Watch the node bubble up the tree while the array swaps below. Students see the correspondence instantly.</p>
      </div>
      <div class="card card-demo">
        <span class="tag tag-demo">Heapsort Playground</span>
        <p style="font-size:.82em;">Enter any array, watch build-heap then repeated extractMin. Sorted output accumulates on the right. Compare with selection sort.</p>
      </div>
    </div>
    <div>
      <h3>Common Misconceptions</h3>
      <div class="card card-warn">
        <h4>Heap ≠ BST</h4>
        <p style="font-size:.82em;">Students confuse heap-order with BST-order. In a min-heap, left child can be larger than right child! The tree visualization makes this clear.</p>
      </div>
      <div class="card card-warn">
        <h4>Array indexing confusion</h4>
        <p style="font-size:.82em;">parent(i) = (i-1)/2, children = 2i+1, 2i+2. Drill this with the challenge slide — students predict positions.</p>
      </div>
      <h3 style="margin-top:12px;">Key Insight to Emphasize</h3>
      <div class="card card-highlight">
        <h4>Bottom-up construction is O(n), not O(n log n)</h4>
        <p style="font-size:.82em;">This is unintuitive. Use the step-through to show that most nodes are near the bottom (short downheap), few are near the top (long downheap). The sum telescopes.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ========== SLIDE 12: Unit 4 — Maps & Hash Tables ========== -->
<div class="slide" id="s12">
  <h2><span class="unit-badge u4">Unit 4</span> Maps & Hash Tables</h2>
  <p><code>maps-enhanced.html</code> (22) + <code>hashtables-enhanced.html</code> (26) &nbsp;|&nbsp; <span class="tag tag-time">~2 lectures, 120 min total</span></p>
  <div class="grid2" style="margin-top:.5rem;">
    <div>
      <h3>Lecture 1: Maps (maps-enhanced.html)</h3>
      <ol style="font-size:.9em;">
        <li>Map ADT: get, put, remove, containsKey</li>
        <li>Unsorted list-based map: O(n) everything</li>
        <li>Applications: word frequency, symbol table</li>
        <li>Motivate: "can we do better than O(n)?" → hashing</li>
      </ol>
      <h3 style="margin-top:12px;">Lecture 2: Hash Tables (hashtables-enhanced.html)</h3>
      <ol style="font-size:.9em;">
        <li>Hash functions: mod, MAD, polynomial rolling</li>
        <li>Collision handling: chaining vs open addressing</li>
        <li>Load factor, rehashing, amortized O(1)</li>
        <li>When hashing goes wrong: clustering, worst case O(n)</li>
      </ol>
    </div>
    <div>
      <h3>Key Demos</h3>
      <div class="card card-demo">
        <span class="tag tag-demo">Hash Function Playground</span>
        <p style="font-size:.82em;">Students type keys, see hash values and bucket assignments. Try "bad" hash functions (always returns 0) → everything clusters.</p>
      </div>
      <div class="card card-demo">
        <span class="tag tag-demo">Chaining vs Probing Toggle</span>
        <p style="font-size:.82em;">Same insertions, two collision strategies side-by-side. Watch chains grow vs linear probing clusters form.</p>
      </div>
      <div class="card card-demo">
        <span class="tag tag-demo">Rehashing Animation</span>
        <p style="font-size:.82em;">Load factor crosses 0.75 → table doubles → all elements re-hash into new positions. Connects back to ArrayList resizing.</p>
      </div>
      <h3 style="margin-top:12px;">Common Misconceptions</h3>
      <div class="card card-warn">
        <h4>"Hash tables are always O(1)"</h4>
        <p style="font-size:.82em;">Average case O(1) with good hash + low load. Worst case O(n) if everything collides. Show the clustering demo.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ========== SLIDE 13: Unit 5 — Trees ========== -->
<div class="slide" id="s13">
  <h2><span class="unit-badge u5">Unit 5</span> Trees</h2>
  <p><code>trees-enhanced.html</code> &nbsp;|&nbsp; 28 slides &nbsp;|&nbsp; <span class="tag tag-time">~80 min</span></p>
  <div class="grid2" style="margin-top:.5rem;">
    <div>
      <h3>Learning Objectives</h3>
      <ol style="font-size:.9em;">
        <li>Tree terminology: root, parent, child, depth, height</li>
        <li>Binary tree properties and traversals (pre/in/post/level)</li>
        <li>BST operations: search, insert, delete</li>
        <li>BST worst case → motivation for balanced trees</li>
      </ol>
      <h3 style="margin-top:12px;">Key Demos</h3>
      <div class="card card-demo">
        <span class="tag tag-demo">Traversal Animations</span>
        <p style="font-size:.82em;">Toggle between preorder, inorder, postorder, level-order on the SAME tree. Watch the visit order change. Ask "which gives sorted output for a BST?"</p>
      </div>
      <div class="card card-demo">
        <span class="tag tag-demo">BST Playground</span>
        <p style="font-size:.82em;">Insert values, watch tree grow. Insert sorted data → degenerates to linked list! Then insert random data → balanced. This is the key visual for motivating AVL/Red-Black.</p>
      </div>
    </div>
    <div>
      <h3>Teaching Strategy</h3>
      <div class="card card-tip">
        <h4>Build from Known Structures</h4>
        <p style="font-size:.82em;">"A linked list is a degenerate tree (each node has one child). A heap IS a tree (but with different ordering). BST combines the search efficiency of binary search with the flexibility of a linked structure."</p>
      </div>
      <h3 style="margin-top:12px;">Common Misconceptions</h3>
      <div class="card card-warn">
        <h4>BST delete with two children</h4>
        <p style="font-size:.82em;">The "find inorder successor" step confuses students. Use the step-through to show: find min in right subtree, copy value, delete that node. Walk through 2-3 examples.</p>
      </div>
      <div class="card card-warn">
        <h4>Height vs Depth confusion</h4>
        <p style="font-size:.82em;">Height = longest path DOWN to leaf. Depth = path UP to root. The interactive tree lets students click nodes and see both values.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ========== SLIDE 14: Unit 6A — Graphs ========== -->
<div class="slide" id="s14">
  <h2><span class="unit-badge u6">Unit 6</span> Graphs</h2>
  <p><code>graph-enhanced.html</code> &nbsp;|&nbsp; 26 slides &nbsp;|&nbsp; <span class="tag tag-time">~70 min</span></p>
  <div class="grid2" style="margin-top:.5rem;">
    <div>
      <h3>Learning Objectives</h3>
      <ol style="font-size:.9em;">
        <li>Graph terminology: vertex, edge, path, cycle, degree</li>
        <li>Directed vs undirected, weighted vs unweighted</li>
        <li>Representations: adjacency matrix vs adjacency list</li>
        <li>Analyze space/time tradeoffs of representations</li>
      </ol>
      <h3 style="margin-top:12px;">Key Demos</h3>
      <div class="card card-demo">
        <span class="tag tag-demo">Build-a-Graph Playground</span>
        <p style="font-size:.82em;">Click to add nodes, drag to add edges. Toggle directed/undirected. Watch the adjacency matrix AND adjacency list update in real time. Students see the dual representation.</p>
      </div>
      <div class="card card-demo">
        <span class="tag tag-demo">Matrix vs List Space Comparison</span>
        <p style="font-size:.82em;">Toggle between sparse and dense graph — see matrix mostly empty (wasted space) vs list compact. Then dense → matrix fills up, list gets huge too.</p>
      </div>
    </div>
    <div>
      <h3>Teaching Strategy</h3>
      <div class="card card-tip">
        <h4>Real-World Motivation</h4>
        <p style="font-size:.82em;">Start with: "Social networks, road maps, the internet, course prerequisites — these are ALL graphs." Show 3-4 examples before formalizing. Students need to see WHY before WHAT.</p>
      </div>
      <div class="card card-highlight">
        <h4>This Lecture Sets Up Everything</h4>
        <p style="font-size:.82em;">BFS, DFS, Dijkstra, Bellman-Ford all build on this vocabulary and these representations. Spend extra time on adjacency list since most algorithms use it.</p>
      </div>
      <h3 style="margin-top:12px;">Common Misconceptions</h3>
      <div class="card card-warn">
        <h4>"Trees aren't graphs"</h4>
        <p style="font-size:.82em;">A tree IS a graph (connected, acyclic). This connection helps students see graphs as a generalization of everything they've learned.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ========== SLIDE 15: Unit 6B — BFS ========== -->
<div class="slide" id="s15">
  <h2><span class="unit-badge u6">Unit 6</span> BFS</h2>
  <p><code>bfs-enhanced.html</code> &nbsp;|&nbsp; 24 slides &nbsp;|&nbsp; <span class="tag tag-time">~65 min</span></p>
  <div class="grid2" style="margin-top:.5rem;">
    <div>
      <h3>Learning Objectives</h3>
      <ol style="font-size:.9em;">
        <li>Understand BFS as level-by-level exploration</li>
        <li>Implement with queue + visited set</li>
        <li>BFS finds shortest path in unweighted graphs</li>
        <li>Applications: social network distance, web crawling</li>
      </ol>
      <h3 style="margin-top:12px;">Key Demos</h3>
      <div class="card card-demo">
        <span class="tag tag-demo">BFS Step-Through</span>
        <p style="font-size:.82em;">Watch the queue state, visited set, and "discovery frontier" expand level by level. The level-coloring makes the "ripple" pattern obvious.</p>
      </div>
      <div class="card card-demo">
        <span class="tag tag-demo">Shortest Path (Unweighted)</span>
        <p style="font-size:.82em;">Click any two nodes — BFS finds the shortest path. Ask "why does BFS guarantee shortest path in unweighted graphs?" (Because it explores by distance.)</p>
      </div>
    </div>
    <div>
      <h3>Teaching Connection</h3>
      <div class="card card-tip">
        <h4>Queue → BFS, Stack → DFS</h4>
        <p style="font-size:.82em;">This is the single most important insight. "Replace the queue with a stack and you get DFS." The data structure choice determines the traversal pattern. Callback to Weeks 5-6!</p>
      </div>
      <h3 style="margin-top:12px;">Lecture Flow</h3>
      <ol style="font-size:.85em;">
        <li>Motivate: "find the fewest hops between two people on Facebook"</li>
        <li>Show BFS algorithm with queue visualization</li>
        <li>Step through example — emphasize level-by-level</li>
        <li>Prove: BFS finds shortest unweighted path</li>
        <li>Applications: social network, web crawling, maze solving</li>
        <li>Challenge: predict BFS order on a new graph</li>
      </ol>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ========== SLIDE 16: Unit 6C — DFS ========== -->
<div class="slide" id="s16">
  <h2><span class="unit-badge u6">Unit 6</span> DFS</h2>
  <p><code>dfs-enhanced.html</code> &nbsp;|&nbsp; 23 slides &nbsp;|&nbsp; <span class="tag tag-time">~70 min</span></p>
  <div class="grid2" style="margin-top:.5rem;">
    <div>
      <h3>Learning Objectives</h3>
      <ol style="font-size:.9em;">
        <li>Understand DFS as "go deep, then backtrack"</li>
        <li>Recursive and iterative (stack-based) implementations</li>
        <li>Edge classification: tree, back, forward, cross</li>
        <li>Applications: cycle detection, topological sort, SCCs</li>
      </ol>
      <h3 style="margin-top:12px;">Key Demos</h3>
      <div class="card card-demo">
        <span class="tag tag-demo">DFS with Call Stack</span>
        <p style="font-size:.82em;">Watch the recursion call stack grow and shrink alongside the graph traversal. Discovery/finish times animate on a timeline.</p>
      </div>
      <div class="card card-demo">
        <span class="tag tag-demo">BFS vs DFS Toggle</span>
        <p style="font-size:.82em;">Same graph, toggle between BFS and DFS — dramatically different traversal orders. Ask "when would you prefer each?"</p>
      </div>
      <div class="card card-demo">
        <span class="tag tag-demo">Topological Sort</span>
        <p style="font-size:.82em;">Course prerequisite DAG — DFS finish order reversed gives valid course sequence. Students see why it works.</p>
      </div>
    </div>
    <div>
      <h3>Teaching Strategy</h3>
      <div class="card card-tip">
        <h4>Teach BFS and DFS Together</h4>
        <p style="font-size:.82em;">Cover BFS and DFS in consecutive lectures. The comparison slide is essential — same graph, different structure. Students who see them side-by-side retain both better.</p>
      </div>
      <h3 style="margin-top:12px;">Deep Dive Topics</h3>
      <div class="card card-highlight">
        <h4>Edge Classification (advanced)</h4>
        <p style="font-size:.82em;">WHITE/GRAY/BLACK coloring determines edge types. Back edge → cycle. This is beautiful theory but can overwhelm — gauge the class. The step-through with colors helps enormously.</p>
      </div>
      <h3 style="margin-top:12px;">Challenge Highlight</h3>
      <div class="card card-demo">
        <span class="tag tag-exercise">sCB — Fix the Bug</span>
        <p style="font-size:.82em;">Missing visited check → infinite loop. This is the most impactful bug-fix challenge. Students who debug this remember to check visited forever.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ========== SLIDE 17: Unit 6D — Shortest Path ========== -->
<div class="slide" id="s17">
  <h2><span class="unit-badge u6">Unit 6</span> Shortest Path</h2>
  <p><code>shortest-path-enhanced.html</code> &nbsp;|&nbsp; 24 slides &nbsp;|&nbsp; <span class="tag tag-time">~80 min</span></p>
  <div class="grid2" style="margin-top:.5rem;">
    <div>
      <h3>Learning Objectives</h3>
      <ol style="font-size:.9em;">
        <li>Understand edge relaxation as the core operation</li>
        <li>Dijkstra's: greedy + PQ, O(E log V), non-negative only</li>
        <li>Bellman-Ford: V-1 iterations, handles negative weights</li>
        <li>Detect negative cycles with the V-th pass</li>
        <li>Choose the right algorithm for the scenario</li>
      </ol>
      <h3 style="margin-top:12px;">Key Demos</h3>
      <div class="card card-demo">
        <span class="tag tag-demo">Dijkstra Cloud Expansion</span>
        <p style="font-size:.82em;">The "expanding cloud" visualization makes the greedy choice intuitive. Step through with PQ + dist table in sync.</p>
      </div>
      <div class="card card-demo">
        <span class="tag tag-demo">Dijkstra FAILS Demo</span>
        <p style="font-size:.82em;">Run Dijkstra on a negative-weight graph — watch it produce the WRONG answer. Then run Bellman-Ford on the same graph — correct! This contrast is unforgettable.</p>
      </div>
    </div>
    <div>
      <h3>Teaching Strategy</h3>
      <div class="card card-tip">
        <h4>Build Up to the Limitation</h4>
        <p style="font-size:.82em;">Spend 40 min on Dijkstra (slides 1-10): concept, relaxation, full trace. Students should feel confident. THEN drop the bomb: "it breaks with negative weights." The failure demo creates cognitive tension that motivates Bellman-Ford.</p>
      </div>
      <div class="card card-highlight">
        <h4>Edge Relaxation Interactive</h4>
        <p style="font-size:.82em;">Slide 6 lets students enter dist[u], weight, dist[v] and see if relaxation triggers. Use this early — if students grok relaxation, both algorithms are easy.</p>
      </div>
      <h3 style="margin-top:12px;">Capstone Connection</h3>
      <div class="card card-tip">
        <h4>Everything Comes Together</h4>
        <p style="font-size:.82em;">Dijkstra uses: graphs (W13), PQ/heap (W9-10), greedy strategy. Bellman-Ford uses: edge relaxation (DP pattern). BFS = unweighted shortest path. This lecture ties the whole course together.</p>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ========== SLIDE 18: Assessment Strategy ========== -->
<div class="slide" id="s18">
  <h2>Assessment Strategy</h2>
  <div class="grid2">
    <div>
      <h3>In-Class (using Enhanced Slides)</h3>
      <div class="card card-highlight">
        <h4>Think-Pair-Share at Challenge Slides</h4>
        <p style="font-size:.82em;">Every deck has 3 inline challenges (sCA, sCB, sCC). Pause, give 2-3 min, have students discuss with a partner, then reveal. Great for formative assessment.</p>
      </div>
      <div class="card card-highlight">
        <h4>Exit Tickets (sQ1-sQ3)</h4>
        <p style="font-size:.82em;">Final 3 slides of each deck are quiz questions. Use as end-of-class check: sQ1 = quick multiple choice, sQ2 = trace exercise, sQ3 = predict code output. Collect responses via hand-raise or clicker.</p>
      </div>
      <div class="card card-highlight">
        <h4>Live Coding Challenges</h4>
        <p style="font-size:.82em;">After the playground demo, ask a student to "predict what happens if we insert 42" before clicking. Builds active engagement.</p>
      </div>
    </div>
    <div>
      <h3>Exam Question Types</h3>
      <div class="card">
        <h4>Type 1: Trace an Algorithm</h4>
        <p style="font-size:.82em;">"Show the state of the heap after inserting 5, 3, 8, 1, 7." Mirrors the step-through animations — students who practiced with interactive slides ace these.</p>
      </div>
      <div class="card">
        <h4>Type 2: Compare & Choose</h4>
        <p style="font-size:.82em;">"For each scenario, which data structure is best?" Mirrors the sCC challenge slides. Tests deeper understanding.</p>
      </div>
      <div class="card">
        <h4>Type 3: Complexity Analysis</h4>
        <p style="font-size:.82em;">"What is the time complexity of X using Y?" Requires connecting structure to operations.</p>
      </div>
      <div class="card">
        <h4>Type 4: Code Bug / Fix</h4>
        <p style="font-size:.82em;">"This code has a bug. Identify and fix it." Mirrors sCB slides. Tests practical understanding.</p>
      </div>
      <h3 style="margin-top:12px;">Suggested Exam Split</h3>
      <p style="font-size:.85em;">Midterm: Units 1-2 (Weeks 1-7)<br>Final: Units 3-6 (Weeks 9-15), cumulative</p>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ========== SLIDE 19: Concept Dependency Map ========== -->
<div class="slide" id="s19">
  <h2>Concept Dependency Map</h2>
  <p class="subtitle">How topics connect — use this to emphasize callbacks during lectures</p>
  <canvas id="cS19" width="900" height="480" style="width:100%;max-width:900px;background:rgba(0,0,0,0.2);border-radius:12px;margin:10px auto;display:block;"></canvas>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS19'),ctx=canvas.getContext('2d');
  const topics=[
    {id:'LL',label:'Linked\nLists',x:80,y:120,color:'#6366f1'},
    {id:'AA',label:'Algorithm\nAnalysis',x:80,y:280,color:'#22c55e'},
    {id:'REC',label:'Recursion',x:80,y:400,color:'#22c55e'},
    {id:'STK',label:'Stacks',x:230,y:80,color:'#6366f1'},
    {id:'QUE',label:'Queues',x:230,y:200,color:'#6366f1'},
    {id:'AL',label:'ArrayLists',x:230,y:320,color:'#6366f1'},
    {id:'PQ',label:'Priority\nQueues',x:400,y:120,color:'#f59e0b'},
    {id:'HEAP',label:'Heaps',x:400,y:260,color:'#f59e0b'},
    {id:'MAP',label:'Maps',x:540,y:80,color:'#ec4899'},
    {id:'HT',label:'Hash\nTables',x:540,y:220,color:'#ec4899'},
    {id:'TREE',label:'Trees',x:540,y:380,color:'#0ea5e9'},
    {id:'GR',label:'Graphs',x:700,y:120,color:'#a78bfa'},
    {id:'BFS',label:'BFS',x:700,y:260,color:'#a78bfa'},
    {id:'DFS',label:'DFS',x:700,y:380,color:'#a78bfa'},
    {id:'SP',label:'Shortest\nPath',x:830,y:300,color:'#a78bfa'}
  ];
  const deps=[
    ['LL','STK'],['LL','QUE'],['LL','AL'],
    ['AA','PQ'],['AA','HEAP'],['AA','HT'],
    ['REC','DFS'],['REC','TREE'],
    ['STK','DFS'],['QUE','BFS'],
    ['AL','HEAP'],['AL','HT'],
    ['PQ','HEAP'],['PQ','SP'],
    ['HEAP','SP'],
    ['MAP','HT'],
    ['TREE','GR'],['TREE','HEAP'],
    ['GR','BFS'],['GR','DFS'],['GR','SP'],
    ['BFS','SP'],['DFS','SP']
  ];

  function draw(){
    ctx.clearRect(0,0,900,480);
    // Deps
    deps.forEach(([from,to])=>{
      const f=topics.find(t=>t.id===from),t2=topics.find(t=>t.id===to);
      ctx.strokeStyle='rgba(148,163,184,0.25)';ctx.lineWidth=1.5;
      ctx.beginPath();ctx.moveTo(f.x,f.y);ctx.lineTo(t2.x,t2.y);ctx.stroke();
      // Arrow
      const dx=t2.x-f.x,dy=t2.y-f.y,len=Math.sqrt(dx*dx+dy*dy);
      const ux=dx/len,uy=dy/len;
      const ax=t2.x-ux*28,ay=t2.y-uy*28;
      ctx.fillStyle='rgba(148,163,184,0.3)';ctx.beginPath();
      ctx.moveTo(ax,ay);ctx.lineTo(ax-ux*6+uy*3,ay-uy*6-ux*3);ctx.lineTo(ax-ux*6-uy*3,ay-uy*6+ux*3);ctx.fill();
    });
    // Nodes
    topics.forEach(t=>{
      ctx.beginPath();ctx.arc(t.x,t.y,26,0,Math.PI*2);
      ctx.fillStyle=t.color;ctx.globalAlpha=0.2;ctx.fill();ctx.globalAlpha=1;
      ctx.strokeStyle=t.color;ctx.lineWidth=2;ctx.stroke();
      ctx.fillStyle='#e2e8f0';ctx.font='bold 10px sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';
      const lines=t.label.split('\n');
      lines.forEach((line,i)=>{
        ctx.fillText(line,t.x,t.y+(i-(lines.length-1)/2)*12);
      });
    });
    // Unit labels
    ctx.font='11px sans-serif';ctx.fillStyle='#64748b';ctx.textAlign='left';
    ctx.fillText('Unit 1: Linear',10,30);ctx.fillText('Unit 2: Analysis',10,60);
    ctx.fillText('Unit 3: Priority',340,30);ctx.fillText('Unit 4: Associative',480,30);
    ctx.fillText('Unit 5: Trees',480,430);ctx.fillText('Unit 6: Graphs',640,30);
  }
  function init(){draw();}
  const obs=new MutationObserver(()=>{if(document.getElementById('s19').classList.contains('active'))init();});
  obs.observe(document.getElementById('s19'),{attributes:true,attributeFilter:['class']});
  init();
})();
</script>

<!-- ========== SLIDE 20: Complexity Cheat Sheet ========== -->
<div class="slide" id="s20">
  <h2>Complexity Cheat Sheet</h2>
  <p class="subtitle">Quick reference for all data structures covered</p>
  <canvas id="cS20" width="880" height="440" style="width:100%;max-width:880px;background:rgba(0,0,0,0.2);border-radius:12px;margin:8px auto;display:block;"></canvas>
  <div class="slide-number"></div>
</div>
<script>
(function(){
  const canvas=document.getElementById('cS20'),ctx=canvas.getContext('2d');
  const data=[
    {ds:'Array List',       insert:'O(1)*',search:'O(n)',delete:'O(n)',  notes:'*amortized, O(n) at index 0'},
    {ds:'Linked List',      insert:'O(1)†', search:'O(n)',delete:'O(1)†',notes:'†at head; O(n) to find position'},
    {ds:'Stack (array)',     insert:'O(1)', search:'O(n)',delete:'O(1)', notes:'push/pop only'},
    {ds:'Queue (circular)',  insert:'O(1)', search:'O(n)',delete:'O(1)', notes:'enqueue/dequeue only'},
    {ds:'Unsorted PQ',      insert:'O(1)', search:'—',   delete:'O(n)', notes:'removeMin scans all'},
    {ds:'Sorted PQ',        insert:'O(n)', search:'—',   delete:'O(1)', notes:'insert keeps order'},
    {ds:'Binary Heap',      insert:'O(log n)',search:'—', delete:'O(log n)',notes:'insert+removeMin'},
    {ds:'Hash Table',       insert:'O(1)*',search:'O(1)*',delete:'O(1)*',notes:'*avg; O(n) worst'},
    {ds:'BST (balanced)',   insert:'O(log n)',search:'O(log n)',delete:'O(log n)',notes:'O(n) if unbalanced'},
    {ds:'Dijkstra (heap)',  insert:'—',    search:'—',   delete:'—',    notes:'O((V+E) log V)'},
    {ds:'Bellman-Ford',     insert:'—',    search:'—',   delete:'—',    notes:'O(V · E)'},
  ];

  function draw(){
    ctx.clearRect(0,0,880,440);
    const cols=[170,75,75,75,340];
    const headers=['Data Structure','Insert','Search','Delete','Notes'];
    const rh=34,sx=20,sy=15;
    // Header
    let cx=sx;
    headers.forEach((h,i)=>{
      ctx.fillStyle='#334155';ctx.fillRect(cx,sy,cols[i],rh);
      ctx.strokeStyle='#475569';ctx.lineWidth=1;ctx.strokeRect(cx,sy,cols[i],rh);
      ctx.fillStyle='#38bdf8';ctx.font='bold 12px monospace';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(h,cx+cols[i]/2,sy+rh/2);
      cx+=cols[i];
    });
    // Rows
    data.forEach((row,r)=>{
      cx=sx;const y=sy+rh*(r+1);
      const vals=[row.ds,row.insert,row.search,row.delete,row.notes];
      vals.forEach((v,c)=>{
        ctx.fillStyle=r%2===0?'#1e293b':'#1a2332';
        ctx.fillRect(cx,y,cols[c],rh);
        ctx.strokeStyle='#334155';ctx.lineWidth=1;ctx.strokeRect(cx,y,cols[c],rh);
        let color='#cbd5e1';
        if(c>=1&&c<=3){
          if(v==='O(1)'||v==='O(1)*'||v==='O(1)†')color='#22c55e';
          else if(v==='O(log n)')color='#38bdf8';
          else if(v==='O(n)')color='#f59e0b';
          else color='#64748b';
        }
        ctx.fillStyle=color;
        ctx.font=c===0?'bold 11px monospace':c===4?'10px monospace':'12px monospace';
        ctx.textAlign=c===0||c===4?'left':'center';
        ctx.fillText(v,c===0||c===4?cx+8:cx+cols[c]/2,y+rh/2);
        cx+=cols[c];
      });
    });
    // Legend
    const ly=sy+rh*(data.length+1)+10;
    ctx.font='11px sans-serif';ctx.textAlign='left';
    [{c:'#22c55e',l:'O(1) — constant'},{c:'#38bdf8',l:'O(log n) — logarithmic'},{c:'#f59e0b',l:'O(n) — linear'}].forEach((item,i)=>{
      ctx.fillStyle=item.c;ctx.fillRect(sx+i*220,ly,12,12);
      ctx.fillStyle='#94a3b8';ctx.fillText(item.l,sx+i*220+16,ly+10);
    });
  }
  function init(){draw();}
  const obs=new MutationObserver(()=>{if(document.getElementById('s20').classList.contains('active'))init();});
  obs.observe(document.getElementById('s20'),{attributes:true,attributeFilter:['class']});
  init();
})();
</script>

<!-- ========== SLIDE 21: Deck Quick Reference ========== -->
<div class="slide" id="s21">
  <h2>Enhanced Deck Quick Reference</h2>
  <p class="subtitle">All 15 decks with slide counts and key interactive features</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:.5rem;font-size:.85em;">
    <div>
      <div class="card" style="padding:10px 14px;"><span class="unit-badge u1" style="font-size:.65em;">U1</span> <strong>linked-list-enhanced.html</strong> <small>(27 slides)</small><br><small>Step-through insert/delete, interactive playground, SVG diagrams</small></div>
      <div class="card" style="padding:10px 14px;"><span class="unit-badge u2" style="font-size:.65em;">U2</span> <strong>algorithm-analysis-enhanced.html</strong> <small>(24 slides)</small><br><small>Growth rate race, loop counter, O/Ω/Θ toggle</small></div>
      <div class="card" style="padding:10px 14px;"><span class="unit-badge u2" style="font-size:.65em;">U2</span> <strong>recursion-enhanced.html</strong> <small>(24 slides)</small><br><small>Call stack visualizer, Fibonacci tree, Tower of Hanoi</small></div>
      <div class="card" style="padding:10px 14px;"><span class="unit-badge u1" style="font-size:.65em;">U1</span> <strong>stacks-enhanced.html</strong> <small>(23 slides)</small><br><small>Parentheses matcher, postfix evaluator, push/pop animation</small></div>
      <div class="card" style="padding:10px 14px;"><span class="unit-badge u1" style="font-size:.65em;">U1</span> <strong>queues-enhanced.html</strong> <small>(23 slides)</small><br><small>Circular array viz, stack vs queue race, BFS preview</small></div>
      <div class="card" style="padding:10px 14px;"><span class="unit-badge u1" style="font-size:.65em;">U1</span> <strong>arraylists-enhanced.html</strong> <small>(23 slides)</small><br><small>Dynamic resizing, shift animation, amortized counter</small></div>
      <div class="card" style="padding:10px 14px;"><span class="unit-badge u3" style="font-size:.65em;">U3</span> <strong>priority-queues-enhanced.html</strong> <small>(24 slides)</small><br><small>Sorted vs unsorted toggle, PQ operations, comparator demo</small></div>
      <div class="card" style="padding:10px 14px;"><span class="unit-badge u3" style="font-size:.65em;">U3</span> <strong>heap-enhanced.html</strong> <small>(26 slides)</small><br><small>Upheap/downheap with tree+array, build-heap, heapsort playground</small></div>
    </div>
    <div>
      <div class="card" style="padding:10px 14px;"><span class="unit-badge u4" style="font-size:.65em;">U4</span> <strong>maps-enhanced.html</strong> <small>(22 slides)</small><br><small>Map operations, list-based implementation, word frequency</small></div>
      <div class="card" style="padding:10px 14px;"><span class="unit-badge u4" style="font-size:.65em;">U4</span> <strong>hashtables-enhanced.html</strong> <small>(26 slides)</small><br><small>Hash playground, chaining vs probing, rehashing animation</small></div>
      <div class="card" style="padding:10px 14px;"><span class="unit-badge u5" style="font-size:.65em;">U5</span> <strong>trees-enhanced.html</strong> <small>(28 slides)</small><br><small>4 traversal animations, BST playground, delete step-through</small></div>
      <div class="card" style="padding:10px 14px;"><span class="unit-badge u6" style="font-size:.65em;">U6</span> <strong>graph-enhanced.html</strong> <small>(26 slides)</small><br><small>Build-a-graph, matrix vs list, directed/undirected toggle</small></div>
      <div class="card" style="padding:10px 14px;"><span class="unit-badge u6" style="font-size:.65em;">U6</span> <strong>bfs-enhanced.html</strong> <small>(24 slides)</small><br><small>Level-by-level BFS, queue state, shortest path demo</small></div>
      <div class="card" style="padding:10px 14px;"><span class="unit-badge u6" style="font-size:.65em;">U6</span> <strong>dfs-enhanced.html</strong> <small>(23 slides)</small><br><small>Call stack + graph, edge classification, topological sort, maze</small></div>
      <div class="card" style="padding:10px 14px;"><span class="unit-badge u6" style="font-size:.65em;">U6</span> <strong>shortest-path-enhanced.html</strong> <small>(24 slides)</small><br><small>Dijkstra cloud, relaxation interactive, Bellman-Ford, neg cycle</small></div>
      <div class="card" style="padding:10px 14px;background:#334155;border-color:#6366f1;">
        <strong style="color:#38bdf8;">Total: 367 interactive slides</strong><br>
        <small>Each with Canvas visualizations, step-throughs, and challenge quizzes</small>
      </div>
    </div>
  </div>
  <div class="slide-number"></div>
</div>

<!-- ==================== NAVIGATION ==================== -->
<div class="nav">
  <button id="prevBtn" onclick="navigate(-1)">&#9664; Prev</button>
  <button id="nextBtn" onclick="navigate(1)">Next &#9654;</button>
</div>

<!-- ==================== NAVIGATION JS ==================== -->
<script>
const slideOrder = ['s1','s2','s3','s4','s5','s6','s7','s8','s9','s10','s11','s12','s13','s14','s15','s16','s17','s18','s19','s20','s21'];
let currentIdx = 0;

function showSlide(idx) {
  slideOrder.forEach(id => document.getElementById(id).classList.remove('active'));
  const slideEl = document.getElementById(slideOrder[idx]);
  slideEl.classList.add('active');
  slideEl.classList.remove('fade-in');
  void slideEl.offsetWidth;
  slideEl.classList.add('fade-in');
  document.getElementById('prevBtn').disabled = (idx === 0);
  document.getElementById('nextBtn').disabled = (idx === slideOrder.length - 1);
  const pct = slideOrder.length > 1 ? (idx / (slideOrder.length - 1)) * 100 : 0;
  document.getElementById('progress').style.width = pct + '%';
}

function navigate(dir) {
  const next = currentIdx + dir;
  if (next < 0 || next >= slideOrder.length) return;
  currentIdx = next;
  showSlide(currentIdx);
}

document.addEventListener('keydown', (e) => {
  const tag = document.activeElement.tagName;
  if (tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA') return;
  if (e.key === 'ArrowRight') navigate(1);
  if (e.key === 'ArrowLeft') navigate(-1);
});

showSlide(0);
</script>
</body>
</html>
